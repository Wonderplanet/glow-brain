# 実装例: ミッション仕様書の要件抽出・分類

このドキュメントは、ミッション仕様書から要件を抽出・分類する実践例です。

## 元の仕様書（サンプル）

```markdown
# ミッション機能 ゲーム体験仕様書

## 概要
新しいデイリーミッション機能を追加し、ユーザーの継続率向上を目指す。

## 機能説明
- ユーザーは毎日更新されるミッションを確認できる
- ミッションを達成すると自動的に報酬が付与される
- ミッション達成時には特別な演出が表示される
- 達成済みミッションは一覧で確認できる

## 運用要件
- ミッションのON/OFFは設定テーブルで切り替え可能
- 報酬内容は管理画面から変更可能
- 設定変更は即時反映される

## 技術要件
- レスポンスは500ms以内を保証
- 報酬の二重付与を防止する仕組みが必要
- 既存のuser_missionsテーブルを使用する
- 既存のRewardUseCaseを流用して実装する
- 新しいUseCaseは作成しない

## 制約
- 既存のミッションAPIとの互換性を維持する
- Laravel 8系で実装する
```

## 抽出プロセス

### ステップ1: セクションごとに要件候補を抽出

#### 概要セクション
- 「継続率向上を目指す」 → ビジネス要件

#### 機能説明セクション
- 「毎日更新されるミッションを確認できる」 → 機能要件
- 「ミッション達成すると自動的に報酬が付与される」 → 機能要件
- 「特別な演出が表示される」 → 機能要件
- 「達成済みミッションは一覧で確認できる」 → 機能要件

#### 運用要件セクション
- 「設定テーブルでON/OFF切り替え可能」 → 運用要件
- 「管理画面から報酬内容を変更可能」 → 運用要件
- 「設定変更は即時反映」 → 運用要件

#### 技術要件セクション
- 「レスポンス500ms以内」 → 非機能要件
- 「報酬の二重付与を防止」 → 非機能要件
- 「既存のuser_missionsテーブルを使用」 → 制約条件
- 「既存のRewardUseCaseを流用」 → 実装要件
- 「新しいUseCaseは作成しない」 → 実装要件

#### 制約セクション
- 「既存ミッションAPIとの互換性維持」 → 制約条件
- 「Laravel 8系で実装」 → 制約条件

### ステップ2: 分類ルールに基づいて分類

各要件を6つのカテゴリに分類します。

## 分類結果

### Markdownテーブル形式

```markdown
# 要件分類結果: ミッション機能

## 1. 機能要件（Functional Requirement）

| No | 要件 | 説明 |
|---|---|---|
| F-1 | デイリーミッション表示 | ユーザーは毎日更新されるミッションを確認できる |
| F-2 | 自動報酬付与 | ミッション達成時に自動的に報酬が付与される |
| F-3 | 達成演出表示 | ミッション達成時には特別な演出が表示される |
| F-4 | 達成履歴確認 | 達成済みミッションを一覧で確認できる |

## 2. 非機能要件（Non-Functional Requirement）

| No | 要件 | 説明 |
|---|---|---|
| NF-1 | レスポンス時間保証 | APIレスポンスは500ms以内を保証する |
| NF-2 | 二重付与防止 | 報酬の二重付与を防止する仕組みが必要 |

## 3. 運用要件（Operational Requirement）

| No | 要件 | 説明 |
|---|---|---|
| O-1 | 機能ON/OFF制御 | ミッションのON/OFFは設定テーブルで切り替え可能 |
| O-2 | 報酬内容変更 | 報酬内容は管理画面から変更可能 |
| O-3 | 即時反映 | 設定変更は即時反映される |

## 4. 制約条件（Constraint）

| No | 要件 | 説明 |
|---|---|---|
| C-1 | 既存テーブル使用 | 既存のuser_missionsテーブルを使用する |
| C-2 | API互換性維持 | 既存のミッションAPIとの互換性を維持する |
| C-3 | Laravelバージョン | Laravel 8系で実装する |

## 5. 実装要件（Implementation Requirement）

| No | 要件 | 説明 |
|---|---|---|
| I-1 | 既存UseCase流用 | 既存のRewardUseCaseを流用して実装する |
| I-2 | 新規UseCase禁止 | 新しいUseCaseは作成しない |

## 6. ビジネス要件（Business Requirement）

| No | 要件 | 説明 |
|---|---|---|
| B-1 | 継続率向上 | 新デイリーミッション機能により継続率向上を目指す |

## 要約

- **機能要件**: 4件
- **非機能要件**: 2件
- **運用要件**: 3件
- **制約条件**: 3件
- **実装要件**: 2件
- **ビジネス要件**: 1件
- **合計**: 15件
```

## 分類のポイント解説

### F-1（デイリーミッション表示）
- **判定**: 機能要件
- **理由**: ユーザーが「できること」が変わる（ミッションを確認できる）
- **判定軸**: 「ユーザーが『できること』が変わるか」→ Yes

### NF-1（レスポンス時間保証）
- **判定**: 非機能要件
- **理由**: 体験の内容ではなく「質」（速さ）の話
- **判定軸**: 「品質・安全・速さ？」→ Yes（速さ）

### O-1（機能ON/OFF制御）
- **判定**: 運用要件
- **理由**: 運営が「どう触れるか」の話
- **判定軸**: 「運営が『どう触れる』か？」→ Yes（設定テーブルで切り替え）

### C-1（既存テーブル使用）
- **判定**: 制約条件
- **理由**: 設計の選択肢を縛る前提条件
- **判定軸**: 「『こうしなければならない』という縛りか？」→ Yes

### I-1（既存UseCase流用）
- **判定**: 実装要件
- **理由**: 設計・実装レベルでの実現方針
- **判定軸**: 「『どう作るか』『どう実装するか』の話か？」→ Yes

### B-1（継続率向上）
- **判定**: ビジネス要件
- **理由**: なぜやるのか、何を達成したいのかの話
- **判定軸**: 「技術ではなく目的・背景・KPIの話か？」→ Yes

## 迷った要件の判定例

### 「ミッション達成時に自動的に報酬が付与される」

**候補:**
- 機能要件: 報酬が付与されるという体験
- 非機能要件: 「自動的に」という実装の質？

**判定:** 機能要件

**理由:**
- 「自動的に」は実装の詳細ではなく、ユーザー体験の一部
- ユーザーから見て「何が起きるか」が定義されている
- 非機能要件は「遅い・落ちる・壊れる」を防ぐ条件であり、これは該当しない

## JSON形式の出力例

```json
{
  "functional_requirements": [
    {
      "no": "F-1",
      "name": "デイリーミッション表示",
      "description": "ユーザーは毎日更新されるミッションを確認できる"
    },
    {
      "no": "F-2",
      "name": "自動報酬付与",
      "description": "ミッション達成時に自動的に報酬が付与される"
    },
    {
      "no": "F-3",
      "name": "達成演出表示",
      "description": "ミッション達成時には特別な演出が表示される"
    },
    {
      "no": "F-4",
      "name": "達成履歴確認",
      "description": "達成済みミッションを一覧で確認できる"
    }
  ],
  "non_functional_requirements": [
    {
      "no": "NF-1",
      "name": "レスポンス時間保証",
      "description": "APIレスポンスは500ms以内を保証する"
    },
    {
      "no": "NF-2",
      "name": "二重付与防止",
      "description": "報酬の二重付与を防止する仕組みが必要"
    }
  ],
  "operational_requirements": [
    {
      "no": "O-1",
      "name": "機能ON/OFF制御",
      "description": "ミッションのON/OFFは設定テーブルで切り替え可能"
    },
    {
      "no": "O-2",
      "name": "報酬内容変更",
      "description": "報酬内容は管理画面から変更可能"
    },
    {
      "no": "O-3",
      "name": "即時反映",
      "description": "設定変更は即時反映される"
    }
  ],
  "constraints": [
    {
      "no": "C-1",
      "name": "既存テーブル使用",
      "description": "既存のuser_missionsテーブルを使用する"
    },
    {
      "no": "C-2",
      "name": "API互換性維持",
      "description": "既存のミッションAPIとの互換性を維持する"
    },
    {
      "no": "C-3",
      "name": "Laravelバージョン",
      "description": "Laravel 8系で実装する"
    }
  ],
  "implementation_requirements": [
    {
      "no": "I-1",
      "name": "既存UseCase流用",
      "description": "既存のRewardUseCaseを流用して実装する"
    },
    {
      "no": "I-2",
      "name": "新規UseCase禁止",
      "description": "新しいUseCaseは作成しない"
    }
  ],
  "business_requirements": [
    {
      "no": "B-1",
      "name": "継続率向上",
      "description": "新デイリーミッション機能により継続率向上を目指す"
    }
  ],
  "summary": {
    "functional_requirements": 4,
    "non_functional_requirements": 2,
    "operational_requirements": 3,
    "constraints": 3,
    "implementation_requirements": 2,
    "business_requirements": 1,
    "total": 15
  }
}
```

## まとめ

この例では、以下のポイントに注意して分類を行いました:

1. **判定軸を活用**: 迷ったときは classification-rules.md の判定軸に立ち返る
2. **文脈を考慮**: セクション名だけでなく、前後の文脈も参考にする
3. **複合的な記述を分解**: 1つの文に複数の要件が含まれる場合は分解して抽出
4. **一貫性を保つ**: 同じカテゴリ内では説明の粒度を統一

## 後続フロー

要件整理が完了したら、実装するコンポーネントに応じて次のステップに進みます:

### サーバー実装の場合
- `api-design-principles` スキルで設計原則を参照しながらAPI設計書を作成
- サーバーAPI実装

### クライアント実装の場合
- クライアント設計書を作成（※今後、クライアント向けスキル作成予定）
- クライアント実装
