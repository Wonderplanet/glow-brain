# マスタデータ配信機構

## 概要

本プロジェクトでは、マスタデータをサーバーAPIを介さず、S3から直接クライアントにダウンロードする方式を採用しています。

これにより、以下のメリットが得られます：
- サーバーAPIへの負荷軽減
- クライアント側での効率的なデータ取得
- CDN活用によるグローバル配信の最適化

## 全体フロー

```
┌──────────────────┐
│ 1. マスタデータ作成 │
│  (管理ツール/admin) │
└─────────┬────────┘
          │
          │ スプレッドシート → DB投入
          │ → JSON/MessagePack生成
          │ → S3アップロード
          ↓
┌──────────────────┐
│ 2. リリース管理    │
│  (mng_master_*)   │
└─────────┬────────┘
          │
          │ バージョン情報・ハッシュ値を保存
          │
          ↓
┌──────────────────┐
│ 3. バージョン情報配信│
│  (game/version API)│
└─────────┬────────┘
          │
          │ S3パス・ハッシュ値を返す
          │
          ↓
┌──────────────────┐
│ 4. データダウンロード │
│    (クライアント)   │
└──────────────────┘
       ↓
   S3から直接取得
```

## 1. マスタデータ作成・管理（管理ツール）

### 使用ライブラリ

**lib/laravel-wp-master-asset-release-admin**

管理ツール（admin）側でマスタデータとアセットデータのリリース管理を行うための基盤ライブラリです。

### 主な機能

#### 1.1 マスタデータのインポート

- Googleスプレッドシートからマスタデータを取得
- CSVフォーマットに変換
- データベース（mstDB）に投入

関連ファイル：
- `Operators/GoogleSpreadSheetOperator.php` - スプレッドシートアクセス
- `Services/MasterDataImportService.php` - マスタデータインポート処理
- `Services/DatabaseImportService.php` - DB投入処理

#### 1.2 クライアント配信用ファイルの生成

マスタデータをクライアントがダウンロード可能な形式に変換します。

生成されるファイル：
- **JSON形式**: `{target}/{target}_{hash}.json`
- **MessagePack形式**: `{target}/{target}_{hash}.data`

対象データ：
- **masterdata (mst)**: マスタデータ（キャラクター、アイテム、ステージ等の固定データ）
- **operationdata (opr)**: オペレーションデータ（イベント、ガチャ等の運用データ）

多言語対応：
- 各言語ごとに国際化ファイルを生成
  - `masterdata_i18n/{language}/masterdata_i18n_{hash}.json`
  - `operationdata_i18n/{language}/operationdata_i18n_{hash}.json`
- 対応言語: ja（日本語）、en（英語）、zh（中国語）

関連ファイル：
- `Operators/SerializedDataFileOperator.php` - ファイル生成・暗号化
- `Utils/MasterDataUtility.php` - パス生成ユーティリティ

ファイル処理の詳細：
```php
// JSON形式で保存
writeAsJson($path, $data)

// MessagePack形式で保存（バイナリ圧縮）
writeAsMessagePack($path, $data)

// 圧縮・暗号化処理
gzipAndEncryptMasterdataFile($path, $output, $setting)
```

#### 1.3 S3へのアップロード

生成したファイルをS3にアップロードします。

S3パス構造：
```
s3://bucket-name/
  └── {release_key}/               # リリースキー（バージョン識別子）
      ├── masterdata/
      │   └── masterdata_{hash}.json
      ├── masterdata_i18n/
      │   ├── ja/
      │   │   └── masterdata_i18n_{hash}.json
      │   ├── en/
      │   │   └── masterdata_i18n_{hash}.json
      │   └── zh/
      │       └── masterdata_i18n_{hash}.json
      ├── operationdata/
      │   └── operationdata_{hash}.json
      └── operationdata_i18n/
          ├── ja/
          │   └── operationdata_i18n_{hash}.json
          ├── en/
          │   └── operationdata_i18n_{hash}.json
          └── zh/
              └── operationdata_i18n_{hash}.json
```

## 2. マスタリリース管理（データベース）

### 関連テーブル

#### mng_master_releases

配信中のマスタデータバージョンを管理するテーブル。

主要カラム：
- `release_key`: リリースキー（S3パスのプレフィックス）
- `enabled`: 配信有効フラグ
- `target_release_version_id`: 配信中のバージョンID（mng_master_release_versions.id）

#### mng_master_release_versions

マスタデータの各バージョンの詳細情報を保存。

主要カラム：
- `release_key`: リリースキー
- `git_revision`: マスタデータのGitリビジョン
- `master_schema_version`: スキーマバージョン
- `client_mst_data_hash`: マスタデータのハッシュ値
- `client_mst_data_i18n_ja_hash`: 日本語マスタデータのハッシュ値
- `client_mst_data_i18n_en_hash`: 英語マスタデータのハッシュ値
- `client_mst_data_i18n_zh_hash`: 中国語マスタデータのハッシュ値
- `client_opr_data_hash`: オペレーションデータのハッシュ値
- `client_opr_data_i18n_ja_hash`: 日本語オペレーションデータのハッシュ値
- `client_opr_data_i18n_en_hash`: 英語オペレーションデータのハッシュ値
- `client_opr_data_i18n_zh_hash`: 中国語オペレーションデータのハッシュ値

### バージョン管理フロー

1. 管理ツールでマスタデータを作成・更新
2. 新しいバージョンとして`mng_master_release_versions`に登録
3. 配信準備が整ったら、`mng_master_releases`の`target_release_version_id`を更新
4. `enabled`フラグをONにして配信開始

## 3. game/version APIによる配信情報提供

### APIエンドポイント

```
GET /api/game/version
```

### リクエストヘッダー

- `Client-Version`: クライアントアプリのバージョン
- `Language`: 言語コード（ja, en, zh）
- `Platform`: プラットフォーム（iOS=1, Android=2）

### レスポンス

```json
{
  "mstHash": "abc123...",
  "mstPath": "0/masterdata/masterdata_abc123.json",
  "mstI18nHash": "def456...",
  "mstI18nPath": "0/masterdata_i18n/ja/masterdata_i18n_def456.json",
  "oprHash": "ghi789...",
  "oprPath": "0/operationdata/operationdata_ghi789.json",
  "oprI18nHash": "jkl012...",
  "oprI18nPath": "0/operationdata_i18n/ja/operationdata_i18n_jkl012.json",
  "assetCatalogDataPath": "...",
  "assetHash": "...",
  "tosVersion": "1.0",
  "tosUserAgreeVersion": "1.0",
  "tosUrl": "https://...",
  "privacyPolicyVersion": "1.0",
  "privacyPolicyUserAgreeVersion": "1.0",
  "privacyPolicyUrl": "https://...",
  "globalCnsntVersion": "1.0",
  "globalCnsntUserAgreeVersion": "1.0",
  "globalCnsntUrl": "https://...",
  "inAppAdvertisementVersion": "1.0",
  "inAppAdvertisementUserAgreeVersion": "1.0",
  "inAppAdvertisementUrl": "https://..."
}
```

### 処理フロー

#### 実装箇所

- **Controller**: `api/app/Http/Controllers/GameController.php`
- **UseCase**: `api/app/Domain/Game/UseCases/GameVersionUseCase.php`
- **Service**: `api/app/Domain/Game/Services/VersionDataManifestService.php`
- **ResponseFactory**: `api/app/Http/ResponseFactories/GameResponseFactory.php`

#### 処理ステップ

1. **クライアントバージョンに基づくマスタバージョン特定**
   ```php
   // VersionDataManifestService.php
   $versionEntity = $this->mngMasterReleaseService
       ->getMasterReleaseVersionByClientVersion($clientVersion, $now);
   ```

2. **マスタデータのパスとハッシュ取得**
   ```php
   // マスタデータ
   $hash = $versionEntity->getClientMstDataHash();
   $path = MasterDataUtility::getPath(MasterData::MASTERDATA, $hash);
   // => "masterdata/masterdata_{hash}.json"

   // 多言語データ
   $i18nHash = $versionEntity->getClientMstDataI18nHashByLanguage($language);
   $i18nPath = MasterDataUtility::getI18nPath(
       MasterData::MASTERDATA_I18N_PATH,
       MasterData::MASTERDATA_I18N,
       $language,
       $i18nHash
   );
   // => "masterdata_i18n/{language}/masterdata_i18n_{hash}.json"
   ```

3. **リリースキーをプレフィックスとして追加**
   ```php
   $releaseKey = $versionEntity->getReleaseKey();
   $fullPath = $releaseKey . '/' . $path;
   // => "0/masterdata/masterdata_{hash}.json"
   ```

4. **レスポンス生成**
   - GameResponseFactory::createVersionResponse()でJSON形式に変換
   - クライアントへ返却

## 4. クライアント側でのダウンロード

### ダウンロードフロー

1. **game/version APIを呼び出し**
   - アプリ起動時やバージョンチェック時に実行

2. **ハッシュ値による差分確認**
   - レスポンスの`mstHash`、`oprHash`等を前回値と比較
   - ハッシュ値が異なる場合のみダウンロード実行

3. **S3から直接ダウンロード**
   - レスポンスの`mstPath`、`oprPath`等を使用
   - S3のベースURLと組み合わせてフルパスを生成
   - 例: `https://s3.amazonaws.com/bucket-name/0/masterdata/masterdata_abc123.json`

4. **データの検証と適用**
   - ダウンロードしたデータのハッシュ値を検証
   - クライアントローカルストレージに保存
   - アプリケーションで利用

### クライアント側の実装例（概念）

```typescript
// 1. バージョン情報取得
const versionInfo = await api.getGameVersion();

// 2. ハッシュ値比較
if (versionInfo.mstHash !== localCache.mstHash) {
  // 3. S3からダウンロード
  const s3BaseUrl = 'https://s3.amazonaws.com/bucket-name/';
  const masterData = await downloadFromS3(s3BaseUrl + versionInfo.mstPath);

  // 4. 検証と保存
  if (verifyHash(masterData, versionInfo.mstHash)) {
    localCache.saveMasterData(masterData);
    localCache.mstHash = versionInfo.mstHash;
  }
}

// 多言語データも同様に処理
if (versionInfo.mstI18nHash !== localCache.mstI18nHash) {
  const i18nData = await downloadFromS3(s3BaseUrl + versionInfo.mstI18nPath);
  if (verifyHash(i18nData, versionInfo.mstI18nHash)) {
    localCache.saveMasterI18nData(i18nData);
    localCache.mstI18nHash = versionInfo.mstI18nHash;
  }
}
```

## データの種類と用途

### マスタデータ (masterdata)

ゲームの基本的な固定データ。

含まれる情報の例：
- キャラクターのステータス
- アイテムの効果
- ステージの構成
- スキルの性能
- エネミーのパラメータ

更新頻度：
- 低頻度（アプリバージョンアップ時など）
- データ量が多い

### オペレーションデータ (operationdata)

運営側で頻繁に更新される動的なデータ。

含まれる情報の例：
- イベント情報
- ガチャラインナップ
- ショップ商品
- キャンペーン情報
- 期間限定コンテンツ

更新頻度：
- 高頻度（イベント開始時、ガチャ更新時など）
- データ量は比較的少ない

### 多言語データ (i18n)

各データの言語別テキスト情報。

対応言語：
- ja: 日本語
- en: 英語
- zh: 中国語

含まれる情報の例：
- キャラクター名、説明
- アイテム名、説明
- クエスト名、ストーリーテキスト
- UI表示テキスト

## データフォーマット

### JSON形式

可読性が高く、デバッグが容易。

```json
{
  "characters": [
    {
      "id": 1,
      "name": "Hero",
      "hp": 100,
      "attack": 20
    }
  ],
  "items": [
    {
      "id": 1,
      "name": "Potion",
      "effect": "heal",
      "value": 50
    }
  ]
}
```

### MessagePack形式

バイナリフォーマットで、JSONより：
- データサイズが小さい（通信量削減）
- パース速度が速い
- 型情報を保持

実装：
- `MessagePack\Packer`を使用
- CarbonTransformer: Carbon型の日時データを変換
- EnumTransformer: Enum型を変換

## セキュリティ

### 暗号化

配信データは暗号化されています。

実装：
- `lib-laravel-wp-encryption`のAesRequestEncryptorを使用
- `SerializedDataFileOperator::gzipAndEncryptMasterdataFile()`で処理

処理フロー：
1. データをgzip圧縮
2. AES暗号化
3. S3にアップロード

クライアント側：
- アプリに埋め込まれた鍵で復号化
- 解凍してデータ利用

### データ整合性

ハッシュ値によるデータ検証：
- SHA256等のハッシュアルゴリズムを使用
- ダウンロード後にハッシュ値を検証
- 改ざん検知

## メリット・デメリット

### メリット

1. **サーバー負荷の軽減**
   - 大量のマスタデータをAPIで配信する必要がない
   - S3/CDNで配信するため、サーバーリソースを節約

2. **配信効率の向上**
   - CDNによるグローバル配信
   - クライアントに近いエッジロケーションから配信
   - 高速なダウンロード

3. **差分更新の容易さ**
   - ハッシュ値による差分検出
   - 変更があったデータのみダウンロード
   - 通信量の最適化

4. **バージョン管理の柔軟性**
   - 複数バージョンの同時配信が可能
   - クライアントバージョンごとに適切なマスタを配信
   - A/Bテストやロールバックが容易

5. **開発・運用の分離**
   - マスタデータの更新がサーバーデプロイ不要
   - 企画側で独立してマスタデータを管理可能
   - リリースサイクルの高速化

### デメリット

1. **初期ダウンロード時間**
   - アプリ初回起動時に全マスタデータをダウンロード
   - 通信環境によっては時間がかかる

2. **クライアント側のストレージ使用**
   - ローカルにマスタデータを保存
   - デバイスの空き容量が必要

3. **整合性管理の複雑さ**
   - クライアントとサーバーでマスタバージョンが異なる可能性
   - バージョン不整合のエラーハンドリングが必要

4. **配信タイミングの制御**
   - S3にアップロード後、即座に全ユーザーに配信
   - 段階的なロールアウトには別の仕組みが必要

## 運用時の注意点

### マスタデータ更新時

1. **テスト環境での検証**
   - 必ず開発環境で動作確認
   - ハッシュ値の正しさを確認

2. **リリースタイミング**
   - ユーザーが少ない時間帯を選択
   - メンテナンス告知を実施

3. **ロールバック準備**
   - 前バージョンのデータを保持
   - `target_release_version_id`を前バージョンに戻すだけでロールバック可能

4. **クライアント対応確認**
   - 新しいマスタデータに対応したクライアントバージョンがリリース済みか確認
   - 非対応クライアントへの配信を避ける

### トラブルシューティング

#### クライアントがマスタデータをダウンロードできない

チェック項目：
1. S3にファイルが存在するか
2. S3のアクセス権限は正しいか
3. CDNのキャッシュは更新されているか
4. game/version APIのレスポンスは正しいか

#### ハッシュ値が一致しない

原因の可能性：
1. ファイル生成時のエラー
2. S3アップロード時の破損
3. DBに保存されたハッシュ値が間違っている

対処：
1. ファイルを再生成
2. ハッシュ値を再計算して確認
3. DBのハッシュ値を更新

## 関連ドキュメント

- lib/laravel-wp-master-asset-release-admin/README.md - ライブラリの詳細仕様
- glow-schema - マスタデータのスキーマ定義リポジトリ
- API仕様書 - game/version APIの詳細仕様

## まとめ

本システムは、マスタデータ配信を最適化するために、以下の構成を採用しています：

1. **管理ツールでの一元管理**: lib/laravel-wp-master-asset-release-adminによる効率的なマスタデータ管理
2. **S3を活用した配信**: APIサーバーへの負荷を軽減し、CDNによる高速配信を実現
3. **バージョン管理**: ハッシュ値とリリースキーによる厳密なバージョン管理
4. **差分更新**: ハッシュ値による効率的な差分検出とダウンロード

この仕組みにより、サーバー負荷を抑えつつ、クライアントに対して迅速かつ安全にマスタデータを配信できます。
