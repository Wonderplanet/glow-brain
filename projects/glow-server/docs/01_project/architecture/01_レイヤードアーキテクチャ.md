# レイヤードアーキテクチャ

## 概要

glow-serverは、レイヤードアーキテクチャをベースとした設計を採用しています。
各レイヤーには明確な責務があり、依存の方向は上位から下位へと一方向に流れます。

## レイヤー構成

```
┌─────────────────────────────────────────────────────┐
│               HTTP Layer (Controller)                │
│  - リクエストバリデーション                          │
│  - レスポンス生成                                    │
│  - ビジネスロジックは含まない                        │
└────────────────────────┬────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────┐
│             UseCase / Service Layer                  │
│  - ビジネスロジックの組み立て                        │
│  - トランザクション制御                              │
└────────────────────────┬────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────┐
│               Repository Layer                       │
│  - テーブル全体に関わる操作                          │
│  - レコードの取得・検索                              │
└────────────────────────┬────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────┐
│                 Model Layer                          │
│  - レコード単位の操作                                │
│  - ドメインロジック                                  │
└────────────────────────┬────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────┐
│                    Database                          │
└─────────────────────────────────────────────────────┘
```

## 各レイヤーの詳細

### 1. HTTP Layer (Controller)

#### 責務
- リクエストのバリデーション
- レスポンスの生成
- **ビジネスロジックは含まない**

#### 構成要素

| 要素 | 役割 | 配置場所 |
|------|------|----------|
| Request | バリデーション・型キャスト | `app/Http/Requests/Api/` |
| Controller | 値取得、UseCase実行、結果受け渡し | `app/Http/Controllers/` |
| ResponseFactory | レスポンス生成（ADRパターン） | `app/Http/ResponseFactories/` |

#### ADRパターン

glow-serverは**Action-Domain-Responder (ADR)パターン**を採用しています。
従来のMVCにおけるControllerの役割を分離し、レスポンス生成をResponder（ResponseFactory）に委譲します。

```php
// Controller例
class StageController extends Controller
{
    public function end(
        StageEndRequest $request,
        StageEndUseCase $useCase,
        StageResponseFactory $responseFactory
    ): JsonResponse {
        $resultData = $useCase->exec(
            $request->currentUser(),
            $request->platform(),
            $request->getMstStageId(),
            $request->getInGameBattleLog(),
        );

        return $responseFactory->end($resultData);
    }
}
```

### 2. UseCase Layer

#### 責務
- 複数の部品を組み合わせて一連の処理を実現
- **トランザクション制御**
- 大まかな処理の流れのみを記述（詳細はServiceに切り出し）

#### 特徴
- **複数のクラスから利用しない**（単一利用）
- Facadeパターン的な使い方を推奨
- 1つのAPIエンドポイントに対して1つのUseCase

#### 実装例

```php
class StageEndUseCase
{
    use UseCaseTrait;

    public function __construct(
        private Clock $clock,
        // Service
        private StageLogService $stageLogService,
        private UsrModelDiffGetService $usrModelDiffGetService,
        // Repository
        private MstStageRepository $mstStageRepository,
        // Delegator
        private RewardDelegator $rewardDelegator,
        private UserDelegator $userDelegator,
    ) {}

    public function exec(
        CurrentUser $user,
        int $platform,
        string $mstStageId,
        array $inGameBattleLog = [],
    ): StageEndResultData {
        $usrUserId = $user->getUsrUserId();
        $now = $this->clock->now();

        // ... ビジネスロジック

        // トランザクション処理
        $result = $this->applyUserTransactionChanges(function () use (...) {
            // トランザクション内の処理
            $this->rewardDelegator->sendRewards($usrUserId, $platform, $now);
            // ...
            return $result;
        });

        return new StageEndResultData(/* ... */);
    }
}
```

#### UseCaseTrait

UseCaseで共通的に使用するトランザクション制御機能を提供します。

```php
trait UseCaseTrait
{
    /**
     * ユーザーデータ更新のトランザクション処理
     * - DB::transaction()によるトランザクション制御
     * - UsrModelManagerによるモデル一括保存
     */
    protected function applyUserTransactionChanges(callable $callback): mixed
    {
        return DB::transaction(function () use ($callback) {
            $result = $callback();
            app(UsrModelManager::class)->saveAll();
            return $result;
        });
    }
}
```

### 3. Service Layer

#### 責務
- **複数のクラスから利用される**共通処理
- 細かい処理を部品として提供
- ドメインロジックの実装

#### UseCaseとServiceの違い

| 観点 | UseCase | Service |
|------|---------|---------|
| 再利用 | 単一利用（1 APIエンドポイント） | 複数クラスから利用可能 |
| 粒度 | 大まかな処理の流れ | 細かい処理の部品 |
| トランザクション | 制御する | 制御しない |
| 命名 | `XxxUseCase` | `XxxService` |

#### 実装方針

- DBから取得してnullチェックする処理はServiceに記載
- UseCaseには大まかな流れのみ

### 4. Repository Layer

#### 責務
- DBのテーブル全体に関わる操作（レコードの取得など）
- SELECT、INSERT、UPDATE、DELETEの実行

#### 設計理由
- Modelのstaticメソッドはテスト容易性が低下するため分離
- Repositoryはインスタンスメソッドでモック可能

#### 実装例

```php
class UsrStageRepository implements UsrModelCacheRepositoryInterface
{
    public function __construct(
        private UsrModelManager $usrModelManager,
    ) {}

    public function findByUsrUserId(string $usrUserId): ?UsrStage
    {
        // キャッシュから取得を試みる
        $cached = $this->getCachedModel($usrUserId);
        if ($cached !== null) {
            return $cached;
        }

        // DBから取得
        $model = UsrStage::query()
            ->where('usr_user_id', $usrUserId)
            ->first();

        // キャッシュに保存
        if ($model !== null) {
            $this->usrModelManager->syncModels(static::class, [$model]);
        }

        return $model;
    }
}
```

### 5. Model Layer

#### 責務
- DBのレコード単位の操作（更新など）
- そのデータに関する処理（ドメインロジック）

#### 特徴
- 同一モジュール内であればEloquentのリレーション機能で他テーブル操作OK
- UseCaseからの直接呼び出しは禁止（Interface経由のみ）

#### Model Interface

UseCaseからModelを呼び出す際はInterfaceを経由します。

```php
// Interface定義
interface UsrStageInterface
{
    public function getUsrUserId(): string;
    public function getMstStageId(): string;
    public function setCleared(bool $cleared): void;
    // save()メソッドは公開しない
}

// Model実装
class UsrStage extends Model implements UsrStageInterface
{
    // ...
}
```

**目的:**
- 基底クラスの直接的なDB操作機能（save()等）を隠蔽
- テスト時にモック可能にする

## レイヤー間の呼び出し制約

| Caller/Callee | Controller | UseCase | Service | Repository | Model Interface | Model |
|---------------|:----------:|:-------:|:-------:|:----------:|:---------------:|:-----:|
| **Controller** | - | ✓ | - | - | - | - |
| **UseCase/Service** | - | - | ✓ | ✓ | ✓ | - |
| **Repository** | - | - | - | ✓ | ✓ | ✓ |
| **Model** | - | - | - | - | ✓ | ✓ |

**重要な制約:**
- **UseCaseからModelの直接呼び出しは禁止**
  - テーブル全体の操作 → Repositoryを介する
  - レコード単位の操作 → Model Interfaceを介する
- **理由:** 変更容易性とテスト容易性の向上
