# モジュラーモノリスとDelegator

## モジュラーモノリスとは

**モジュラーモノリス**は、単一のコードベースでありながら内部を機能（ドメイン）ごとにモジュール分割するアーキテクチャスタイルです。

### 採用理由

1. **変更容易性**: モジュール内で変更が完結する
2. **テスト容易性**: モジュール単位でテスト可能
3. **シンプルなデプロイ**: マイクロサービスの複雑さを回避
4. **将来の拡張性**: 必要に応じてマイクロサービス化が可能

### モノリスとの違い

| 観点 | モノリス | モジュラーモノリス |
|------|----------|-------------------|
| 依存関係 | 無秩序に依存 | Delegator経由で管理 |
| 境界 | 曖昧 | ドメイン単位で明確 |
| 保守性 | 低下しがち | 維持しやすい |
| テスト | 全体テストが必要 | モジュール単位で可能 |

## ドメイン分割

### Domainレイヤーのモジュール構成

```
api/app/Domain/
├── Auth/           # 認証ドメイン
├── User/           # ユーザードメイン
├── Stage/          # ステージドメイン
├── Gacha/          # ガチャドメイン
├── Shop/           # ショップドメイン
├── Item/           # アイテムドメイン
├── ...             # その他ドメイン
├── Game/           # ゲーム全体（特例ドメイン）
├── Common/         # 全ドメイン共通
└── Resource/       # 共有リソース
```

### モジュール分割の範囲

- **Domainレイヤーの内部のみ**機能ごとにモジュール分割
- **Controllerは分割しない**（役割が限定的、自動生成が多い）

## Delegator パターン

### 概要

**Delegator**は、モジュール間のアクセス窓口として機能するクラスです。
他ドメインのロジックを使用する場合は、必ずDelegatorを通す必要があります。

```
┌─────────────────────────────────────────────────────────────┐
│ Stage ドメイン                                               │
│                                                              │
│  ┌─────────────────┐                                        │
│  │  StageUseCase   │                                        │
│  └────────┬────────┘                                        │
│           │                                                  │
└───────────┼──────────────────────────────────────────────────┘
            │ Delegator経由でアクセス
            ▼
┌─────────────────────────────────────────────────────────────┐
│ Item ドメイン                                                │
│                                                              │
│  ┌─────────────────┐      ┌─────────────────┐              │
│  │  ItemDelegator  │─────▶│  ItemService    │              │
│  │  (窓口)         │      └────────┬────────┘              │
│  └─────────────────┘               │                        │
│                                    ▼                        │
│                           ┌─────────────────┐              │
│                           │  ItemRepository │              │
│                           └─────────────────┘              │
└─────────────────────────────────────────────────────────────┘
```

### Delegatorの実装例

```php
namespace App\Domain\Item\Delegators;

class ItemDelegator
{
    public function __construct(
        private UsrItemService $usrItemService,
        private UsrItemRepository $usrItemRepository,
        private ItemIdleBoxService $itemIdleBoxService,
    ) {}

    /**
     * 報酬によるアイテム追加
     */
    public function addItemByRewards(
        string $usrUserId,
        Collection $rewards,
        CarbonImmutable $now,
    ): void {
        $this->usrItemService->addItemByRewards($usrUserId, $rewards, $now);
    }

    /**
     * アイテム使用
     */
    public function useItemByMstItemId(
        string $usrUserId,
        string $mstItemId,
        int $useNum,
        LogTrigger $logTrigger,
    ): void {
        $this->usrItemService->consumeItem($usrUserId, $mstItemId, $useNum, $logTrigger);
    }

    /**
     * ユーザーアイテム取得
     * ※ ユーザーモデルエンティティに変換して返す
     */
    public function getUsrItemByMstItemId(string $usrUserId, string $mstItemId): ?UsrItemEntity
    {
        return $this->usrItemRepository->getByMstItemId($usrUserId, $mstItemId)?->toEntity();
    }
}
```

### Delegator使用時のルール

#### 1. ユーザーデータの返却

他ドメインへユーザーデータを渡す場合は、**ユーザーモデルエンティティに変換**してから返します。

```php
// NG: ユーザーモデルをそのまま返す
public function getUsrItem(string $usrUserId): ?UsrItem
{
    return $this->usrItemRepository->getByUsrUserId($usrUserId);
}

// OK: エンティティに変換して返す
public function getUsrItem(string $usrUserId): ?UsrItemEntity
{
    return $this->usrItemRepository->getByUsrUserId($usrUserId)?->toEntity();
}
```

#### 2. プリミティブ型はそのまま返却可能

```php
// OK: プリミティブ型はそのまま返却
public function getItemCount(string $usrUserId, string $mstItemId): int
{
    return $this->usrItemRepository->getCount($usrUserId, $mstItemId);
}
```

### Delegatorの利点

#### 変更容易性
- 例: IdleIncentiveドメインへの影響なしで、Itemドメインのロジックを変更できる

#### テスト容易性
- 例: Itemドメインのサービスメソッドのテストで、IdleIncentiveDelegatorをモックすることで、純粋にItemドメインのロジックをテストできる

## 特例ルール

### 1. マスタデータの共有（Resource/Mst）

マスタデータは**全ドメイン共有可**とし、Delegator不要で直接DIして利用できます。

```php
// OK: マスタデータは直接DI可能
class StageEndUseCase
{
    public function __construct(
        private MstStageRepository $mstStageRepository,  // 直接DI
        private OprCampaignRepository $oprCampaignRepository,  // 直接DI
    ) {}
}
```

**理由:**
- API処理でデータ変更がないため、ドメイン内に収める必要がない
- 複数ドメインで利用するケースが頻繁にある
- 全ドメインでの共有リソースとして位置付ける

### 2. Gameドメインの特例

**Gameのロジックにおいては、Delegator不要で直接DIしてOK**

```php
// OK: GameドメインからStageServiceを直接DI
class GameService
{
    public function __construct(
        private StageService $stageService,  // 直接DI可能
    ) {}
}
```

**理由:**
- `game/update_and_fetch`ではゲームプレイのためのユーザーデータを大量にレスポンス
- Delegatorメソッドを用意すると以下の問題がある:
  - Delegatorインスタンスの依存解決処理の時間やメモリ消費に無駄がある
  - Gameは各ドメインから依存されることはなく、Delegatorする意味が薄い
  - 各RepositoryやServiceメソッドをラップするためのコード追加に意味がない

**例外:**
- 課金基盤関連処理は全てDelegatorメソッドを使う

## Entityの分類

| 分類 | 説明 | 配置場所 | 用途例 |
|------|------|----------|--------|
| **DomainEntity** | ファイルを追加したドメイン内でのみ使用。他ドメインへ渡すのは禁止。 | `Domain/[ドメイン]/Entities/` | MissionState（ミッション進捗判定ロジックのみで使用） |
| **ResourceEntity** | 限定的な複数のドメインで使用。Delegatorメソッドのreturnで使うユーザーモデルエンティティを含む。 | `Domain/Resource/Entities/`, `Domain/Resource/Usr/Entities/` | Unit（Stage, AdventBattle, Party等で使用）、UsrItemEntity |
| **CommonEntity** | 全ドメインで使用可能。 | `Domain/Common/Entities/` | Clock, Lottery, CurrentUser |

## ドメイン間依存の禁止事項

### NG: 他ドメインのService/Repositoryを直接使用

```php
// NG: ItemドメインのUseCaseからStageServiceを直接使用
class ItemUseCase
{
    public function __construct(
        private StageService $stageService,  // 禁止
    ) {}
}
```

### NG: 他ドメインのModelを直接使用

```php
// NG: UsrStage（Stageドメイン）をItemドメインで直接使用
class ItemService
{
    public function doSomething(UsrStage $usrStage)  // 禁止
    {
        // ...
    }
}
```

### OK: Delegator経由でアクセス

```php
// OK: Delegator経由でアクセス
class ItemUseCase
{
    public function __construct(
        private StageDelegator $stageDelegator,  // OK
    ) {}

    public function exec(): void
    {
        $stageEntity = $this->stageDelegator->getStage($usrUserId);
        // ...
    }
}
```
