# ステップアップガシャ - ガシャ検証改修 アプローチ比較分析

## 概要

ステップアップガシャのガシャ検証機能（事前検証・事後検証）を実装する際の2つのアプローチを比較分析し、最適解を提示する。

## 背景

### ステップアップガシャの特性

- 1回のガシャ実行で複数ステップが存在
- 各ステップで異なる排出テーブル（`opr_step_up_gacha_steps`）を参照
- ガシャログ（`log_gachas`）は1回の実行ごとに1レコード記録
- ガシャアクション（`log_gacha_actions`）は各ステップごとに複数レコード記録

### 検証機能の要件

1. **事前検証（マスタJSON生成）**
   - BNEが提供する排出テーブルとサーバーマスタが一致しているか確認
   - ステップごとの排出テーブル情報が必要

2. **事後検証（ログJSON生成）**
   - 実際の排出結果がマスタ通りか確認
   - どのステップで何が排出されたかの情報が必要

## アプローチA: log_gacha_actionsとのJOIN

### 概要

`log_gachas`と`log_gacha_actions`をJOINして`step_number`を取得するアプローチ。

### 実装方法

```php
// GenerateGachaLogJson.php の想定実装
$logGacha = LogGacha::find($id);
$logGachaAction = LogGachaActionRepository::findByCompositeKey(
    $logGacha->getUsrUserId(),
    $logGacha->getOprGachaId(),
    $logGacha->getCostType(),
    $logGacha->getDrawCount(),
    $logGacha->getDrawnAt()
);
$stepNumber = $logGachaAction ? $logGachaAction->getStepNumber() : 0;
```

### メリット

- `log_gachas`テーブルスキーマを変更しない
- 既存のテーブル構造を活用

### デメリット

#### 1. 複雑な複合キー検索

`log_gacha_actions`には主キーが存在せず、以下の5カラムで特定する必要がある:

- `usr_user_id`
- `opr_gacha_id`
- `cost_type`
- `draw_count`
- `drawn_at`

複合キー検索のための専用Repository実装が必要。

#### 2. N+1問題のリスク

`GenerateGachaLogJson`は大量のログを処理するため、1件ずつJOINすると以下の問題が発生:

- 各ログごとに`log_gacha_actions`へのクエリが発生
- バッチ取得の実装が必要（複合キーでのIN検索は複雑）

#### 3. admin側での新規Repository作成

`admin/app/Repositories/Log/LogGachaActionRepository.php`の新規作成が必要:

- `findByCompositeKey()`メソッド
- バッチ取得用の`getBatchByCompositeKeys()`メソッド
- 複雑なクエリビルダーロジック

#### 4. データ不整合のリスク

`log_gachas`と`log_gacha_actions`の記録タイミングが異なる場合、JOINで取得できない可能性がある。

#### 5. 実装コストと保守性

- 新規Repository作成: 50-100行
- 複合キー検索ロジック: 30-50行
- バッチ取得ロジック: 50-80行
- テストコード: 100-150行
- **合計: 約230-380行**

### コードベース調査結果

#### GenerateGachaLogJsonの現状

```php
// admin/app/Console/Commands/GenerateGachaLogJson.php:105
'step_no' => 0, // 現在は固定値
```

`GenerateGachaLogJson`は`log_gachas`のみを読み取り、`log_gacha_actions`は参照していない。

#### LogGachaActionのキー構造

```php
// api/database/schema/exports/log_tables_schema.json
"log_gacha_actions": {
    "columns": {
        "usr_user_id": "bigint unsigned",
        "opr_gacha_id": "int unsigned",
        "cost_type": "tinyint unsigned",
        "draw_count": "tinyint unsigned",
        "drawn_at": "timestamp",
        "step_number": "tinyint unsigned"
    },
    "indexes": {
        "idx_usr_user_id_drawn_at": ["usr_user_id", "drawn_at"],
        "idx_opr_gacha_id_drawn_at": ["opr_gacha_id", "drawn_at"]
    }
}
```

主キーがなく、複合キーでの検索が必要。

## アプローチB: log_gachasにstep_number追加（推奨）

### 概要

`log_gachas`テーブルに`step_number`カラムを追加し、ガシャ実行時に直接記録するアプローチ。

### 実装方法

#### 1. マイグレーション

```php
// api/database/migrations/YYYY_MM_DD_add_step_number_to_log_gachas.php
Schema::table('log_gachas', function (Blueprint $table) {
    $table->unsignedTinyInteger('step_number')->nullable()->after('drawn_at');
});
```

#### 2. モデル更新

```php
// api/app/Domain/Gacha/Models/LogGacha.php
/**
 * @property int|null $step_number ステップ番号（ステップアップガシャ用、通常ガシャはnull）
 */
class LogGacha extends Model
{
    public function getStepNumber(): ?int
    {
        return $this->step_number;
    }

    public function setStepNumber(?int $stepNumber): self
    {
        $this->step_number = $stepNumber;
        return $this;
    }
}
```

#### 3. Repository更新

```php
// api/app/Domain/Gacha/Repositories/LogGachaRepository.php
public function create(
    int $usrUserId,
    int $oprGachaId,
    CostType $costType,
    int $drawCount,
    CarbonImmutable $drawnAt,
    int $summonStoneCount,
    ?int $stepNumber = null  // 追加
): LogGacha {
    $logGacha = new LogGacha();
    // ...
    $logGacha->setStepNumber($stepNumber);
    return $logGacha;
}
```

#### 4. Service更新

```php
// api/app/Domain/Gacha/Services/GachaLogService.php
public function sendGachaLog(
    int $usrUserId,
    int $oprGachaId,
    CostType $costType,
    int $drawCount,
    CarbonImmutable $drawnAt,
    int $summonStoneCount,
    ?int $stepNumber = null  // 追加
): void {
    $this->logGachaRepository->create(
        $usrUserId,
        $oprGachaId,
        $costType,
        $drawCount,
        $drawnAt,
        $summonStoneCount,
        $stepNumber  // 追加
    );
}
```

#### 5. StepUpGachaDrawService更新

```php
// api/app/Domain/Gacha/Services/Draw/StepUpGachaDrawService.php:172-178
$this->gachaLogService->sendGachaLog(
    usrUserId: $usrUserId,
    oprGachaId: $stepUpGachaConfig->getOprGachaId(),
    costType: $stepUpGachaConfig->getCostType(),
    drawCount: $drawCount,
    drawnAt: $drawnAt,
    summonStoneCount: $summonStoneCount,
    stepNumber: $currentStepNumber  // 追加（行77で確定済み）
);
```

#### 6. admin側のログJSON生成

```php
// admin/app/Console/Commands/GenerateGachaLogJson.php:105
// 修正前
'step_no' => 0,

// 修正後
'step_no' => $logGacha->getStepNumber() ? $logGacha->getStepNumber() - 1 : 0,
```

**BNE仕様注**: BNEのstep_noは0始まり、サーバーのstep_numberは1始まりのため変換が必要。

### メリット

#### 1. シンプルな実装

- **admin側の変更はたった1行**（行105の修正のみ）
- JOINロジック不要
- 新規Repository作成不要
- 複雑な複合キー検索不要

#### 2. パフォーマンス

- N+1問題なし
- 追加クエリ不要
- `$logGacha->getStepNumber()`で直接取得

#### 3. データ整合性

- ガシャ実行時に確定した`step_number`を記録
- `log_gacha_actions`とのJOINによる不整合リスクなし

#### 4. 保守性とテスト容易性

- シンプルなロジック → テストが容易
- 後方互換性あり（nullable、通常ガシャはnull）
- 既存の通常ガシャ・チュートリアルガシャは変更不要

#### 5. 実装コスト

- マイグレーション: 10行
- モデル更新: 15行
- Repository更新: 5行
- Service更新: 5行
- DrawService更新: 1行
- admin側更新: 1行
- **合計: 約37行**

**アプローチAの約1/7の実装量**

### デメリット

#### 1. テーブルスキーマ変更

- `log_gachas`にカラム追加が必要
- マイグレーション実行が必要

→ ただし、ログテーブルは頻繁にカラム追加されており、特段のリスクなし

#### 2. データ重複

- `log_gacha_actions`にも`step_number`が存在
- 同じ情報を2箇所に保持

→ ただし、`log_gachas`と`log_gacha_actions`は既に以下のカラムが重複:
  - `opr_gacha_id`
  - `cost_type`
  - `draw_count`
  - `drawn_at`

ログテーブルでのデータ重複は既存方針と一貫しており、問題なし。

## コードベース検証

### StepUpGachaDrawServiceの実装確認

```php
// api/app/Domain/Gacha/Services/Draw/StepUpGachaDrawService.php

// 行77: currentStepNumberの確定
$currentStepNumber = $stepUpGachaUserState->getStepNumber();

// 行172-178: ガシャログ送信（step_number確定のはるか後）
$this->gachaLogService->sendGachaLog(
    usrUserId: $usrUserId,
    oprGachaId: $stepUpGachaConfig->getOprGachaId(),
    costType: $stepUpGachaConfig->getCostType(),
    drawCount: $drawCount,
    drawnAt: $drawnAt,
    summonStoneCount: $summonStoneCount
    // ここに stepNumber: $currentStepNumber を追加可能
);
```

**重要**: `sendGachaLog()`呼び出し時点で、`$currentStepNumber`は既に確定済み。技術的に安全に追加可能。

### 後方互換性の確認

#### 通常ガシャ

```php
// api/app/Domain/Gacha/Services/Draw/StandardGachaDrawService.php:177-183
$this->gachaLogService->sendGachaLog(
    usrUserId: $usrUserId,
    oprGachaId: $gachaConfig->getOprGachaId(),
    costType: $gachaConfig->getCostType(),
    drawCount: $drawCount,
    drawnAt: $drawnAt,
    summonStoneCount: $summonStoneCount
    // stepNumber: null（デフォルト引数）
);
```

`?int $stepNumber = null`のため、既存コードは変更不要。

#### チュートリアルガシャ

```php
// api/app/Domain/Tutorial/Services/TutorialLogService.php
// sendGachaLog() を呼び出していない（独自実装）
```

影響なし。

## データ重複に関する既存方針の確認

### log_gachasとlog_gacha_actionsの重複カラム

| カラム名 | log_gachas | log_gacha_actions |
|---------|-----------|------------------|
| usr_user_id | ✓ | ✓ |
| opr_gacha_id | ✓ | ✓ |
| cost_type | ✓ | ✓ |
| draw_count | ✓ | ✓ |
| drawn_at | ✓ | ✓ |
| step_number | (追加予定) | ✓ |

**結論**: ログテーブル間でのデータ重複は既存の設計方針であり、`step_number`追加は一貫性がある。

## GachaType.phpのバグ確認

### 現状

```php
// admin/app/Constants/GachaType.php

// 行21: STEPUP定義は存在
case STEPUP = 4;

// 行25-35: label()メソッド（STEPUPケースなし）
public function label(): string
{
    return match ($this) {
        self::NORMAL => '通常',
        self::TUTORIAL => 'チュートリアル',
        self::BOX => 'BOX',
        // self::STEPUP がない！
    };
}

// 行39-47: labels()メソッド
public static function labels(): array
{
    $labels = [];
    foreach (self::cases() as $case) {
        $labels[$case->value] = $case->label(); // ここでSTEPUPが呼ばれるとクラッシュ
    }
    return $labels;
}
```

### 問題

- `labels()`が全caseをループして`label()`を呼ぶ
- `label()`に`self::STEPUP`のケースがない
- `UnhandledMatchError`が発生（ステップアップガシャ存在時）

### 緊急度

- **即時修正が必要**（別タスクとして独立実行可能）
- ガシャ検証改修とは独立した不具合

## 比較表

| 項目 | アプローチA (JOIN) | アプローチB (カラム追加) |
|-----|-------------------|----------------------|
| **実装量** | 約230-380行 | 約37行 |
| **admin側変更** | 新規Repository作成 + 複雑なロジック | **1行のみ** |
| **パフォーマンス** | N+1リスクあり（要バッチ取得） | N+1問題なし |
| **複雑性** | 複合キー検索、JOIN、バッチ取得 | シンプル（直接取得） |
| **保守性** | 複雑（複数箇所の変更） | シンプル（最小限の変更） |
| **テスト容易性** | 複雑（Repository、JOIN、バッチ） | 容易（単純なgetter/setter） |
| **データ整合性** | JOINによる不整合リスク | 確定値を直接記録 |
| **後方互換性** | 影響なし | nullable → 影響なし |
| **スキーマ変更** | 不要 | 必要（マイグレーション） |
| **データ重複** | なし | あり（既存方針と一貫） |
| **既存方針との一貫性** | - | ログテーブル重複は既存方針 |

## 推奨アプローチ

### **アプローチB（log_gachasにstep_number追加）を強く推奨**

### 理由

1. **実装量が1/7**: 37行 vs 230-380行
2. **admin側の変更が最小**: たった1行の修正
3. **シンプルで保守しやすい**: JOINロジック不要
4. **パフォーマンスが良い**: N+1問題なし
5. **テストが容易**: 複雑なRepository不要
6. **既存方針と一貫**: ログテーブルの重複は既存設計
7. **後方互換性あり**: nullable、通常ガシャ影響なし

### スキーマ変更に関する懸念への回答

**Q**: ログテーブルのスキーマ変更はリスクでは？

**A**: ログテーブルは頻繁にカラム追加されており、以下の実績がある:
- `log_gachas`は過去に複数回カラム追加済み
- マイグレーション手順は確立済み
- `nullable`のため既存データへの影響なし

**Q**: データ重複は問題では？

**A**: `log_gachas`と`log_gacha_actions`は既に5カラムが重複しており、既存の設計方針。ログテーブルは各テーブルが独立して完結する設計が採用されている。

## 次のステップ

1. **Phase 0**: GachaType.phpのバグ修正（緊急・独立）
2. **Phase 1**: API側の実装（アプローチB）
3. **Phase 2-4**: admin側の実装
4. **Phase 5**: テスト・検証

詳細は「ステップアップガシャ_実装計画書_v2.md」を参照。
