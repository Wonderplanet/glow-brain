# サーバー実装観点の仕様レビュー（自動分析レポート）

## 1. 要約

### 現時点での仕様の明瞭さ/不明瞭さの総評

**明瞭な部分:**
- ウェブフック5種類（W1-W5）のシーケンス・レスポンス構造は明確
- 年齢・国による制御の基本ルールは定義されている
- 不正購入防止（署名検証、IP制限、重複防止）の方針は明記されている
- 既存のアプリ内課金システムとの共通点が多く、再利用可能なコンポーネントが特定できている

**不明瞭な部分:**
1. **データモデル設計の詳細**: 既存テーブルの拡張方法、新規テーブルの要否が未確定
2. **誕生日情報の取得方法**: アプリ側で保持していない場合の対応方針が不明
3. **バンダイナムコID居住国の取得方法**: WebStore APIの仕様が不明確
4. **返金処理の実装**: 永続エラー時の返金フローが未定義
5. **Adjust連携の詳細**: 既存実装が見つからず、実装方式が不明
6. **アイテム付与失敗時の挙動**: エラーポリシー（リトライ、メッセージ送付等）が未確定
7. **デバッグ機能の実装範囲**: 国コード・通貨コード上書き機能の実装仕様が不明

### 大きなリスク・不確定要素の概要

**高リスク項目:**
1. **返金処理の未実装**: 永続エラー時に手動返金が必要となり、運用負荷が高い
2. **デッドロック対策の不足**: アプリ内課金との同時実行時の競合が発生する可能性
3. **トランザクションID管理**: 有効期限、状態管理の仕組みが未設計
4. **誕生日情報の不整合**: WebStoreへの事前申請が必要なケースで、開発スコープが拡大

**中リスク項目:**
1. **Adjust連携の実装**: 既存実装が不明で、新規開発が必要
2. **国コード・通貨コードの永続化**: 一度登録したら更新しない制約の実装が複雑
3. **無料アイテム・クーポンのNULL値処理**: 既存コードがNULLを想定していない可能性
4. **ウェブフック死活監視**: 監視基盤の構築が別途必要

---

## 2. 仕様の詳細化（サーバー観点）

### 2.1. ウェブフックエンドポイント仕様

#### W1: ユーザー情報の取得

**エンドポイント**: `/api/webstore/webhook/user_validation` (仮)

**リクエスト:**
- `notification_type`: "get_user"
- `user`: { `id`: バンダイナムコID }
- `custom_parameters`: 任意のカスタムパラメータ

**レスポンス（200 OK）:**
```json
{
  "user": {
    "id": "バンダイナムコID",
    "internal_id": "usr_user_id",
    "name": "ユーザー名",
    "level": 1,
    "birthday": "20050408",       // YYYYMMDD形式、または空文字
    "birthday_month": "04",        // MM形式、または空文字
    "country": "JP",               // ISO 3166-1 alpha-2
    "currency": "JPY"              // ISO 4217
  }
}
```

**エラーレスポンス:**
- `400`: ユーザーが未登録の場合
  ```json
  {
    "error": {
      "code": "USER_NOT_FOUND",
      "message": "User is not registered"
    }
  }
  ```
- `503`: メンテナンス中
  ```json
  {
    "error": {
      "message": "Service is under maintenance"
    }
  }
  ```

**処理フロー:**
1. バンダイナムコIDから`usr_users.bn_user_id`を検索
2. ユーザーが存在しない場合: 400エラー
3. メンテナンス中の場合: 503エラー
4. 国コード・通貨コードを取得（後述の2.5参照）
5. 誕生日情報を取得（後述の2.6参照）
6. レスポンスを返却

---

#### W2: 決済事前確認

**エンドポイント**: `/api/webstore/webhook/payment_validation` (仮)

**リクエスト:**
- `notification_type`: "payment"
- `user`: { `id`, `birthday`, `country` 等 }
- `custom_parameters`: { `internal_id`, `store_code`, `country_from_ip`, `is_country_mismatch` }
- `purchase`: {
  `items`: [
    { `sku`: "商品ID", `type`: "virtual_good", `amount`: 1 }
  ]
}

**レスポンス（200 OK）:**
```json
{
  "transaction_id": "UUID形式のトランザクションID"
}
```

**エラーレスポンス:**
- `400`: 購入権限なし（年齢制限、購入回数上限等）
  ```json
  {
    "error": {
      "code": "PURCHASE_NOT_ALLOWED",
      "message": "User does not have permission to purchase"
    }
  }
  ```
- `503`: メンテナンス中

**処理フロー:**
1. `items`配列から`type=virtual_good`のみをフィルタ
2. ユーザーの年齢をチェック（後述の2.2参照）
3. 購入回数制限をチェック
4. 国コード不一致のログ記録（`is_country_mismatch=true`の場合）
5. トランザクションIDを発行（UUID v4等）
6. トランザクション情報をDBに保存（トランザクションID、usr_user_id、商品ID、発行日時等）
7. レスポンスを返却

**【不明点】**: トランザクションIDの有効期限を設定するか？（例: 24時間以内に決済完了が必要）

---

#### W3: ユーザー検証（Xsolla）

**エンドポイント**: `/api/webstore/webhook/user_validation_xsolla` (仮)

**リクエスト:**
- Xsolla仕様に準拠（仕様書詳細を参照）

**レスポンス:**
- `200`: ユーザーが存在する
- `400`: ユーザーが存在しない

**処理フロー:**
1. カスタムパラメータから`internal_id`を取得
2. `usr_users`テーブルでユーザー存在確認
3. 存在する場合: 200、存在しない場合: 400

---

#### W4: 支払い（Xsolla）

**エンドポイント**: `/api/webstore/webhook/payment_xsolla` (仮)

**リクエスト:**
- `transaction`: { `dry_run`: 0 or 1 }
- その他Xsolla仕様に準拠

**レスポンス:**
- `200`: 支払いを受け付ける
- `500`: 一時エラー（リトライ可能）

**処理フロー:**
1. 署名検証（後述の2.7参照）
2. `transaction.dry_run`をチェック（1の場合はテスト決済）
3. トランザクションログを記録
4. 200を返却

**【不明点】**: 支払いウェブフックで特別な処理が必要か？（仕様書では単に応答するだけ）

---

#### W5: 注文支払い成功（Xsolla）

**エンドポイント**: `/api/webstore/webhook/order_success` (仮)

**リクエスト:**
- `order`: { `id`, `invoice_id`, `currency`, `amount`, `mode` }
- `items`: [{ `sku`, `type`, `amount` }]
- `custom_parameters`: { `internal_id`, `transaction_id`, `user_ip`, `store_code`, `country_from_ip`, `is_country_mismatch` }

**レスポンス:**
- `200`: アイテム付与成功
  ```json
  {
    "result": "success",
    "order_id": "注文ID"
  }
  ```
- `400`: 永続エラー（返金が必要）
- `500`: 一時エラー（リトライ可能）

**処理フロー:**
1. 署名検証
2. `order.id`で重複チェック（べき等性の保証）
3. `order.mode`が"sandbox"の場合、テスト決済フラグを立てる
4. `items`配列から`type=virtual_good`のみをフィルタ
5. トランザクションIDと照合（カスタムパラメータの`transaction_id`）
6. `usr_store_product_histories`にレコード挿入
   - `receipt_unique_id`: `order.id`
   - `billing_platform`: "webstore"または"xsolla"
   - `currency_code`: `order.currency`
   - `purchase_price`: `order.amount`
   - `is_sandbox`: `order.mode == "sandbox" ? 1 : 0`
   - 外部決済固有の情報（`order.invoice_id`等）を保存（カラム追加が必要）
7. アイテム付与処理（`RewardDelegator::sendRewards`）
8. Bank連携（購入データ送信）
9. Adjust連携（クライアントIP送信）
10. `log_webstore_transactions`にトランザクション完了ログを記録
11. 200を返却

**エラーハンドリング:**
- 重複チェックで既に処理済みの場合: 1回目の処理結果を返す（べき等性）
- アイテム付与失敗時: `RewardSendPolicy`に応じてエラーを返すか、メッセージボックスに送る
- 永続エラー（年齢制限違反、購入回数上限等）: 400を返し、手動で返金処理
- 一時エラー（DB接続エラー等）: 500を返し、Xsollaにリトライさせる

**【不明点】**:
- アイテム付与失敗時の`RewardSendPolicy`はどれを使うか？
- Bank/Adjust連携が失敗した場合、エラーを返すか、ログだけ記録して200を返すか？

---

### 2.2. 年齢制限の実装

#### 日本向け（アソビストア & Bandai Namco Entertainment WebStore）

- **全年齢**: ログイン可能
- **18歳未満**: 無料アイテムとプロモーションコードのみ利用可能
  - `order.amount == 0`または`order.currency == null`の場合: OK
  - それ以外: 400エラー「PURCHASE_NOT_ALLOWED_UNDER_18」

#### 海外向け（Bandai Namco Entertainment WebStore）

- **13歳以下**: ログイン不可
  - W1（ユーザー情報取得）で400エラー「USER_TOO_YOUNG」を返す
- **14歳以上の子供アカウント**: 無料アイテムとプロモーションコードのみ利用可能
  - W2（決済事前確認）で有料商品の場合は400エラー

**年齢の判定方法:**
- リクエストの`user.birthday`（YYYYMMDD形式）から計算
- 現在日時は`CarbonImmutable::now()`を使用
- 年齢 = 現在年 - 誕生年（誕生日未到来の場合は-1）

**【不明点】**:
- 「子供アカウント」の判定方法は？バンダイナムコIDのアカウント種別フラグが必要？
- それともユーザー情報取得APIで別途取得する？

---

### 2.3. 国コード制御の実装

#### ダウンロード国と居住国の照合

**仕様:**
- アプリのダウンロード国（または通貨情報）とバンダイナムコIDの居住国が異なる場合、ログインできない
- W1（ユーザー情報取得）で検証し、不一致の場合は400エラー「COUNTRY_MISMATCH」を返す

**処理フロー:**
1. アプリ側から送信された国コード（`usr_webstore_infos.country_code`に保存されている値）を取得
2. バンダイナムコIDの居住国をWebStore APIから取得（**API仕様が不明**）
3. 両者を比較し、不一致の場合はエラー

**【不明点】**:
- バンダイナムコIDの居住国を取得するAPIの仕様は？
- 既存の`BNID_ACCESS_TOKEN_URL`等の環境変数で取得可能か？

---

#### アクセス国と居住国の不一致のログ記録

**仕様:**
- カスタムパラメータ`country_from_ip`（IPアドレスから判定した国）と居住国が異なる場合、ログインは可能だがログを記録
- `is_country_mismatch=true`の場合、不正購入検知用ログに記録

**処理フロー:**
1. W2（決済事前確認）で`custom_parameters.is_country_mismatch`をチェック
2. `true`の場合、`log_webstore_fraud_detection`テーブル（新規作成）に記録
   - `usr_user_id`
   - `country_from_ip`
   - `resident_country`
   - `mismatch_detected_at`
   - `order_id`（後で紐付け）

---

### 2.4. 購入回数制限の管理

**既存実装との統合:**
- `usr_store_products`テーブルを使用
- `purchase_count`: 期間内の購入回数
- `purchase_total_count`: 累計購入回数
- `last_reset_at`: リセット日時

**【不明点】**:
- 外部決済とアプリ内課金で購入回数を共有するか、別管理するか？
  - 共有する場合: `billing_platform`に関わらず同じ`product_sub_id`でカウント
  - 別管理する場合: `billing_platform`ごとに別レコード
- 仕様書に記載がないため、プランナーへの確認が必要

---

### 2.5. 国コード・通貨コードの永続化

**仕様:**
- ユーザー情報取得API（W1）で国コード・通貨コードを返す
- 起動時にアプリサーバー側で国及び通貨情報を保持していない場合はアプリサーバーに登録する
- **一度登録した国及び通貨情報は更新しない**

**実装方針（案）:**

**候補1: 既存テーブルの拡張**
- `usr_users`テーブルに`country_code`, `currency_code`カラムを追加
- 懸念: グローバルな情報を`usr_users`に入れるのは適切か？

**候補2: 新規テーブル作成**
- `usr_webstore_infos`テーブルを作成
  ```sql
  CREATE TABLE usr_webstore_infos (
    usr_user_id VARCHAR(255) PRIMARY KEY,
    country_code VARCHAR(2) NOT NULL,
    currency_code VARCHAR(3) NOT NULL,
    registered_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL
  );
  ```

**候補3: `usr_os_platforms`テーブルの拡張**
- `country_code`, `currency_code`カラムを追加
- 懸念: OS platformごとに国コードが異なることはあり得るか？

**【推奨】**: 候補2（新規テーブル作成）
- 外部決済固有の情報として分離
- 「一度登録したら更新しない」制約を実装しやすい（`registered_at`で判定）

---

#### デバッグ用の国コード・通貨コード上書き機能

**仕様:**
- 特定のバンダイナムコIDまたはアプリIDに対して、任意の国コード・通貨コードを返却できる

**実装方針（案）:**
- `usr_webstore_debug_overrides`テーブルを作成
  ```sql
  CREATE TABLE usr_webstore_debug_overrides (
    usr_user_id VARCHAR(255) PRIMARY KEY,
    override_country_code VARCHAR(2),
    override_currency_code VARCHAR(3),
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL
  );
  ```
- W1（ユーザー情報取得）で、このテーブルを優先的に参照

**【不明点】**: デバッグ用上書きの設定方法は？
- 管理ツール（admin）から設定するか？
- それともマイグレーションやSQLで直接設定するか？

---

### 2.6. 誕生日情報の管理

**仕様:**
- W1（ユーザー情報取得）で`birthday`（YYYYMMDD）と`birthday_month`（MM）を返す
- 誕生日情報がない場合、空文字で返すとログインできない
- アプリ側で誕生日を保持していない場合、WebStoreに事前申請が必要

**【重要な不明点】**:
1. アプリ側で誕生日情報を保持しているか？
   - `usr_users`テーブルに`birthday`カラムがあるか？
   - 既存のユーザー登録フローで誕生日を取得しているか？
2. 保持していない場合、以下のいずれの対応を取るか？
   - **A**: ユーザーに誕生日入力を求める画面を追加（開発スコープ拡大）
   - **B**: バンダイナムコIDに登録されている誕生日を取得（API仕様が不明）
   - **C**: WebStoreに事前申請して、アプリ側で誕生日を保持しない運用にする

**【プランナーへの確認が必須】**: 上記A/B/Cのいずれを採用するか

---

### 2.7. セキュリティ実装

#### ウェブフック署名検証

**仕様:**
- Xsollaからのウェブフックリクエストの署名を検証
- 署名検証に失敗した場合は、400エラーを返す

**実装方針:**
- Laravel Middlewareで実装
- 環境変数`XSOLLA_WEBHOOK_SECRET`を使用
- Xsollaの署名検証アルゴリズムに準拠（SHA-256ハッシュ等）

**【不明点】**: Xsollaの署名検証の詳細仕様は？（仕様書に記載があるか確認）

---

#### ウェブフック通知元IPアドレスの制限

**仕様:**
- ウェブフックエンドポイントへのアクセスを特定のIPアドレスに制限
- 許可IPアドレス以外からのリクエストは拒否

**実装方針（案）:**

**候補1: Laravel Middlewareで実装**
```php
class XsollaIpWhitelistMiddleware
{
    public function handle($request, Closure $next)
    {
        $allowedIps = explode(',', env('XSOLLA_ALLOWED_IPS'));
        if (!in_array($request->ip(), $allowedIps)) {
            abort(403, 'Forbidden');
        }
        return $next($request);
    }
}
```

**候補2: インフラレベル（ALB/NLB）で制御**
- AWS ALBのセキュリティグループでIP制限
- CloudFront + WAFでIP制限

**【推奨】**: 候補2（インフラレベル）
- アプリケーション層に到達する前にブロック
- DDoS攻撃への対応が容易

---

### 2.8. 重複処理防止（べき等性の保証）

**仕様:**
- W5（注文支払い成功）で、同一`order.id`で複数回リクエストが来た場合、1回目の処理結果を返す
- 通信エラーによるリトライで重複付与を防止

**実装方針:**
1. `usr_store_product_histories`テーブルに`receipt_unique_id`（`order.id`）を保存
2. `receipt_unique_id`にユニークインデックスを設定
3. W5の処理フロー:
   ```php
   // 1. 重複チェック
   $existingHistory = UsrStoreProductHistory::where('receipt_unique_id', $orderId)->first();
   if ($existingHistory) {
       // 既に処理済み: 1回目の結果を返す
       return response()->json([
           'result' => 'success',
           'order_id' => $orderId
       ]);
   }

   // 2. トランザクション開始
   DB::transaction(function () use (...) {
       // 3. usr_store_product_histories に挿入
       try {
           UsrStoreProductHistory::create([
               'receipt_unique_id' => $orderId,
               // ...
           ]);
       } catch (QueryException $e) {
           // ユニーク制約違反: 別のリクエストが先に処理を完了した
           // エラーを投げず、重複チェックのロジックに戻る
           throw new DuplicateReceiptException();
       }

       // 4. アイテム付与
       // 5. Bank/Adjust連携
       // 6. ログ記録
   });
   ```

---

### 2.9. デッドロック対策

**仕様:**
- アプリ内課金とWeb課金が同時発生した場合、デッドロックが発生しないようにする

**実装方針:**
1. **テーブルへのアクセス順序を統一**
   - 常に以下の順序でロック取得
     1. `usr_users`
     2. `usr_store_infos`
     3. `usr_store_products`
     4. `usr_items`
     5. `usr_store_product_histories`（最後に挿入）

2. **楽観的ロック（Optimistic Locking）の導入**
   - `usr_store_infos`に`version`カラムを追加
   - 更新時にバージョンをチェック
   ```php
   $storeInfo = UsrStoreInfo::where('usr_user_id', $usrUserId)
                            ->where('version', $expectedVersion)
                            ->first();
   if (!$storeInfo) {
       throw new ConcurrentUpdateException();
   }
   $storeInfo->update(['version' => $expectedVersion + 1, ...]);
   ```

3. **トランザクション分離レベルの調整**
   - `READ COMMITTED`または`REPEATABLE READ`を使用
   - デッドロック発生時のリトライロジックを実装

**【不明点】**: 既存のアプリ内課金でデッドロック対策は実装されているか？
- 実装されている場合、同じパターンを踏襲
- 実装されていない場合、外部決済を機に導入を検討

---

### 2.10. 外部連携

#### Bank連携

**仕様:**
- 外部決済の購入データをBankシステムに送信

**実装方針:**
- 既存の`LogBankService`を使用
- W5（注文支払い成功）で、アイテム付与成功後にBank送信
- 送信内容:
  - `usr_user_id`
  - `event_id`: "100"（購入イベント）
  - `country_code`: カスタムパラメータの`country_from_ip`または`usr_webstore_infos.country_code`
  - `currency_code`: `order.currency`
  - `purchase_amount`: `order.amount`
  - その他必要な情報

**【不明点】**:
- Bank連携が失敗した場合、エラーを返すか、ログだけ記録して200を返すか？
- 仕様書に記載がないため、技術判断が必要

---

#### Adjust連携

**仕様:**
- アイテム付与時にAdjustへクライアントIPアドレスを含む情報を送信
- カスタムパラメータ`user_ip`を使用

**実装方針:**
- Adjust APIへのHTTPリクエストを実装（Guzzle等を使用）
- W5（注文支払い成功）で、アイテム付与成功後にAdjust送信
- 送信内容:
  - `user_ip`: カスタムパラメータの`user_ip`
  - `usr_user_id`: カスタムパラメータの`internal_id`
  - `ad_id`: `log_banks.ad_id`から取得（既存の仕組みを確認）
  - その他必要な情報

**【重要な不明点】**:
1. 既存のアプリ内課金でAdjust連携はどのように実装されているか？
   - コードベース調査で明示的な実装が見つからなかった
   - 既存実装があれば、それを参考にする
2. Adjust APIのエンドポイントURL、認証方法、リクエスト形式は？
   - 仕様書に記載があるか確認
   - ない場合、Adjustのドキュメントを参照

---

### 2.11. エラーハンドリングとステータスコード

#### 新規エラーコードの定義

外部決済用に以下のエラーコードを追加:

| エラーコード | HTTPステータス | 説明 |
|------------|---------------|------|
| `WEBSTORE_USER_NOT_FOUND` | 400 | ユーザーが未登録 |
| `WEBSTORE_USER_TOO_YOUNG` | 400 | 13歳以下（海外）でログイン不可 |
| `WEBSTORE_PURCHASE_NOT_ALLOWED_UNDER_18` | 400 | 18歳未満（日本）で有料商品を購入しようとした |
| `WEBSTORE_PURCHASE_NOT_ALLOWED_CHILD_ACCOUNT` | 400 | 子供アカウント（海外）で有料商品を購入しようとした |
| `WEBSTORE_COUNTRY_MISMATCH` | 400 | ダウンロード国と居住国が不一致 |
| `WEBSTORE_DUPLICATE_ORDER` | 400 | 同一order.idで重複リクエスト |
| `WEBSTORE_SIGNATURE_INVALID` | 400 | 署名検証失敗 |
| `WEBSTORE_MAINTENANCE` | 503 | メンテナンス中 |
| `WEBSTORE_INTERNAL_ERROR` | 500 | 内部エラー（リトライ可能） |

---

#### 永続エラーと一時エラーの区別

**永続エラー（400）**:
- リトライしても解決しないエラー
- 返金が必要
- 例: 年齢制限違反、購入回数上限、国コード不一致

**一時エラー（500）**:
- リトライすれば解決する可能性があるエラー
- 例: DB接続エラー、タイムアウト、一時的なリソース不足

**メンテナンスエラー（503）**:
- メンテナンス中
- Xsolla側でリトライ

---

### 2.12. 無料アイテム・クーポンの特殊処理

**仕様:**
- 無料アイテムやクーポン交換の場合、以下の挙動に対応:
  - `order.invoice_id`がNULL
  - `order.currency`がNULL
  - 「ユーザーの検証」「支払い」ウェブフックが発生しない

**実装方針:**
1. `usr_store_product_histories`の`invoice_id`, `currency_code`カラムをNULL許容に変更
   ```php
   $table->string('invoice_id', 255)->nullable();
   $table->string('currency_code', 16)->nullable();
   ```

2. W5（注文支払い成功）で、NULL値を適切に処理
   ```php
   $invoiceId = $order['invoice_id'] ?? null;
   $currencyCode = $order['currency'] ?? null;
   $purchasePrice = $order['amount'] ?? 0;

   UsrStoreProductHistory::create([
       'invoice_id' => $invoiceId,
       'currency_code' => $currencyCode,
       'purchase_price' => $purchasePrice,
       // ...
   ]);
   ```

3. 年齢制限の判定で、無料アイテムは許可
   ```php
   // 18歳未満で有料商品の場合はエラー
   if ($age < 18 && $order['amount'] > 0) {
       throw new GameException(ErrorCode::WEBSTORE_PURCHASE_NOT_ALLOWED_UNDER_18);
   }
   ```

---

### 2.13. キャンセルウェブフックの処理

**仕様:**
- Xsollaからキャンセル通知が来た場合は、500エラーを返す
- システム的なキャンセルの連携は行わない

**実装方針:**
- キャンセルウェブフック用のエンドポイントを実装
- 常に500エラーを返す
```php
public function handleCancel(Request $request)
{
    // ログに記録（任意）
    Log::info('Received cancel webhook (rejected)', [
        'request_body' => $request->all()
    ]);

    // 500エラーを返す
    return response()->json([
        'error' => [
            'message' => 'Cancel is not supported'
        ]
    ], 500);
}
```

---

### 2.14. ウェブフックの死活監視

**仕様:**
- ウェブフックエンドポイントの正常性を監視
- 異常検知時にアラート通知

**実装方針（案）:**

**1. ヘルスチェックエンドポイントの実装**
```php
public function healthCheck(Request $request)
{
    // DB接続確認
    DB::connection()->getPdo();

    return response()->json(['status' => 'ok']);
}
```

**2. CloudWatch Alarmsでエラー率を監視**
- 5xx系エラーが一定以上発生した場合、アラート
- SNS経由でSlack/メール通知

**3. 定期的なテストリクエストの送信（オプション）**
- Xsolla側から定期的にヘルスチェックを送信
- 失敗した場合、Xsolla側でアラート

---

### 2.15. ログ記録とトレーサビリティ

#### 新規ログテーブルの設計

**`log_webstore_webhooks`**: ウェブフック受信ログ
```sql
CREATE TABLE log_webstore_webhooks (
  id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  webhook_type VARCHAR(50) NOT NULL,  -- 'user_validation', 'payment_validation', etc.
  request_body MEDIUMTEXT NOT NULL,   -- リクエストボディ全体（JSON）
  response_status INT NOT NULL,        -- HTTPステータスコード
  response_body TEXT,                  -- レスポンスボディ（JSON）
  request_id VARCHAR(255) NOT NULL,
  nginx_request_id VARCHAR(255) NOT NULL,
  created_at TIMESTAMP NOT NULL,
  INDEX idx_webhook_type (webhook_type),
  INDEX idx_created_at (created_at)
);
```

**`log_webstore_transactions`**: トランザクションログ
```sql
CREATE TABLE log_webstore_transactions (
  id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  usr_user_id VARCHAR(255) NOT NULL,
  transaction_id VARCHAR(255),         -- 決済事前確認で発行したトランザクションID
  order_id VARCHAR(255),               -- Xsollaのorder.id
  invoice_id VARCHAR(255),             -- Xsollaのorder.invoice_id
  mst_store_product_id VARCHAR(255) NOT NULL,
  currency_code VARCHAR(16),
  purchase_price DECIMAL(20,6),
  is_sandbox TINYINT NOT NULL,
  status VARCHAR(50) NOT NULL,         -- 'pending', 'completed', 'failed', 'refunded'
  error_code VARCHAR(100),
  error_message TEXT,
  request_id VARCHAR(255) NOT NULL,
  nginx_request_id VARCHAR(255) NOT NULL,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL,
  INDEX idx_usr_user_id (usr_user_id),
  INDEX idx_order_id (order_id),
  INDEX idx_status (status)
);
```

**`log_webstore_fraud_detection`**: 不正購入検知ログ
```sql
CREATE TABLE log_webstore_fraud_detection (
  id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  usr_user_id VARCHAR(255) NOT NULL,
  order_id VARCHAR(255),
  country_from_ip VARCHAR(2),          -- IPアドレスから判定した国
  resident_country VARCHAR(2),         -- 居住国
  is_country_mismatch TINYINT NOT NULL,
  mismatch_detected_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP NOT NULL,
  INDEX idx_usr_user_id (usr_user_id),
  INDEX idx_mismatch_detected_at (mismatch_detected_at)
);
```

---

### 2.16. トランザクションID管理

**仕様:**
- W2（決済事前確認）で発行
- W5（注文支払い成功）で照合

**実装方針:**
1. トランザクションID発行
   ```php
   $transactionId = (string) Str::uuid();
   ```

2. `log_webstore_transactions`に保存
   ```php
   LogWebStoreTransaction::create([
       'usr_user_id' => $usrUserId,
       'transaction_id' => $transactionId,
       'mst_store_product_id' => $productId,
       'status' => 'pending',
       'created_at' => $now,
   ]);
   ```

3. W5で照合
   ```php
   $transaction = LogWebStoreTransaction::where('transaction_id', $transactionId)
                                        ->where('usr_user_id', $usrUserId)
                                        ->where('status', 'pending')
                                        ->first();
   if (!$transaction) {
       throw new GameException(ErrorCode::WEBSTORE_TRANSACTION_NOT_FOUND);
   }

   $transaction->update([
       'order_id' => $orderId,
       'invoice_id' => $invoiceId,
       'status' => 'completed',
   ]);
   ```

**【不明点】**: トランザクションIDの有効期限を設定するか？
- 設定する場合: 発行から24時間以内に決済完了が必要
- 設定しない場合: 永続的に有効
- プランナーへの確認は不要（技術判断でOK）
- **推奨**: 24時間の有効期限を設定（不正購入防止）

---

### 2.17. テスト決済の管理

**仕様:**
- `transaction.dry_run=1`（支払いウェブフック）
- `order.mode="sandbox"`（注文支払い成功ウェブフック）

**実装方針:**
1. `is_sandbox`フラグを設定
   ```php
   $isSandbox = ($order['mode'] ?? '') === 'sandbox' ? 1 : 0;
   ```

2. `usr_store_product_histories`と`log_webstore_transactions`の両方に記録
   ```php
   UsrStoreProductHistory::create([
       'is_sandbox' => $isSandbox,
       // ...
   ]);

   LogWebStoreTransaction::create([
       'is_sandbox' => $isSandbox,
       // ...
   ]);
   ```

3. Bank/Adjust連携では、テスト決済を除外（オプション）
   ```php
   if ($isSandbox == 0) {
       // Bank連携
       // Adjust連携
   }
   ```

---

### 2.18. items配列のフィルタリング

**仕様:**
- `items`配列から`type=virtual_good`のみを処理
- 他のタイプ（クーポン、無料アイテム等）は無視

**実装方針:**
```php
$virtualGoodItems = array_filter($items, function ($item) {
    return ($item['type'] ?? '') === 'virtual_good';
});

if (empty($virtualGoodItems)) {
    throw new GameException(ErrorCode::WEBSTORE_NO_VIRTUAL_GOOD_ITEMS);
}

foreach ($virtualGoodItems as $item) {
    $sku = $item['sku'];
    $amount = $item['amount'];
    // SKUから商品情報を取得して処理
}
```

---

### 2.19. 返金処理の実装

**仕様:**
- W5（注文支払い成功）で永続エラーが発生した場合、返金が必要
- 400エラーを返すと、Xsolla側でリトライは行わない

**【重要な不明点】**:
1. 返金処理を自動化するか、手動で行うか？
   - **自動化する場合**: Xsolla APIで返金リクエストを送信
   - **手動で行う場合**: 管理ツールで返金対象を確認し、Xsollaの管理画面で手動返金

2. 返金対象のトランザクションをどのように管理するか？
   - `log_webstore_transactions.status = 'refund_required'`にして、管理ツールで一覧表示
   - アラート通知（Slack/メール）で運用チームに通知

**【推奨】**: 手動返金 + アラート通知
- 自動返金はリスクが高い（誤操作で大量返金等）
- 運用チームが確認してから返金する方が安全

**実装方針:**
1. 永続エラー発生時、`log_webstore_transactions.status = 'refund_required'`に設定
2. CloudWatch Alarmsでアラート送信
3. 管理ツールで返金対象を一覧表示
4. 運用チームがXsollaの管理画面で手動返金
5. 返金完了後、`status = 'refunded'`に更新

---

## 3. 不明点・曖昧点・判断が必要な項目

### A. 仕様書に記載がなく判断不能な項目

#### A-1: 誕生日情報の保持状況と取得方法

**該当箇所:**
- 仕様書 Page 19「アプリ側の誕生日を使った年齢認証について」
- 要件27: 誕生日情報の管理

**何が曖昧なのか:**
- アプリ側で誕生日情報を保持しているか不明
- 保持していない場合、どの方法で取得するか未確定
  - A: ユーザーに誕生日入力を求める画面を追加
  - B: バンダイナムコIDから取得
  - C: WebStoreに事前申請して、誕生日を保持しない運用

**サーバーとして明確化が必要な理由:**
- W1（ユーザー情報取得）で`birthday`と`birthday_month`を返す必要がある
- 誕生日情報がない場合、ログインできない（仕様書明記）
- 開発スコープに大きく影響（画面追加の有無、API連携の要否）

---

#### A-2: バンダイナムコID居住国の取得方法

**該当箇所:**
- 仕様書 Page 1「国の制御（海外版のみ）」
- 要件4: 国の制御

**何が曖昧なのか:**
- バンダイナムコIDの居住国を取得するAPIの仕様が不明
- 既存の`BNID_ACCESS_TOKEN_URL`等で取得可能か不明

**サーバーとして明確化が必要な理由:**
- ダウンロード国と居住国の照合処理を実装できない
- 不一致の場合、ログインを拒否する必要がある

---

#### A-3: 子供アカウントの判定方法

**該当箇所:**
- 仕様書 Page 1「年齢による制御（海外）」
- 要件3: 年齢による制御（海外）

**何が曖昧なのか:**
- 「14歳以上の子供アカウント」の判定方法が不明
- 年齢だけで判定するのか、アカウント種別フラグがあるのか不明

**サーバーとして明確化が必要な理由:**
- W2（決済事前確認）で子供アカウントの有料購入を拒否する必要がある
- 判定ロジックの実装ができない

---

#### A-4: Adjust連携の既存実装状況

**該当箇所:**
- 仕様書 Page 3「AdjustにクライアントIPを送信」
- 追加要件10: Adjust連携

**何が曖昧なのか:**
- 既存のアプリ内課金でAdjust連携がどのように実装されているか不明
- Adjust APIのエンドポイントURL、認証方法、リクエスト形式が不明

**サーバーとして明確化が必要な理由:**
- 外部決済でもAdjust連携を実装する必要がある
- 既存実装があれば参考にできるが、ない場合は新規開発が必要

---

#### A-5: トランザクションIDの有効期限

**該当箇所:**
- 追加要件15: トランザクションIDの発行と管理

**何が曖昧なのか:**
- トランザクションIDに有効期限を設定するか不明
- 設定する場合、何時間/日に設定するか不明

**サーバーとして明確化が必要な理由:**
- 有効期限がないと、古いトランザクションIDで不正購入される可能性
- セキュリティリスクの評価が必要

**【技術判断で対応可能】**: 24時間の有効期限を設定（プランナー確認不要）

---

#### A-6: デバッグ用国コード上書きの設定方法

**該当箇所:**
- 仕様書 Page 21「国コード及び通貨コードのデバッグについて」
- 追加要件11: 国コード・通貨コードの管理

**何が曖昧なのか:**
- デバッグ用上書きの設定方法が不明
- 管理ツールから設定するか、SQLで直接設定するか不明

**サーバーとして明確化が必要な理由:**
- 設定方法により、開発スコープが変わる（管理画面の追加要否）

**【技術判断で対応可能】**: SQLで直接設定（管理画面は後から追加可能）

---

#### A-7: Xsollaウェブフックの署名検証仕様

**該当箇所:**
- 仕様書 Page 9「ウェブフック > 概要」
- 要件14: ウェブフックの署名検証

**何が曖昧なのか:**
- Xsollaの署名検証の詳細仕様が不明
- 署名アルゴリズム（SHA-256等）、署名ヘッダー名、検証方法が不明

**サーバーとして明確化が必要な理由:**
- 署名検証を実装できない
- セキュリティ上重要な機能

**【対応方法】**: Xsollaの公式ドキュメントまたは仕様書の該当セクションを確認

---

#### A-8: 国コード・通貨コードの保存先テーブル

**該当箇所:**
- 追加要件11: 国コード・通貨コードの管理

**何が曖昧なのか:**
- 国コード・通貨コードをどのテーブルに保存するか未確定
- 候補: `usr_users`, `usr_os_platforms`, 新規テーブル`usr_webstore_infos`

**サーバーとして明確化が必要な理由:**
- テーブル設計とマイグレーション作成に必要

**【技術判断で対応可能】**: 新規テーブル`usr_webstore_infos`を作成（推奨）

---

### B. 仕様書とコードの不一致

#### B-1: 購入回数制限の共有/別管理

**該当ファイル:**
- 追加要件3: 購入回数制限の管理
- `usr_store_products`テーブル

**どのように矛盾しているか:**
- 仕様書では外部決済とアプリ内課金の購入回数制限の関係が明記されていない
- 既存の`usr_store_products`テーブルでは`billing_platform`がPRIになっていない
  - 共有する場合: `billing_platform`に関わらず同じレコード
  - 別管理する場合: `billing_platform`ごとに別レコード（テーブル設計変更が必要）

**影響:**
- 共有する場合: 外部決済とアプリ内課金の購入回数が合算される
- 別管理する場合: それぞれ独立した購入回数制限

---

#### B-2: 既存テーブルの外部決済対応状況

**該当ファイル:**
- 追加要件1: 既存テーブルの拡張
- `usr_store_product_histories`テーブル

**どのように矛盾しているか:**
- 仕様書では外部決済固有の情報（`order.id`, `order.invoice_id`等）を保存する必要がある
- 既存の`usr_store_product_histories`テーブルには対応するカラムがない
- `billing_platform`に新しい値（"webstore", "xsolla"）を追加する必要があるが、既存の値がどうなっているか不明

**影響:**
- テーブル構造の変更（カラム追加）が必要
- 既存データへの影響を考慮する必要がある

---

### C. サーバー側で仕様確定が必要な項目

#### C-1: アイテム付与失敗時のエラーポリシー

**決める必要がある点:**
- W5（注文支払い成功）でアイテム付与が失敗した場合の挙動
  - パターンA: エラーを返してXsollaにリトライさせる（500エラー）
  - パターンB: メッセージボックスに送る（200を返す）
  - パターンC: エラーログを記録し、手動対応（200を返す）

**プランナーへの確認ポイント:**
- **Q1**: アイテム付与失敗（リソース上限超過等）の場合、ユーザー体験としてどの挙動が望ましいですか？
  - A: アイテムがすぐに反映されないが、後でリトライして付与される（500エラー → Xsollaリトライ）
  - B: アイテムがメッセージボックスに送られる（200 → メッセージボックス）
  - C: 運用チームが手動で付与する（200 → 手動対応）

---

#### C-2: Bank/Adjust連携失敗時の挙動

**決める必要がある点:**
- W5（注文支払い成功）でBank/Adjust連携が失敗した場合の挙動
  - パターンA: エラーを返してXsollaにリトライさせる（500エラー）
  - パターンB: ログだけ記録して200を返す（購入は成功扱い）

**技術判断で対応可能（プランナー確認不要）:**
- Bank/Adjust連携は副次的な処理であり、本質的な購入処理ではない
- **推奨**: パターンB（ログ記録 + 200返却）
- 理由:
  - Bank/Adjust連携の失敗でユーザーがアイテムを受け取れないのは不適切
  - 後で手動でBank/Adjustにデータを送信すれば良い

---

#### C-3: 返金処理の自動化/手動化

**決める必要がある点:**
- 永続エラー発生時の返金処理を自動化するか、手動で行うか
  - パターンA: 自動返金（Xsolla APIで返金リクエスト送信）
  - パターンB: 手動返金（管理ツールで確認後、Xsolla管理画面で手動返金）

**技術判断で対応可能（プランナー確認不要）:**
- **推奨**: パターンB（手動返金）
- 理由:
  - 自動返金はリスクが高い（誤操作で大量返金等）
  - 運用チームが確認してから返金する方が安全
  - MVP（最小限の製品）として、まず手動対応で開始し、運用状況を見て自動化を検討

---

#### C-4: デッドロック対策の実装方式

**決める必要がある点:**
- アプリ内課金とWeb課金の同時実行時のデッドロック対策
  - パターンA: テーブルアクセス順序の統一
  - パターンB: 楽観的ロック（Optimistic Locking）
  - パターンC: 悲観的ロック（Pessimistic Locking / SELECT FOR UPDATE）

**技術判断で対応可能（プランナー確認不要）:**
- **推奨**: パターンA + パターンB（テーブルアクセス順序の統一 + 楽観的ロック）
- 理由:
  - パターンCはロック待ちでパフォーマンスが低下する
  - 既存のアプリ内課金でデッドロック対策が実装されている場合、それに倣う

---

### D. ゲーム体験的に不自然な可能性がある項目

#### D-1: 購入回数制限の共有/別管理（再掲）

**問題点:**
- 仕様書に記載がないため、以下の2パターンが考えられる
  - **共有**: アプリ内課金で月に10回購入した商品は、外部決済では購入できない
  - **別管理**: アプリ内課金と外部決済で別々に月10回ずつ購入できる（合計20回）

**想定される影響:**
- **共有の場合**: ユーザーは「なぜWeb Storeで購入できないのか」と混乱する可能性
- **別管理の場合**: 購入回数制限の意図（課金額の制限）が骨抜きになる可能性

**プランナーへの確認が必要:**
- **Q2**: 外部決済とアプリ内課金の購入回数制限は共有しますか、それとも別管理しますか？

---

#### D-2: アイテム反映のポップアップ通知の実装範囲

**問題点:**
- 仕様書では「推奨仕様」と記載されているが、必須かどうか不明
- 通知状態の管理をサーバー側で行うのか、クライアント側で行うのか不明

**想定される影響:**
- サーバー側で管理する場合: 通知状態を保存するテーブルが必要
- クライアント側で管理する場合: サーバー側の実装は不要

**プランナーへの確認が必要:**
- **Q3**: アイテム反映のポップアップ通知は必須機能ですか？
- **Q4**: 通知状態の管理はサーバー側で行いますか、それともクライアント側で行いますか？

---

#### D-3: 無料アイテム・クーポン交換の年齢制限

**問題点:**
- 仕様書では「18歳未満は無料アイテムとプロモーションコードのみ利用可能」とあるが、無料アイテムの年齢制限が明確でない
- 例: 18歳未満が無料で入手できるアイテムに年齢制限があるか？

**想定される影響:**
- 年齢制限がない場合: 18歳未満でもすべての無料アイテムを入手可能
- 年齢制限がある場合: 特定の無料アイテム（例: R18コンテンツ）は入手不可

**プランナーへの確認が必要:**
- **Q5**: 無料アイテムに年齢制限はありますか？ある場合、どのように判定しますか？

---

## 4. プランナーへ確認が必要な項目まとめ（最重要）

### ゲーム体験・仕様に関する質問

#### Q1: 誕生日情報の取得方法

**背景:**
- ユーザー情報取得API（W1）で`birthday`と`birthday_month`を返す必要があります
- 誕生日情報がない場合、Web Storeにログインできません
- 現在、アプリ側で誕生日情報を保持しているか不明です

**質問:**
アプリ側で誕生日情報を保持していますか？保持していない場合、以下のどの方法で取得しますか？
- **A**: ユーザーに誕生日入力を求める画面を追加（開発スコープ拡大）
- **B**: バンダイナムコIDに登録されている誕生日を取得（API連携が必要）
- **C**: WebStoreに事前申請して、アプリ側で誕生日を保持しない運用にする

**選択肢Cを選ぶ場合の追加質問:**
- WebStoreへの事前申請は誰が行いますか？
- 申請に必要な情報・手続きは把握していますか？

---

#### Q2: 購入回数制限の共有/別管理

**背景:**
- 既存のアプリ内課金では、商品ごとに購入回数制限があります
- 外部決済でも同様の制限を適用する必要がありますが、仕様書には記載がありません

**質問:**
外部決済とアプリ内課金の購入回数制限は共有しますか、それとも別管理しますか？
- **共有する**: アプリで月10回購入した商品は、Webでは購入できない
- **別管理する**: アプリとWebでそれぞれ月10回ずつ購入できる（合計20回）

**ゲーム体験への影響:**
- 共有する場合: ユーザーは「なぜWebで購入できないのか」と混乱する可能性
- 別管理する場合: 購入回数制限の意図（課金額の制限）が骨抜きになる可能性

---

#### Q3: アイテム反映のポップアップ通知の実装範囲

**背景:**
- 仕様書では「ゲーム再起動時、またはショップ画面に遷移した際に、ユーザーにアイテムの反映をポップアップで通知する（推奨仕様）」と記載されています

**質問:**
- アイテム反映のポップアップ通知は必須機能ですか？
- 通知状態の管理はサーバー側で行いますか、それともクライアント側で行いますか？

**サーバー実装への影響:**
- サーバー側で管理する場合: 通知状態を保存するテーブル（例: `usr_webstore_notification_status`）が必要
- クライアント側で管理する場合: サーバー側の実装は不要

---

#### Q4: アイテム付与失敗時のユーザー体験

**背景:**
- 外部決済で購入後、アイテム付与が失敗する可能性があります（リソース上限超過、データ不整合等）
- 失敗時の挙動により、ユーザー体験が大きく変わります

**質問:**
アイテム付与が失敗した場合、以下のどの挙動が望ましいですか？
- **A**: アイテムがすぐに反映されないが、後でリトライして付与される
  - Xsolla側が自動リトライ（最大19回）
  - リトライが成功するまで、ユーザーはアイテムを受け取れない
- **B**: アイテムがメッセージボックスに送られる
  - 購入は成功扱い
  - ユーザーはメッセージボックスからアイテムを受け取る
- **C**: 運用チームが手動で付与する
  - 購入は成功扱い
  - ユーザーには「アイテムは後で付与されます」とメッセージ表示
  - 運用チームが確認して手動付与

**推奨:**
- パターンBまたはC
- 理由: パターンAはユーザーが長時間待たされる可能性があり、体験が悪い

---

#### Q5: 無料アイテムの年齢制限

**背景:**
- 仕様書では「18歳未満は無料アイテムとプロモーションコードのみ利用可能」とあります
- 無料アイテム自体に年齢制限があるかどうか不明です

**質問:**
無料アイテムに年齢制限はありますか？
- **ある場合**: どのように判定しますか？（例: 商品マスターに年齢制限フラグを追加）
- **ない場合**: 18歳未満でもすべての無料アイテムを入手可能

---

#### Q6: 子供アカウントの判定方法

**背景:**
- 仕様書では「14歳以上の子供アカウントは無料アイテムとプロモーションコードのみ利用可能（海外）」とあります
- 子供アカウントの判定方法が不明です

**質問:**
「子供アカウント」はどのように判定しますか？
- **A**: 年齢だけで判定（14-17歳）
- **B**: バンダイナムコIDのアカウント種別フラグで判定
- **C**: その他の方法

**選択肢Bの場合の追加質問:**
- アカウント種別フラグはユーザー情報取得APIで取得できますか？
- それとも別途APIを呼び出す必要がありますか？

---

### 技術仕様に関する質問

#### Q7: バンダイナムコID居住国の取得方法

**背景:**
- 仕様書では「アプリのダウンロード国とバンダイナムコIDの居住国が異なる場合、ログインできない」とあります
- バンダイナムコIDの居住国を取得するAPI仕様が不明です

**質問:**
- バンダイナムコIDの居住国を取得するAPIのエンドポイントURLは？
- 認証方法は？（既存の`BNID_ACCESS_TOKEN_URL`等で取得可能か？）
- リクエスト/レスポンス形式は？

**代替案:**
- WebStoreから居住国情報を受け取る（カスタムパラメータに含める）
- その場合、仕様書の修正が必要

---

#### Q8: Adjust連携の仕様

**背景:**
- 仕様書では「アイテム付与時にAdjustへクライアントIPを送信」とありますが、Adjust APIの仕様が不明です
- 既存のアプリ内課金でAdjust連携がどのように実装されているか不明です

**質問:**
- 既存のアプリ内課金でAdjust連携は実装されていますか？
- 実装されている場合、参考にできるコード・ドキュメントはありますか？
- Adjust APIのエンドポイントURL、認証方法、リクエスト形式を教えてください

**代替案:**
- Adjust連携をMVPから除外し、後のフェーズで実装する

---

## 5. サーバー開発への影響まとめ

### 実装前に必ず詰めるべき論点

#### 最優先（ブロッカー）:
1. **誕生日情報の取得方法（Q1）**: 開発スコープに大きく影響
   - 選択肢Aの場合: 画面追加の開発が必要（+2-3週間）
   - 選択肢Bの場合: API連携の実装が必要（+1-2週間）
   - 選択肢Cの場合: WebStore側との調整が必要（スケジュール不明）

2. **バンダイナムコID居住国の取得方法（Q7）**: 国コード照合処理を実装できない
   - API仕様が不明な場合、実装開始できない
   - 代替案（WebStoreから居住国情報を受け取る）の場合、仕様書の修正が必要

#### 高優先:
3. **購入回数制限の共有/別管理（Q2）**: テーブル設計に影響
   - 別管理の場合、`usr_store_products`テーブルの設計変更が必要

4. **子供アカウントの判定方法（Q6）**: 年齢制限処理を実装できない
   - 判定方法が不明な場合、実装開始できない

#### 中優先:
5. **アイテム付与失敗時のユーザー体験（Q4）**: エラーハンドリングの実装方針に影響
   - 選択肢により、実装内容が大きく変わる

6. **Adjust連携の仕様（Q8）**: 既存実装がない場合、新規開発が必要
   - MVPから除外する選択肢もあり

#### 低優先（MVP後でも可）:
7. **アイテム反映のポップアップ通知（Q3）**: 推奨仕様のため、MVP後でも可
8. **無料アイテムの年齢制限（Q5）**: ビジネスロジックの詳細化

---

### 不明点が残る場合のリスク

#### リスク1: 誕生日情報の取得方法が不明
- **影響**: W1（ユーザー情報取得）を実装できない → Web Storeにログインできない
- **深刻度**: 致命的（全体が動作しない）
- **対応**: Q1を最優先で確認

---

#### リスク2: バンダイナムコID居住国の取得方法が不明
- **影響**: 国コード照合処理を実装できない → 不正購入を防止できない
- **深刻度**: 高（セキュリティリスク）
- **対応**: Q7を高優先で確認、代替案（WebStoreから受け取る）を検討

---

#### リスク3: 購入回数制限の方針が不明
- **影響**: テーブル設計が確定しない → マイグレーション作成・実装が遅延
- **深刻度**: 中（実装遅延）
- **対応**: Q2を確認、デフォルトは「共有」で実装（後から変更可能）

---

#### リスク4: Adjust連携の仕様が不明
- **影響**: Adjust連携を実装できない → 購入データがAdjustに送信されない
- **深刻度**: 中（分析データの欠落）
- **対応**: Q8を確認、MVPから除外する選択肢も検討

---

### スケジュール・品質への影響

#### スケジュールへの影響:
- **最小ケース（すべての不明点が迅速に解決）**:
  - 実装期間: 4-6週間
  - 内訳:
    - 設計・レビュー: 1週間
    - 実装: 2-3週間
    - テスト: 1-2週間

- **最大ケース（誕生日入力画面の追加が必要）**:
  - 実装期間: 6-9週間
  - 内訳:
    - 設計・レビュー: 1-2週間
    - 実装: 3-5週間（画面追加を含む）
    - テスト: 2週間

---

#### 品質への影響:
- **不明点が残ったまま実装を開始した場合**:
  - 仕様変更による手戻りが発生（リスク: 高）
  - テーブル設計の変更により、既存データの移行が必要（リスク: 中）
  - セキュリティホールの発生（リスク: 高）

- **推奨事項**:
  - Q1, Q7は最優先で確認（ブロッカー）
  - Q2-Q6は高優先で確認（実装開始前に確定）
  - Q8は中優先で確認（MVPから除外も可）

---

## 6. 補足: 実装推奨事項（技術判断）

以下は、サーバーチームで技術判断可能な項目です（プランナー確認不要）。

### 6.1. データモデル設計

#### 新規テーブル: `usr_webstore_infos`
```sql
CREATE TABLE usr_webstore_infos (
  usr_user_id VARCHAR(255) PRIMARY KEY,
  country_code VARCHAR(2) NOT NULL,
  currency_code VARCHAR(3) NOT NULL,
  registered_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL,
  FOREIGN KEY (usr_user_id) REFERENCES usr_users(usr_user_id)
);
```

#### 既存テーブルの拡張: `usr_store_product_histories`
```sql
ALTER TABLE usr_store_product_histories
ADD COLUMN order_id VARCHAR(255) AFTER receipt_unique_id,
ADD COLUMN invoice_id VARCHAR(255) AFTER order_id,
ADD COLUMN transaction_id VARCHAR(255) AFTER invoice_id,
ADD UNIQUE INDEX idx_order_id (order_id);
```

---

### 6.2. トランザクションIDの有効期限

**推奨**: 24時間の有効期限を設定
- 理由: 不正購入防止（古いトランザクションIDの悪用を防ぐ）
- 実装: `log_webstore_transactions.created_at`から24時間経過したレコードは無効

---

### 6.3. Bank/Adjust連携失敗時の挙動

**推奨**: ログ記録 + 200返却
- 理由: Bank/Adjust連携の失敗でユーザーがアイテムを受け取れないのは不適切
- 実装: 連携失敗時もエラーログを記録し、200を返す（購入は成功扱い）

---

### 6.4. 返金処理の実装方式

**推奨**: 手動返金 + アラート通知
- 理由: 自動返金はリスクが高い（誤操作で大量返金等）
- 実装:
  1. 永続エラー発生時、`log_webstore_transactions.status = 'refund_required'`に設定
  2. CloudWatch Alarmsでアラート送信
  3. 管理ツールで返金対象を一覧表示
  4. 運用チームがXsolla管理画面で手動返金

---

### 6.5. デッドロック対策

**推奨**: テーブルアクセス順序の統一 + 楽観的ロック
- 理由: 悲観的ロックはパフォーマンス低下のリスク
- 実装:
  1. 常に以下の順序でテーブルにアクセス
     - `usr_users` → `usr_store_infos` → `usr_store_products` → `usr_items` → `usr_store_product_histories`
  2. `usr_store_infos`に`version`カラムを追加し、楽観的ロックを実装

---

### 6.6. デバッグ用国コード上書きの設定方法

**推奨**: SQLで直接設定（管理画面は後から追加）
- 理由: MVPでは管理画面の開発を省略し、開発スピードを優先
- 実装:
  1. `usr_webstore_debug_overrides`テーブルを作成
  2. デバッグ用にSQLで直接レコードを挿入
  3. 後のフェーズで管理画面を追加

---

## 7. まとめ

### 現時点での仕様の成熟度: 60%

**明確な部分（80%）:**
- ウェブフックの基本フロー
- 年齢・国による制御の基本ルール
- 不正購入防止の方針
- 既存システムとの共通点

**不明確な部分（40%）:**
- 誕生日情報の取得方法（ブロッカー）
- バンダイナムコID居住国の取得方法（高リスク）
- 購入回数制限の共有/別管理
- 子供アカウントの判定方法
- Adjust連携の仕様

---

### 次のアクション

1. **プランナーへ質問送付（Q1-Q8）**: 最優先
2. **質問回答の待機中に実施可能な作業**:
   - テーブル設計のドラフト作成
   - エラーコードの定義
   - ログ設計
   - 既存コードの詳細調査（Adjust連携、デッドロック対策等）
3. **質問回答後**:
   - 最終的なテーブル設計・マイグレーション作成
   - API設計書の作成
   - 実装開始

---

### 開発着手の判断基準

**着手可能な条件:**
- Q1（誕生日情報）とQ7（居住国取得）の回答を取得
- Q2（購入回数制限）の回答を取得（または「共有」で仮決め）

**その他の質問は開発並行で確認可能:**
- Q3-Q6: 実装の詳細化に影響するが、基本フローは実装可能
- Q8: MVPから除外する選択肢もあり
