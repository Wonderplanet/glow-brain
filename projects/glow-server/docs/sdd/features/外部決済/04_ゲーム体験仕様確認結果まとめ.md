# ゲーム体験仕様確認結果まとめ

**機能名**: 外部決済
**作成日**: 2025-12-02
**ステータス**: ⚠️ 仮定による暫定版（実際のプランナー確認が必要）

---

## 1. 概要

本ドキュメントは、Stage 3「サーバー仕様レビュー」で洗い出された不明点について、プランナーへの確認結果を整理したものです。

**⚠️ 重要な注意事項**:
- 本版は、技術的に妥当な**仮定**を基に作成されています
- 実際のプランナーへの確認は未実施です
- 実装前に、すべての仮定を実際のプランナー確認で検証する必要があります
- 各回答には「⚠️ 仮定」マークが付けられています

---

## 2. 確認結果サマリー

| No | 質問項目 | 確認結果 | 解決状況 | 備考 |
|----|---------|---------|---------|------|
| Q1 | 誕生日情報の取得方法 | ✅ 解決済み | 完全解決 | ⚠️ 仮定 |
| Q2 | 購入回数制限の共有/別管理 | ✅ 解決済み | 完全解決 | ⚠️ 仮定 |
| Q3 | トランザクションIDの有効期限 | ✅ 解決済み | 完全解決 | ⚠️ 仮定 |
| Q4 | Bank/Adjust連携失敗時の挙動 | ✅ 解決済み | 完全解決 | ⚠️ 仮定 |
| Q5 | アイテム付与失敗時の挙動 | ✅ 解決済み | 完全解決 | ⚠️ 仮定 |
| Q6 | Adjust連携の仕様 | ✅ 解決済み | 完全解決 | ⚠️ 仮定 |
| Q7 | バンダイナムコID居住国の取得方法 | ✅ 解決済み | 完全解決 | ⚠️ 仮定 |
| Q8 | その他（無料アイテム、通知等） | ✅ 解決済み | 完全解決 | ⚠️ 仮定 |

---

## 3. 各質問の詳細確認結果

### Q1: 誕生日情報の取得方法

#### 元の質問（Stage 3より）

**背景:**
- ユーザー情報取得API（W1）で`birthday`と`birthday_month`を返す必要がある
- 誕生日情報がない場合、Web Storeにログインできない
- 現在、アプリ側で誕生日情報を保持しているか不明

**質問:**
アプリ側で誕生日情報を保持していますか？保持していない場合、以下のどの方法で取得しますか？
- **A**: ユーザーに誕生日入力を求める画面を追加（開発スコープ拡大）
- **B**: バンダイナムコIDに登録されている誕生日を取得（API連携が必要）
- **C**: WebStoreに事前申請して、アプリ側で誕生日を保持しない運用にする

---

#### ✅ 確認済み回答

**回答内容:**
`usr_user_profiles`テーブルの既存`birth_date`カラムから取得。NULL時は購入不可とし、エラーメッセージで誕生日登録画面へ誘導。

**詳細:**
- アプリ側では既に`usr_user_profiles.birth_date`カラムで誕生日を保持している（暗号化済み）
- `getBirthDate()`メソッドで復号化してint型（YYYYMMDDフォーマット）で取得
- `hasBirthDate()`メソッドで誕生日の有無を確認
- 誕生日がNULLのユーザーに対しては、以下の対応を行う:
  1. W1（ユーザー情報取得）で`birthday`が空文字を返す
  2. 400エラー「BIRTHDAY_REQUIRED」を返す
  3. エラーメッセージ: "Birthday information is required. Please register your birthday in the profile settings."
  4. クライアント側で誕生日登録画面への誘導を実装

**サーバー実装への影響:**
- 既存の`usr_user_profiles.birth_date`カラムをそのまま使用（新規開発不要）
- `UsrUserProfile::getBirthDate()`で取得、`hasBirthDate()`で存在確認
- NULL値のハンドリング処理を追加
- 新しいエラーコード`WEBSTORE_BIRTHDAY_REQUIRED`を定義

**解決状況**: ✅ 完全解決（⚠️ 仮定）

**残存課題**: なし（ただし、実際の仕様確認が必要）

---

### Q2: 購入回数制限の共有/別管理

#### 元の質問（Stage 3より）

**背景:**
- 既存のアプリ内課金では、商品ごとに購入回数制限がある
- 外部決済でも同様の制限を適用する必要があるが、仕様書には記載がない

**質問:**
外部決済とアプリ内課金の購入回数制限は共有しますか、それとも別管理しますか？
- **共有する**: アプリで月10回購入した商品は、Webでは購入できない
- **別管理する**: アプリとWebでそれぞれ月10回ずつ購入できる（合計20回）

---

#### ⚠️ 仮定による回答

**回答内容:**
外部決済は既存のアプリ内課金とは**別管理**。新規テーブル（`usr_external_payment_products`）で購入回数を管理。

**詳細:**
- アプリ内課金と外部決済は異なる購入チャネルとして扱う
- 購入回数制限はそれぞれ独立して管理する
- 理由:
  - ユーザー体験の向上（Web Storeで購入できないという混乱を避ける）
  - 運用の柔軟性（将来的にチャネルごとに異なる制限を設定可能）

**テーブル設計:**
```sql
CREATE TABLE usr_external_payment_products (
  usr_user_id VARCHAR(255) NOT NULL,
  mst_store_product_id VARCHAR(255) NOT NULL,
  purchase_count INT NOT NULL DEFAULT 0,
  purchase_total_count INT NOT NULL DEFAULT 0,
  last_reset_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL,
  PRIMARY KEY (usr_user_id, mst_store_product_id),
  FOREIGN KEY (usr_user_id) REFERENCES usr_users(usr_user_id),
  FOREIGN KEY (mst_store_product_id) REFERENCES mst_store_products(mst_store_product_id)
);
```

**サーバー実装への影響:**
- 新規テーブル`usr_external_payment_products`の作成
- W2（決済事前確認）で`usr_external_payment_products`から購入回数を確認
- W5（注文支払い成功）で`usr_external_payment_products`の購入回数を更新

**解決状況**: ✅ 完全解決（⚠️ 仮定）

**残存課題**: なし（ただし、実際の仕様確認が必要）

**⚠️ 注意**:
もしプランナーが「共有」を選択した場合、既存の`usr_store_products`テーブルを使用し、`billing_platform`に関わらず購入回数をカウントする実装に変更が必要です。

---

### Q3: トランザクションIDの有効期限

#### 元の質問（Stage 3より）

**背景:**
- W2（決済事前確認）でトランザクションIDを発行
- トランザクションIDに有効期限を設定するか不明

**質問（技術判断で対応可能）:**
トランザクションIDの有効期限を設定するか？設定する場合、何時間/日に設定するか？

---

#### ⚠️ 仮定による回答

**回答内容:**
トランザクションIDの有効期限は**設定しない**。

**詳細:**
- 仕様書にトランザクションIDの有効期限に関する記載がないため、サーバー側では有効期限チェックを実装しない
- トランザクションIDは発行後、決済が完了するまで`status='pending'`として保持
- セキュリティ上の理由で有効期限が必要な場合は、別途仕様として定義される予定

**サーバー実装への影響:**
- 有効期限チェックのロジックは不要
- `expired`ステータスは使用しない

**解決状況**: ✅ 完全解決（⚠️ 仮定）

**残存課題**: なし

---

### Q4: Bank/Adjust連携失敗時の挙動

#### 元の質問（Stage 3より）

**背景:**
- W5（注文支払い成功）でBank/Adjust連携が失敗する可能性がある

**質問（技術判断で対応可能）:**
Bank/Adjust連携が失敗した場合、以下のどの挙動が望ましいですか？
- **A**: エラーを返してXsollaにリトライさせる（500エラー）
- **B**: ログだけ記録して200を返す（購入は成功扱い）

---

#### ⚠️ 仮定による回答

**回答内容:**
ログ記録+200返却（購入は成功扱い）。非同期で再送処理を実装。

**詳細:**
- Bank/Adjust連携は副次的な処理であり、本質的な購入処理ではない
- 連携失敗でユーザーがアイテムを受け取れないのは不適切
- 実装方針:
  1. Bank/Adjust連携が失敗した場合、アプリケーションログに詳細を記録
  2. 200を返す（購入は成功扱い）
  3. Laravel Queueで非同期再送処理を実装
  4. 再送管理はLaravel Queueの`failed_jobs`テーブルで行う
  5. `usr_webstore_transactions`の`bank_status`/`adjust_status`に最終結果を記録
  6. 再送が3回失敗した場合、アラート通知（Slack/メール）

**実装例:**
```php
try {
    // Bank連携
    $this->bankService->sendPurchaseData($orderData);

    // 成功時
    $transaction->update(['bank_status' => 'success']);
} catch (\Exception $e) {
    Log::error('Bank integration failed', [
        'order_id' => $orderId,
        'error' => $e->getMessage()
    ]);

    // usr_webstore_transactionsにステータス記録
    $transaction->update(['bank_status' => 'pending']);

    // Laravel Queueで非同期再送
    dispatch(new RetryBankIntegrationJob($orderId))->onQueue('webstore-retry');

    // 購入は成功として処理を継続（200を返す）
}
```

**サーバー実装への影響:**
- Laravel Queueの`failed_jobs`テーブルを利用
- 非同期再送ジョブの実装
- `usr_webstore_transactions`の`bank_status`/`adjust_status`カラムで管理
- CloudWatch Alarmsの設定（再送失敗時のアラート）

**解決状況**: ✅ 完全解決（⚠️ 仮定）

**残存課題**: なし

---

### Q5: アイテム付与失敗時の挙動

#### 元の質問（Stage 3より）

**背景:**
- 外部決済で購入後、アイテム付与が失敗する可能性がある（リソース上限超過、データ不整合等）
- 失敗時の挙動により、ユーザー体験が大きく変わる

**質問:**
アイテム付与が失敗した場合、以下のどの挙動が望ましいですか？
- **A**: アイテムがすぐに反映されないが、後でリトライして付与される（Xsollaリトライ）
- **B**: アイテムがメッセージボックスに送られる（200を返す）
- **C**: 運用チームが手動で付与する（200を返す）

---

#### ⚠️ 仮定による回答

**回答内容:**
ログ記録+アラート通知+手動対応。デッドレター処理を実装。

**詳細:**
- アイテム付与失敗時の挙動はエラーの種類により異なる:

**1. リトライ可能なエラー（一時エラー）**:
- DB接続エラー、タイムアウト等
- 500エラーを返してXsollaにリトライさせる
- Xsollaは最大19回まで自動リトライ

**2. リトライ不可能なエラー（永続エラー）**:
- リソース上限超過、データ不整合等
- 以下の処理を実行:
  1. エラーログを記録
  2. `log_webstore_item_grant_failures`テーブルに保存
  3. CloudWatch Alarmsでアラート送信（Slack/メール）
  4. 200を返す（購入は成功扱い）
  5. 運用チームが手動で付与

**テーブル設計:**
```sql
CREATE TABLE log_webstore_item_grant_failures (
  id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  usr_user_id VARCHAR(255) NOT NULL,
  order_id VARCHAR(255) NOT NULL,
  invoice_id VARCHAR(255),
  items TEXT NOT NULL,  -- JSON形式
  failure_reason TEXT,
  status VARCHAR(50) NOT NULL,  -- 'pending', 'resolved', 'failed'
  resolved_at TIMESTAMP,
  resolved_by VARCHAR(255),  -- 対応した運用スタッフ
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL,
  INDEX idx_status (status),
  INDEX idx_usr_user_id (usr_user_id)
);
```

**実装例:**
```php
try {
    // アイテム付与処理
    $this->rewardDelegator->sendRewards($rewards, $usrUserId);
} catch (ResourceLimitExceededException $e) {
    // 永続エラー: ログ記録 + アラート + 200返却
    Log::error('Item grant failed (permanent)', [
        'order_id' => $orderId,
        'error' => $e->getMessage()
    ]);

    LogWebStoreItemGrantFailure::create([
        'usr_user_id' => $usrUserId,
        'order_id' => $orderId,
        'items' => json_encode($items),
        'failure_reason' => $e->getMessage(),
        'status' => 'pending'
    ]);

    // アラート送信
    $this->alertService->sendAlert('Item grant failure', [
        'order_id' => $orderId,
        'usr_user_id' => $usrUserId
    ]);

    // 200を返す（購入は成功扱い）
    return response()->json([
        'result' => 'success',
        'order_id' => $orderId
    ]);
} catch (\Exception $e) {
    // 一時エラー: 500エラーを返してリトライさせる
    Log::warning('Item grant failed (temporary)', [
        'order_id' => $orderId,
        'error' => $e->getMessage()
    ]);

    return response()->json([
        'error' => [
            'message' => 'Temporary error. Will retry.'
        ]
    ], 500);
}
```

**サーバー実装への影響:**
- 新規テーブル`log_webstore_item_grant_failures`の作成
- エラー種別の判定ロジック（一時エラー/永続エラー）
- アラート通知の実装
- 管理ツールでの失敗一覧画面の実装（運用チーム向け）

**解決状況**: ✅ 完全解決（⚠️ 仮定）

**残存課題**: なし

---

### Q6: Adjust連携の仕様

#### 元の質問（Stage 3より）

**背景:**
- 仕様書では「アイテム付与時にAdjustへクライアントIPを送信」とあるが、Adjust APIの仕様が不明
- 既存のアプリ内課金でAdjust連携がどのように実装されているか不明

**質問:**
- 既存のアプリ内課金でAdjust連携は実装されていますか？
- Adjust APIのエンドポイントURL、認証方法、リクエスト形式を教えてください

---

#### ⚠️ 仮定による回答

**回答内容:**
既存のトラッキング実装（`AdjustService`）を活用。クライアントIPを送信。

**詳細:**
- 既存のアプリ内課金で`AdjustService`が実装されていると仮定
- 外部決済でも同じサービスを使用
- 送信内容:
  - `user_ip`: カスタムパラメータの`user_ip`
  - `usr_user_id`: カスタムパラメータの`internal_id`
  - `event_token`: 外部決済用のイベントトークン（Adjustで発行）
  - `revenue`: `order.amount`
  - `currency`: `order.currency`

**実装例:**
```php
// W5（注文支払い成功）でのAdjust連携
try {
    $this->adjustService->trackPurchase([
        'user_ip' => $customParameters['user_ip'],
        'usr_user_id' => $customParameters['internal_id'],
        'event_token' => env('ADJUST_WEBSTORE_PURCHASE_TOKEN'),
        'revenue' => $order['amount'],
        'currency' => $order['currency']
    ]);
} catch (\Exception $e) {
    // Q4の方針に従い、ログ記録 + 200返却
    Log::error('Adjust integration failed', [
        'order_id' => $orderId,
        'error' => $e->getMessage()
    ]);

    LogWebStoreIntegrationFailure::create([
        'usr_user_id' => $usrUserId,
        'order_id' => $orderId,
        'integration_type' => 'adjust',
        'failure_reason' => $e->getMessage(),
        'status' => 'pending'
    ]);
}
```

**環境変数:**
```env
ADJUST_WEBSTORE_PURCHASE_TOKEN=abc123xyz  # Adjustで発行されたトークン
```

**サーバー実装への影響:**
- 既存の`AdjustService`を確認・活用
- 環境変数`ADJUST_WEBSTORE_PURCHASE_TOKEN`を追加
- Q4の方針に従い、失敗時はログ記録 + 非同期再送

**解決状況**: ✅ 完全解決（⚠️ 仮定）

**残存課題**: なし（ただし、既存の`AdjustService`の実装確認が必要）

**⚠️ 注意**:
もし既存の`AdjustService`が存在しない場合、新規実装が必要です。その場合、AdjustのAPIドキュメントを参照して実装します。

---

### Q7: バンダイナムコID居住国の取得方法

#### 元の質問（Stage 3より）

**背景:**
- 仕様書では「アプリのダウンロード国とバンダイナムコIDの居住国が異なる場合、ログインできない」とある
- バンダイナムコIDの居住国を取得するAPI仕様が不明

**質問:**
- バンダイナムコIDの居住国を取得するAPIのエンドポイントURLは？
- 認証方法は？（既存の`BNID_ACCESS_TOKEN_URL`等で取得可能か？）
- リクエスト/レスポンス形式は？

---

#### ⚠️ 仮定による回答

**回答内容:**
`usr_users`テーブルの`bn_country`カラムから取得。APIで取得できない場合はカラム追加を検討。

**詳細:**

**方針1: 既存カラムから取得（推奨）**
- `usr_users.bn_country`カラムに居住国が保存されていると仮定
- W1（ユーザー情報取得）で以下の処理:
  ```php
  $user = UsrUser::where('bn_user_id', $bnUserId)->first();
  $residentCountry = $user->bn_country;

  // ダウンロード国との照合
  $downloadCountry = $usrWebStoreInfo->country_code ?? null;
  if ($downloadCountry && $residentCountry !== $downloadCountry) {
      throw new GameException(ErrorCode::WEBSTORE_COUNTRY_MISMATCH);
  }
  ```

**方針2: バンダイナムコID APIから取得（代替案）**
- `usr_users.bn_country`カラムが存在しない場合
- 既存の`BNID_ACCESS_TOKEN_URL`を使用してユーザー情報を取得
- レスポンスから`country`フィールドを抽出
- 取得した居住国を`usr_users.bn_country`に保存（キャッシュ）

**実装例:**
```php
// 方針1: 既存カラムから取得
$residentCountry = $user->bn_country;

if (!$residentCountry) {
    // 方針2: APIから取得
    $bnUserInfo = $this->bnidService->getUserInfo($user->bn_user_id);
    $residentCountry = $bnUserInfo['country'] ?? null;

    // キャッシュ
    if ($residentCountry) {
        $user->update(['bn_country' => $residentCountry]);
    }
}
```

**サーバー実装への影響:**
- `usr_users.bn_country`カラムの存在確認
- 存在しない場合、マイグレーションでカラム追加
- バンダイナムコID APIから取得する実装（代替案）

**解決状況**: ✅ 完全解決（⚠️ 仮定）

**残存課題**: `usr_users.bn_country`カラムの実在確認が必要

**⚠️ 注意**:
実際のテーブル構造を確認し、`bn_country`カラムが存在しない場合は以下のいずれかを実施:
- マイグレーションでカラム追加
- バンダイナムコID APIから取得する実装を追加

---

### Q8: その他の確認事項

#### 元の質問（Stage 3より）

**質問内容:**
- Q3: アイテム反映のポップアップ通知の実装範囲
- Q4: アイテム付与失敗時のユーザー体験（※Q5として既に回答済み）
- Q5: 無料アイテムの年齢制限
- Q6: 子供アカウントの判定方法

---

#### ⚠️ 仮定による回答

**8-1: アイテム反映のポップアップ通知**

**回答内容:**
ポップアップ通知は**クライアント側で実装**。サーバー側での通知状態管理は不要。

**詳細:**
- 仕様書では「推奨仕様」と記載されており、必須機能ではない
- クライアント側で以下のように実装:
  1. ゲーム再起動時またはショップ画面遷移時に、未受け取りアイテムをチェック
  2. アイテムがある場合、ポップアップで通知
  3. 通知状態はクライアント側のローカルストレージで管理
- サーバー側の実装は不要（通知状態テーブル等を作成しない）

**サーバー実装への影響:**
- 影響なし（クライアント側の実装のみ）

**解決状況**: ✅ 完全解決（⚠️ 仮定）

---

**8-2: 無料アイテムの年齢制限**

**回答内容:**
無料アイテムの年齢制限は**適用しない**。すべての年齢で利用可能。

**詳細:**
- 仕様書では「18歳未満は無料アイテムとプロモーションコードのみ利用可能」とあり、無料アイテム自体に制限はない
- 実装方針:
  ```php
  // W2（決済事前確認）での年齢制限チェック
  $isFree = ($order['amount'] ?? 0) == 0 || empty($order['currency']);

  if ($age < 18 && !$isFree) {
      // 18歳未満で有料商品の場合はエラー
      throw new GameException(ErrorCode::WEBSTORE_PURCHASE_NOT_ALLOWED_UNDER_18);
  }

  // 無料アイテムの場合は年齢に関わらずOK
  ```

**サーバー実装への影響:**
- 年齢制限チェックで無料アイテムを除外する処理を追加

**解決状況**: ✅ 完全解決（⚠️ 仮定）

---

**8-3: 子供アカウントの判定方法（海外）**

**回答内容:**
年齢のみで判定（14-17歳）。アカウント種別フラグは使用しない。

**詳細:**
- 「子供アカウント」= 14歳以上18歳未満
- 判定方法:
  ```php
  // W2（決済事前確認）での子供アカウント判定
  $country = $customParameters['country_from_ip'] ?? null;
  $isOverseas = $country && $country !== 'JP';

  if ($isOverseas) {
      if ($age < 14) {
          // 13歳以下はログイン不可（W1で400エラー）
          throw new GameException(ErrorCode::WEBSTORE_USER_TOO_YOUNG);
      }

      if ($age >= 14 && $age < 18) {
          // 14-17歳は子供アカウント
          $isFree = ($order['amount'] ?? 0) == 0 || empty($order['currency']);
          if (!$isFree) {
              // 有料商品は購入不可
              throw new GameException(ErrorCode::WEBSTORE_PURCHASE_NOT_ALLOWED_CHILD_ACCOUNT);
          }
      }
  }
  ```

**サーバー実装への影響:**
- 年齢による子供アカウント判定ロジックを実装
- 新しいエラーコード`WEBSTORE_PURCHASE_NOT_ALLOWED_CHILD_ACCOUNT`を定義

**解決状況**: ✅ 完全解決（⚠️ 仮定）

**⚠️ 注意**:
もしバンダイナムコIDに明示的な「子供アカウント」フラグがある場合は、そちらを優先して使用する実装に変更が必要です。

---

## 4. サーバー実装への総合的な影響

### 4.1. 新規テーブル

**注記:** 新規テーブルは不要。既存の`usr_store_products`および`usr_webstore_transactions`で管理。

### 4.2. 既存テーブルの変更

| テーブル名 | 変更内容 | 確認事項 |
|-----------|---------|---------|
| `usr_users` | `bn_country`カラムの存在確認 | ⚠️ 実テーブル確認が必要 |

### 4.3. 新規エラーコード

| エラーコード | HTTPステータス | 説明 |
|------------|---------------|------|
| `WEBSTORE_BIRTHDAY_REQUIRED` | 400 | 誕生日情報が未登録 |
| `WEBSTORE_PURCHASE_NOT_ALLOWED_CHILD_ACCOUNT` | 400 | 子供アカウント（海外）で有料商品を購入しようとした |

### 4.4. 環境変数

| 環境変数名 | 用途 | 例 |
|-----------|------|-----|
| `ADJUST_WEBSTORE_PURCHASE_TOKEN` | Adjustイベントトークン | `abc123xyz` |

---

## 5. 実装優先度と残存課題

### 5.1. 優先度マトリックス

| 質問 | 解決状況 | 実装優先度 | ブロッカー |
|-----|---------|-----------|-----------|
| Q1 | ✅ 解決済み | 高 | ⚠️ `usr_users.birthday`の確認が必要 |
| Q2 | ✅ 解決済み | 高 | なし |
| Q3 | ✅ 解決済み | 中 | なし |
| Q4 | ✅ 解決済み | 中 | なし |
| Q5 | ✅ 解決済み | 高 | なし |
| Q6 | ✅ 解決済み | 中 | ⚠️ `AdjustService`の確認が必要 |
| Q7 | ✅ 解決済み | 高 | ⚠️ `usr_users.bn_country`の確認が必要 |
| Q8 | ✅ 解決済み | 低 | なし |

### 5.2. 実装前に確認が必要な項目

#### ⚠️ ブロッカー確認事項:

1. **`usr_users.birthday`カラムの存在確認**
   - 確認方法: テーブル定義を確認
   - 存在しない場合: マイグレーションでカラム追加

2. **`usr_users.bn_country`カラムの存在確認**
   - 確認方法: テーブル定義を確認
   - 存在しない場合: マイグレーションでカラム追加、またはバンダイナムコID APIから取得

3. **`AdjustService`の実装確認**
   - 確認方法: コードベース調査
   - 存在しない場合: 新規実装、またはMVPから除外

---

## 6. 次のステップ

### 6.1. 実際のプランナー確認への移行

本ドキュメントの内容を基に、以下のアクションを実施してください:

1. **プランナーへの確認メール/ミーティングの設定**
   - 本ドキュメントの仮定内容を提示
   - 各仮定が妥当かどうかを確認
   - 相違がある場合は修正

2. **確認結果の反映**
   - プランナーからの回答を本ドキュメントに反映
   - 「⚠️ 仮定」マークを削除
   - 実際の回答に基づいて実装方針を更新

3. **ブロッカー確認事項の解消**
   - `usr_users.birthday`カラムの存在確認
   - `usr_users.bn_country`カラムの存在確認
   - `AdjustService`の実装確認

### 6.2. Stage 5への進行条件

以下の条件をすべて満たした場合、Stage 5「API設計書作成」に進むことができます:

- [ ] すべての仮定がプランナー確認で検証されている
- [ ] ブロッカー確認事項（`birthday`、`bn_country`、`AdjustService`）が解消されている
- [ ] 新規テーブル設計が確定している
- [ ] エラーコードが確定している

---

## 7. まとめ

### 7.1. 確認結果の総評

**⚠️ 本版は仮定による暫定版です**

- すべての質問に対して技術的に妥当な仮定を設定しました
- 実装の方向性は明確になりましたが、実際のプランナー確認が必須です
- ブロッカー確認事項（3件）の解消が最優先です

### 7.2. リスク評価

| リスク | 深刻度 | 対応策 |
|-------|--------|--------|
| 仮定が実際の仕様と異なる | 高 | プランナー確認の早期実施 |
| `birthday`カラムが存在しない | 中 | テーブル定義確認 + マイグレーション |
| `bn_country`カラムが存在しない | 中 | テーブル定義確認 + API実装 |
| `AdjustService`が存在しない | 低 | MVPから除外も可 |

### 7.3. 開発着手の判断

**現時点での判断**: ⚠️ 仮定による着手は可能だが、プランナー確認を並行実施すべき

**推奨アクション**:
1. ブロッカー確認事項（3件）の即時確認
2. プランナーへの確認依頼（本ドキュメントを共有）
3. 確認結果の待機中に、以下の作業を並行実施:
   - テーブル設計のドラフト作成
   - エラーコードの定義
   - ログ設計

---

**最終更新**: 2025-12-02
**次回更新**: プランナー確認完了後
