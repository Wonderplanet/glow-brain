# サーバー要件（コード調査による追加・補足） - 交換所機能

**機能名**: 交換所の実装
**バージョン**: v.1.4.0
**調査日**: 2025-11-26

---

## はじめに

本ドキュメントは、`サーバー要件抽出.md`で仕様書から抽出した要件に加えて、既存コードベースの調査により判明した追加要件・制約・前提条件を整理したものです。

実装方式を決定するのではなく、**サーバー側で考慮すべき事項を要件レベルで整理**することを目的としています。

---

## 調査対象の既存実装

以下の既存機能の実装を調査し、交換所機能に適用可能なパターンと制約を抽出しました。

- **Shop機能**: `ShopTradeShopItemUseCase`, `ShopService`, `UsrShopItem`, `UsrItemTrade`
- **Item機能**: `ItemService`, `UsrItemService`, アイテム交換処理（キャラのかけら⇔選択かけらBOX）
- **Reward機能**: `RewardDelegator`, `RewardSendService`, 各種SendService（Coin, Item, Unit等）
- **データベース**: `usr_shop_items`, `usr_item_trades`, `log_trade_shop_items`
- **スキーマ定義**: `Shop.yml`, `Item.yml`

---

## サーバー要件一覧（コード調査による追加・補足）

### 要件C-1: 交換履歴の二重管理（trade_count と trade_total_count）
- **種別**: コードから判明した追加要件
- **関連機能**: 交換所全般、交換回数制限
- **関連ファイル**:
  - `api/app/Domain/Shop/Models/UsrShopItem.php` の `trade_count`, `trade_total_count`
  - `api/database/usr.usr_shop_items` テーブル定義
- **内容の要約**:
  - ユーザーの交換履歴は、リセット可能な`trade_count`と、リセット不可能な通算`trade_total_count`の2つのカウンタで管理される
- **詳細**:
  - 既存のShop機能では、`usr_shop_items`テーブルに`trade_count`（リセット対象）と`trade_total_count`（通算、リセット対象外）の2つのカラムが存在する
  - デイリー・ウィークリー・マンスリーのリセットが発生する際は`trade_count`のみがリセットされ、`trade_total_count`は継続してカウントアップされる
  - これにより、「今月の交換回数」と「累計交換回数」の両方を管理できる
  - 交換所機能でも同様に、リセット可能な回数と通算回数の両方を管理する必要がある
- **元になったコードの抜粋**:
  ```php
  // UsrShopItem.php
  public function incrementTradeCount(): void
  {
      $this->trade_count++;
      $this->trade_total_count++;
  }

  public function reset(CarbonImmutable $now): void
  {
      $this->trade_count = 0;
      $this->last_reset_at = $now->format('Y-m-d H:i:s');
  }
  ```
- **備考**:
  - 仕様書には「交換回数のリセット」の記載はあるが、通算回数の管理については明示されていない
  - ログ分析や運用分析のために通算回数を記録するのが既存パターン

---

### 要件C-2: リセットタイミングの判定はClock機能を利用
- **種別**: コードから判明した追加要件
- **関連機能**: 交換所リセット処理（毎月初日04:00のリセット等）
- **関連ファイル**:
  - `api/app/Domain/Shop/Services/ShopService.php` の `resetUsrShopItem`
  - `api/app/Domain/Common/Entities/Clock.php` の `isFirstToday`, `isFirstWeek`, `isFirstMonth`
- **内容の要約**:
  - 日次・週次・月次のリセット判定は、Clockクラスの専用メソッド（`isFirstToday`, `isFirstWeek`, `isFirstMonth`）を使用する
- **詳細**:
  - 既存のShop機能では、リセットタイミングの判定に`Clock`クラスの`isFirstToday()`などのメソッドを使用している
  - これらのメソッドは、前回のリセット日時（`last_reset_at`）と現在時刻を比較し、日・週・月の境界を跨いだかを判定する
  - 日次リセット（Daily）、週次リセット（Weekly）、月次リセット（Monthly）の3パターンがサポートされている
  - 通常交換所の「毎月初日04:00リセット」は、MonthlyリセットとClockの基準時刻（04:00）を組み合わせて実現する
- **元になったコードの抜粋**:
  ```php
  // ShopService.php
  public function resetUsrShopItem(
      UsrShopItemInterface $usrShopItem,
      MstShopItemEntity $mstShopItem,
      CarbonImmutable $now
  ): bool {
      $shopType = $mstShopItem->getShopType();
      if ($shopType === ShopType::DAILY->value) {
          if ($this->clock->isFirstToday($usrShopItem->getLastResetAt())) {
              $usrShopItem->reset($now);
              return true;
          }
      } elseif ($shopType === ShopType::WEEKLY->value) {
          if ($this->clock->isFirstWeek($usrShopItem->getLastResetAt())) {
              $usrShopItem->reset($now);
              return true;
          }
      }
      return false;
  }
  ```
- **備考**:
  - 仕様書には「毎月初日04:00にリセット」と記載されているが、実装レベルでは既存のClock機能を利用する前提がある

---

### 要件C-3: 交換実行はトランザクション内で原子性を保証
- **種別**: コードから判明した追加要件
- **関連機能**: 交換実行処理、リソース消費と報酬付与
- **関連ファイル**:
  - `api/app/Domain/Shop/UseCases/ShopTradeShopItemUseCase.php` の `applyUserTransactionChanges`
- **内容の要約**:
  - 交換処理（コスト消費＋報酬付与）は、`applyUserTransactionChanges`メソッド内でトランザクション処理される
- **詳細**:
  - 既存のShop交換処理では、`UseCaseTrait::applyUserTransactionChanges()`メソッドを使用してトランザクション処理を実施している
  - このメソッド内で、リソースの消費（`consumeCost`）と報酬の配布（`rewardDelegator->sendRewards`）が実行される
  - トランザクション内で例外が発生した場合、すべての変更がロールバックされる
  - 交換回数のインクリメントは、トランザクション外で先に実行され、トランザクション内で消費・報酬処理が行われる
- **元になったコードの抜粋**:
  ```php
  // ShopTradeShopItemUseCase.php
  $this->applyUserTransactionChanges(function () use (
      $usrUserId,
      $mstShopItem,
      $usrShopItem,
      $platform,
      $billingPlatform,
      $now,
  ) {
      // コスト消費
      $this->shopService->consumeCost(
          $usrUserId,
          $usrShopItem->getTradeCount(),
          $mstShopItem,
          $platform,
          $billingPlatform,
          $now,
      );

      // 報酬配布実行
      $this->rewardDelegator->sendRewards($usrUserId, $platform, $now);
  });
  ```
- **備考**:
  - 仕様書には「トランザクション処理」の明示的な記載はないが、ゲームサーバーの一般的な要求事項として原子性の保証が必要

---

### 要件C-4: 報酬付与はRewardDelegator経由で一元管理
- **種別**: コードから判明した追加要件
- **関連機能**: 報酬付与（アイテム、コイン、キャラ等）
- **関連ファイル**:
  - `api/app/Domain/Reward/Delegators/RewardDelegator.php`
  - `api/app/Domain/Reward/Services/RewardSendService.php`
  - 各種SendService（`CoinSendService`, `ItemSendService`, `UnitSendService`等）
- **内容の要約**:
  - 報酬の付与は、`RewardDelegator`を経由して実行され、報酬タイプごとに専用のSendServiceが呼び出される
- **詳細**:
  - 既存のShop機能では、交換物の付与に`RewardDelegator`を使用している
  - `RewardDelegator::addReward()`または`addRewards()`で報酬をリストに追加し、`RewardDelegator::sendRewards()`で一括配布を実行する
  - `RewardSendService`内で、報酬タイプ（Coin, Item, Unit, FreeDiamond, Stamina, Emblem, Exp）ごとに専用のSendServiceクラスが呼び出される
  - 各SendServiceは、リソースの加算、上限チェック、ログ出力、ミッション連携などを自動的に処理する
  - 交換所機能でも、同様に`RewardDelegator`を使用して報酬を付与する必要がある
- **元になったコードの抜粋**:
  ```php
  // ShopService.php
  // 交換物の付与
  $reward = new ShopItemReward(
      $resourceType,
      $mstShopItem->getResourceId(),
      $resourceAmount,
      $mstShopItem->getId(),
  );
  $this->rewardDelegator->addReward($reward);

  // UseCase内でトランザクション内実行
  $this->rewardDelegator->sendRewards($usrUserId, $platform, $now);
  ```
- **備考**:
  - 仕様書には「報酬の付与」としか記載されていないが、実装レベルでは既存のReward基盤を使用する前提がある

---

### 要件C-5: 交換コストの種別（CostType）は既存パターンを踏襲
- **種別**: コードから判明した追加要件
- **関連機能**: 交換コスト消費処理
- **関連ファイル**:
  - `api/app/Domain/Shop/Enums/ShopItemCostType.php`
  - `api/app/Domain/Shop/Services/ShopService.php` の `consumeCost`
  - `glow-schema/Schema/Shop.yml` のCostType定義
- **内容の要約**:
  - 交換に必要なコストは、既存のCostType（Coin, Diamond, PaidDiamond, Item, Ad, Free）のいずれかを使用する
- **詳細**:
  - 既存のShop機能では、`ShopItemCostType` enumに以下のコストタイプが定義されている:
    - `Coin`: 二次通貨（ゲーム内コイン）
    - `Diamond`: 一次通貨（無償ダイヤ→有償ダイヤの順で消費）
    - `PaidDiamond`: 有償一次通貨のみ
    - `Ad`: 広告視聴（コスト消費なし、ミッショントリガー送信）
    - `Free`: 無料（コスト消費なし）
  - 仕様書では「アイテム、リソース、専用通貨」と記載されているが、実装では`Item`タイプも存在する（ただし現状のShopItemではサポートされていない）
  - 交換所でアイテムをコストとする場合、ItemタイプのCostTypeをサポートするか、別の実装パターンが必要
- **元になったコードの抜粋**:
  ```php
  // ShopItemCostType.php
  enum ShopItemCostType: string
  {
      case COIN = 'Coin';
      case PAID_DIAMOND = 'PaidDiamond';
      case DIAMOND = 'Diamond';
      case AD = 'Ad';
      case FREE = 'Free';
  }

  // ShopService.php consumeCost()
  if ($costType === ShopItemCostType::COIN->value) {
      $this->userDelegator->consumeCoin(...);
  } elseif ($costType === ShopItemCostType::PAID_DIAMOND->value) {
      $this->appCurrencyDelegator->consumePaidDiamond(...);
  } // ...
  ```
- **備考**:
  - 仕様書では「アイテムID」「リソースID」を必要コストとして指定する記載があるが、既存のShopItemCostTypeにはItem消費の直接サポートがない
  - アイテムを消費する場合、ItemService経由で消費するか、新たにItemタイプのCostTypeをサポートする必要がある

---

### 要件C-6: アイテム消費はUsrItemServiceを経由
- **種別**: コードから判明した追加要件
- **関連機能**: アイテムをコストとする交換
- **関連ファイル**:
  - `api/app/Domain/Item/Services/UsrItemService.php` の `consumeItem`
  - `api/app/Domain/Item/Services/ItemService.php` の `apply`, `applyCharacterFragment`
- **内容の要約**:
  - アイテムを消費する場合、`UsrItemService::consumeItem()`を使用し、所持数チェックとログ出力が自動的に実行される
- **詳細**:
  - 既存のItem交換機能（キャラのかけら→選択かけらBOX）では、`UsrItemService::consumeItem()`メソッドでアイテムを消費している
  - このメソッドは、ユーザーの所持数チェック、不足時のエラー（`LACK_OF_RESOURCES`）、ログ出力（`log_items`）を自動的に処理する
  - 交換所でアイテムをコストとする場合、同様に`UsrItemService::consumeItem()`を使用する必要がある
- **元になったコードの抜粋**:
  ```php
  // ItemService.php
  // コストの消費
  $this->usrItemService->consumeItem(
      $userId,
      $mstItem->getId(),
      $amount,
      new ItemFragmentBoxLogTrigger($mstItem),
  );
  ```
- **備考**:
  - 仕様書では「交換リソース」としてアイテムが記載されているが、実装レベルでは既存のUsrItemServiceを使用する前提がある

---

### 要件C-7: 交換上限数がNULLの場合は無制限として扱う
- **種別**: 仕様書要件の補足
- **関連機能**: 交換上限数のバリデーション
- **関連ファイル**:
  - `api/app/Domain/Shop/Services/ShopService.php` の `validateTradeCount`
- **内容の要約**:
  - 交換上限数（`tradable_count`）がNULLの場合、上限チェックをスキップし、無制限として扱う
- **詳細**:
  - 既存のShop機能では、`validateTradeCount()`メソッドで交換回数の上限チェックを実施している
  - `tradableCount`がNULLの場合、チェック処理を早期リターンし、無制限として扱う
  - 上限に達している場合は、`SHOP_TRADE_COUNT_LIMIT`エラーをスローする
- **元になったコードの抜粋**:
  ```php
  // ShopService.php
  public function validateTradeCount(?int $tradableCount, int $tradeCount): void
  {
      if (is_null($tradableCount)) {
          // 交換回数無制限
          return;
      }

      if ($tradableCount <= $tradeCount) {
          // 交換上限に達している
          throw new GameException(
              ErrorCode::SHOP_TRADE_COUNT_LIMIT,
              "The trade limit has been reached. (tradable: $tradableCount trade: $tradeCount)"
          );
      }
  }
  ```
- **備考**:
  - 仕様書では「NULLまたは未設定の場合は無制限」と記載されており、コードでも同様のロジックが確認できた

---

### 要件C-8: 交換ログの保存（log_trade_shop_items相当）
- **種別**: コードから判明した追加要件
- **関連機能**: 交換履歴のログ出力
- **関連ファイル**:
  - `api/app/Domain/Shop/Repositories/LogTradeShopItemRepository.php`
  - `api/database/migrations/2025_04_14_000001_create_log_trade_shop_items_table.php`
  - `api/app/Domain/Shop/Services/ShopService.php` の `tradeShopItem`
- **内容の要約**:
  - 交換実行時には、交換ログ（ユーザーID、交換物ID、交換回数、コストタイプ、コスト数、実際に受け取った報酬）を`log_trade_shop_items`相当のテーブルに保存する
- **詳細**:
  - 既存のShop機能では、交換実行時に`LogTradeShopItemRepository::create()`で交換ログを保存している
  - ログには以下の情報が含まれる:
    - `usr_user_id`: ユーザーID
    - `mst_shop_item_id`: 交換物のマスタID
    - `trade_count`: 交換回数（何回目の交換か）
    - `cost_type`: 消費したコストタイプ
    - `cost_amount`: 消費したコスト数
    - `received_reward`: 実際にユーザーが受け取った報酬情報（JSON）
  - `received_reward`には、RewardDelegatorから取得した実際の配布済み報酬情報が格納される
  - 交換所機能でも、同様にログテーブルを作成し、交換履歴を記録する必要がある
- **元になったコードの抜粋**:
  ```php
  // ShopService.php
  // 交換ログの保存
  $this->logTradeShopItemRepository->create(
      $user->id,
      $mstShopItem->getId(),
      $usrShopItem->getTradeCount(),
      $mstShopItem->getCostType(),
      $mstShopItem->getCostAmount(),
      $this->rewardDelegator->getSentRewards(ShopItemReward::class),
  );
  ```
- **備考**:
  - 仕様書にはログ出力に関する記載がないが、運用上の分析・トラブルシューティングのためにログ出力は必須

---

### 要件C-9: 初回無料フラグ（is_first_time_free）のサポート
- **種別**: コードから判明した追加要件
- **関連機能**: 交換コスト制御
- **関連ファイル**:
  - `api/app/Domain/Shop/Services/ShopService.php` の `consumeCost`
  - `api/database/mst.mst_shop_items` の`is_first_time_free`カラム
- **内容の要約**:
  - マスタに`is_first_time_free`フラグがあり、trueの場合、初回交換時（trade_count = 1）はコスト消費をスキップする
- **詳細**:
  - 既存のShop機能では、`is_first_time_free`フラグがtrueで、かつ`trade_count === 1`（初回交換）の場合、コスト消費処理をスキップする
  - 2回目以降の交換では通常通りコストが消費される
  - 交換所機能でも、初回無料の仕組みを実装する場合、同様のフラグとロジックが必要
- **元になったコードの抜粋**:
  ```php
  // ShopService.php
  public function consumeCost(...) {
      if ($tradeCount === 1 && $mstShopItem->isFirstTimeFree()) {
          // 初回無料の場合はコスト消費なし
          return;
      }
      // 通常のコスト消費処理
  }
  ```
- **備考**:
  - 仕様書には初回無料に関する記載がないが、既存のShop機能と同様の仕組みを適用できる

---

### 要件C-10: 開催期間のバリデーション（start_date, end_date）
- **種別**: 仕様書要件の補足
- **関連機能**: 交換所・ラインナップの開催期間チェック
- **関連ファイル**:
  - `api/app/Domain/Resource/Mst/Repositories/MstShopItemRepository.php` の `getActiveShopItemById`
  - `api/database/mst.mst_shop_items` の`start_date`, `end_date`カラム
- **内容の要約**:
  - 交換所やラインナップには`start_date`と`end_date`が設定され、現在時刻がこの範囲内かをチェックする必要がある
- **詳細**:
  - 既存のShop機能では、`MstShopItemRepository::getActiveShopItemById()`などのメソッドで、現在時刻が`start_date`と`end_date`の範囲内かをチェックしている
  - 範囲外の場合は、マスタが見つからない（`MST_NOT_FOUND`）として扱われる
  - 交換所機能でも、交換所自体とラインナップアイテムの両方で開催期間チェックが必要
- **備考**:
  - 仕様書には「開催期間」「交換期間」の記載があり、コードレベルでも同様のチェックが必要

---

### 要件C-11: リソース不足時のエラーコード（LACK_OF_RESOURCES）
- **種別**: コードから判明した追加要件
- **関連機能**: コスト消費時のバリデーション
- **関連ファイル**:
  - `api/app/Domain/Common/Constants/ErrorCode.php` の `LACK_OF_RESOURCES`
  - `api/app/Domain/User/Delegators/UserDelegator.php` の `consumeCoin`
  - `api/app/Domain/Item/Services/UsrItemService.php` の `consumeItem`
- **内容の要約**:
  - リソース（コイン、アイテム等）が不足している場合、`LACK_OF_RESOURCES`エラーコードをスローする
- **詳細**:
  - 既存のリソース消費処理（`consumeCoin`, `consumeItem`等）では、所持数が不足している場合に`GameException`を`LACK_OF_RESOURCES`エラーコードでスローする
  - クライアント側では、このエラーコードを受け取って不足ダイアログ等を表示する
  - 交換所機能でも、同様にリソース不足時は`LACK_OF_RESOURCES`エラーを返す必要がある
- **備考**:
  - 仕様書には「リソース不足時の表示制御」の記載があるが、サーバー側のエラーコードは既存パターンを踏襲する

---

### 要件C-12: まとめて交換時の個数検証（最小1個〜最大上限）
- **種別**: 仕様書要件の補足
- **関連機能**: まとめて交換機能
- **関連ファイル**:
  - （既存コードでは単一交換のみのため、実装例はなし）
- **内容の要約**:
  - まとめて交換の際、交換個数は最小1個、最大は「交換上限数 - 既交換数」と「所持リソース / 必要リソース」の小さい方となる
- **詳細**:
  - 仕様書では「±1、±10、最大、最小で変更できる」とあるが、実際の交換可能数の上限は以下の条件で制限される:
    - 交換上限数の残数（`tradable_count - trade_count`）
    - 所持リソース数から計算可能な交換回数（`所持数 / 必要リソース数`）
  - 既存のShop機能では単一交換のみのため、まとめて交換の実装例はない
  - 交換所機能では、クライアントから交換個数を受け取り、上記の条件を満たすかバリデーションする必要がある
- **備考**:
  - 仕様書には「まとめて交換」の記載があるが、具体的なバリデーションロジックは実装時に定義する必要がある

---

### 要件C-13: UsrModelManagerによるキャッシュ管理
- **種別**: コードから判明した追加要件
- **関連機能**: ユーザーデータのキャッシュ管理
- **関連ファイル**:
  - `api/app/Domain/Shop/Models/UsrShopItem.php` の `makeModelKey`
  - `api/app/Domain/Item/Models/UsrItemTrade.php` の `makeModelKey`
- **内容の要約**:
  - ユーザーの交換履歴データは、UsrModelManagerによってキャッシュ管理され、`makeModelKey()`でユニークキーを生成する
- **詳細**:
  - 既存のShop・Item機能では、`UsrShopItem`や`UsrItemTrade`などのユーザーデータは、`UsrEloquentModel`を継承し、`makeModelKey()`メソッドでキャッシュキーを生成する
  - キャッシュキーは、通常`usr_user_id`と主キーの組み合わせ（例: `{usr_user_id}{mst_shop_item_id}`）で構成される
  - 交換所機能でも、ユーザー交換履歴を管理するテーブルには同様のキャッシュ機構を実装する必要がある
- **元になったコードの抜粋**:
  ```php
  // UsrShopItem.php
  public function makeModelKey(): string
  {
      // UsrModelManagerのキャッシュ管理キーで、DBスキーマのユニークキーを使う
      return $this->usr_user_id . $this->mst_shop_item_id;
  }
  ```
- **備考**:
  - 仕様書にはキャッシュに関する記載はないが、パフォーマンス要件として既存のキャッシュ機構を踏襲する必要がある

---

### 要件C-14: 交換リセット方式の種別（ItemTradeResetType）
- **種別**: コードから判明した追加要件
- **関連機能**: 交換回数のリセット方式
- **関連ファイル**:
  - `api/app/Domain/Item/Enums/ItemTradeResetType.php`
  - `api/app/Domain/Item/Services/ItemService.php` の `resetUsrItemTrade`
  - `glow-schema/Schema/Item.yml` のItemTradeResetType定義
- **内容の要約**:
  - 交換回数のリセット方式は、None（リセットなし）、Daily、Weekly、Monthlyの4パターンがある
- **詳細**:
  - 既存のItem交換機能（キャラのかけら→選択かけらBOX）では、`MstItemRarityTrade`テーブルに`reset_type`カラムがあり、リセット方式を指定している
  - `ItemTradeResetType` enumには以下の値が定義されている:
    - `None`: リセットなし（上限は永続的）
    - `Daily`: 日次リセット
    - `Weekly`: 週次リセット
    - `Monthly`: 月次リセット
  - 交換所機能でも、ラインナップごとにリセット方式を指定できるようにする場合、同様のenum定義が必要
- **元になったコードの抜粋**:
  ```php
  // ItemTradeResetType.php
  enum ItemTradeResetType: string
  {
      case NONE = 'None';
      case DAILY = 'Daily';
      case WEEKLY = 'Weekly';
      case MONTHLY = 'Monthly';
  }

  // ItemService.php
  $needReset = match ($mstItemRarityTrade->getResetTypeEnum()) {
      ItemTradeResetType::DAILY => $this->clock->isFirstToday($beforeResetAt),
      ItemTradeResetType::WEEKLY => $this->clock->isFirstWeek($beforeResetAt),
      ItemTradeResetType::MONTHLY => $this->clock->isFirstMonth($beforeResetAt),
      default => false,
  };
  ```
- **備考**:
  - 仕様書では「通常交換所は毎月初日04:00にリセット」とあるが、リセット方式をマスタで柔軟に設定できる仕組みがある

---

### 要件C-15: 報酬の変換処理（アイテムの所持上限等）
- **種別**: コードから判明した追加要件
- **関連機能**: 報酬付与時の上限チェックと変換
- **関連ファイル**:
  - `api/app/Domain/Reward/Services/RewardSendService.php` の `execSendRewards`
  - 各種SendService（例: `ItemSendService`, `UnitSendService`）
- **内容の要約**:
  - 報酬付与時、各リソースの所持上限チェックや変換処理（アイテム上限超過時のコイン変換等）が自動的に実行される
- **詳細**:
  - `RewardSendService`では、報酬タイプごとに専用のSendServiceが呼び出され、以下のような処理が行われる:
    - アイテムの所持上限チェック（上限超過時はコイン等に変換）
    - ユニットの所持チェック（既に所持している場合はかけらに変換）
    - コインの所持上限チェック
  - 変換処理の結果、実際にユーザーが受け取った報酬は、`RewardSendSummary`や`RewardSent`として記録される
  - 交換所機能でも、報酬付与時に同様の変換処理が自動的に適用される
- **備考**:
  - 仕様書には報酬の変換処理に関する記載はないが、既存のReward基盤を使用することで自動的に処理される

---

### 要件C-16: ミッション連携（アイテム取得、交換実行等）
- **種別**: コードから判明した追加要件
- **関連機能**: ミッションの進捗更新
- **関連ファイル**:
  - （各SendServiceやItemServiceでミッショントリガーが送信される）
- **内容の要約**:
  - アイテム取得、交換実行などの行動は、ミッションシステムへのトリガー送信が必要
- **詳細**:
  - 既存のShop・Item機能では、報酬付与時や交換実行時に、ミッションシステムへのトリガーが自動的に送信される
  - 例えば、アイテムを取得するとItemSendServiceがミッショントリガーを送信し、ミッション進捗が更新される
  - 交換所機能でも、交換実行時に適切なミッショントリガーを送信する必要がある（例: 「交換所で〇回交換した」というミッション）
- **備考**:
  - 仕様書にはミッション連携に関する記載はないが、ゲーム全体の設計として既存機能との連携が必要

---

### 要件C-17: 原画アイテムの特別処理（16ピース完成状態）
- **種別**: 仕様書要件の補足
- **関連機能**: 原画アイテムの交換
- **関連ファイル**:
  - （既存コードでは原画の特別処理の実装例は見つからず）
- **内容の要約**:
  - 原画を交換所で交換する場合、16ピース分の完成状態として付与する必要がある
- **詳細**:
  - 仕様書では「原画を交換すると、既存の原画のかけら演出がかけら16ピース分再生される」とあるが、既存コードでは原画の特別処理の実装例が見つからなかった
  - 原画アイテムには特別なフラグやタイプが必要で、交換時に16個分として扱うロジックを実装する必要がある
  - または、マスタの`resource_amount`を16に設定することで対応する可能性がある
- **備考**:
  - 仕様書には原画の特別処理が記載されているが、既存実装との整合性を確認する必要がある

---

### 要件C-18: アイテムのタブ分類（ItemGroupType）
- **種別**: 仕様書要件の補足
- **関連機能**: アイテムBOXのタブ分類
- **関連ファイル**:
  - `glow-schema/Schema/Item.yml` のItemGroupType定義
  - `api/app/Domain/Item/Enums/ItemType.php`
- **内容の要約**:
  - アイテムには`group_type`（Consumable, Etc）があり、タブ分類の基準となる
- **詳細**:
  - glow-schemaのItem.ymlでは、`ItemGroupType` enumに`Consumable`と`Etc`が定義されている
  - 仕様書では「消費タブ」「強化タブ」「かけらタブ」の3種類が記載されているが、既存のItemGroupTypeは2種類のみ
  - タブ分類の実装方法については、ItemTypeとItemGroupTypeの組み合わせ、または新たなenum定義が必要
- **備考**:
  - 仕様書のタブ分類と既存のItemGroupTypeの定義にギャップがあり、実装時に整合性を取る必要がある

---

### 要件C-19: 売却機能の法務的制約（消費タブは売却不可）
- **種別**: 仕様書要件の補足
- **関連機能**: アイテムBOXの売却機能
- **関連ファイル**:
  - （既存コードでは売却機能の実装例は見つからず）
- **内容の要約**:
  - 消費タブのアイテムは、法務的な理由（二次通貨扱い）により売却機能を提供してはならない
- **詳細**:
  - 仕様書では「消費タブに売却機能がないのは、複数役務を持った二次通貨扱いとなり、法務NGとなってしまう懸念」と記載されている
  - 売却機能を実装する場合、アイテムのタブ種別またはタイプに基づいて売却可否をチェックする必要がある
  - 既存コードでは売却機能の実装例が見つからなかったため、新規実装が必要
- **備考**:
  - 仕様書には法務的な制約が明記されており、実装時に厳守する必要がある

---

### 要件C-20: エラーコードの統一（交換所専用エラー）
- **種別**: コードから判明した追加要件
- **関連機能**: エラーハンドリング
- **関連ファイル**:
  - `api/app/Domain/Common/Constants/ErrorCode.php` のShop関連エラー（200番台）
- **内容の要約**:
  - 交換所機能でも、既存のShopエラーコード体系に従い、新たなエラーコード（200番台）を追加する
- **詳細**:
  - 既存のShop機能では、以下のエラーコードが200番台で定義されている:
    - `SHOP_TRADE_COUNT_LIMIT (202)`: 購入上限到達
    - `SHOP_CONDITION_PACK_NOT_RELEASED (203)`: 未開放の条件パック
    - `SHOP_CONDITION_PACK_EXPIRED (204)`: 期限切れの条件パック
    - `SHOP_PASS_NOT_EXPIRED (205)`: 有効期限内のパス
  - 交換所機能でも、同様に200番台で新たなエラーコードを定義する（例: `EXCHANGE_SHOP_NOT_FOUND`, `EXCHANGE_LINEUP_EXPIRED`等）
- **備考**:
  - 仕様書にはエラーコードの記載はないが、既存のエラーコード体系に従う必要がある

---

## 追加要件のカテゴリ別整理

### データ管理
- **C-1**: 交換履歴の二重管理（trade_count と trade_total_count）
- **C-13**: UsrModelManagerによるキャッシュ管理

### リセット・期間管理
- **C-2**: リセットタイミングの判定はClock機能を利用
- **C-10**: 開催期間のバリデーション（start_date, end_date）
- **C-14**: 交換リセット方式の種別（ItemTradeResetType）

### トランザクション・報酬処理
- **C-3**: 交換実行はトランザクション内で原子性を保証
- **C-4**: 報酬付与はRewardDelegator経由で一元管理
- **C-15**: 報酬の変換処理（アイテムの所持上限等）

### コスト消費
- **C-5**: 交換コストの種別（CostType）は既存パターンを踏襲
- **C-6**: アイテム消費はUsrItemServiceを経由
- **C-9**: 初回無料フラグ（is_first_time_free）のサポート

### バリデーション
- **C-7**: 交換上限数がNULLの場合は無制限として扱う
- **C-11**: リソース不足時のエラーコード（LACK_OF_RESOURCES）
- **C-12**: まとめて交換時の個数検証（最小1個〜最大上限）
- **C-20**: エラーコードの統一（交換所専用エラー）

### ログ・監査
- **C-8**: 交換ログの保存（log_trade_shop_items相当）

### 既存機能連携
- **C-16**: ミッション連携（アイテム取得、交換実行等）

### 特殊処理
- **C-17**: 原画アイテムの特別処理（16ピース完成状態）
- **C-18**: アイテムのタブ分類（ItemGroupType）
- **C-19**: 売却機能の法務的制約（消費タブは売却不可）

---

## 実装時の注意点

1. **既存基盤の活用**
   - RewardDelegator、UsrItemService、Clock等の既存基盤を最大限活用する
   - 独自実装ではなく、既存パターンを踏襲することでコードの一貫性を保つ

2. **トランザクション処理の徹底**
   - 交換処理は必ず`applyUserTransactionChanges`内で実行し、原子性を保証する
   - コスト消費と報酬付与は同一トランザクション内で完結させる

3. **ログ出力の漏れ防止**
   - 交換実行時の詳細ログ（log_trade_xxx）は運用上必須
   - RewardSendServiceで自動出力されるログ（log_items, log_coin等）も活用する

4. **エラーハンドリングの統一**
   - 既存のエラーコード体系（200番台: Shop関連）に従う
   - リソース不足、上限到達等の共通エラーは既存のエラーコードを使用する

5. **パフォーマンス考慮**
   - UsrModelManagerのキャッシュ機構を適切に実装する
   - リセット処理は毎回DBアクセスせず、キャッシュ上で判定する

6. **法務的制約の遵守**
   - 消費タブのアイテム売却は法務NGのため実装しない
   - 複数役務を持つアイテムの扱いには注意が必要

---

## 未確認事項・今後の調査課題

1. **原画アイテムの実装方法**
   - 既存コードで原画の16ピース処理の実装例が見つからなかった
   - 原画アイテムのタイプ定義やフラグの有無を確認する必要がある

2. **アイテムをコストとする交換の実装方法**
   - 既存のShopItemCostTypeにはItemタイプがあるが、実装例がない
   - ItemService経由でアイテムを消費する場合の統合方法を検討する必要がある

3. **アイテムBOXのタブ分類の実装方法**
   - 仕様書の3タブ分類と既存のItemGroupType（2種類）の整合性
   - 新たなenum定義が必要かどうかを検討する必要がある

4. **売却機能の実装有無**
   - 既存コードで売却機能の実装例が見つからなかった
   - 交換所機能で売却機能を実装するかどうかを確認する必要がある

---

## 参考: 既存実装との対応表

| 交換所の概念 | 既存のShop機能での対応 | 備考 |
|------------|---------------------|------|
| 交換所 | Shop（Daily, Weekly, Coin） | ShopTypeで種別管理 |
| 交換所ラインナップ | MstShopItem | 1つのShopItemが1つのラインナップに相当 |
| ユーザー交換履歴 | UsrShopItem | trade_count, trade_total_count, last_reset_at |
| 交換ログ | LogTradeShopItem | 交換実行時の詳細ログ |
| 交換コスト | ShopItemCostType | Coin, Diamond, PaidDiamond, Ad, Free |
| 交換報酬 | ShopItemReward | RewardDelegator経由で配布 |
| 交換上限 | tradable_count | NULLは無制限 |
| リセット方式 | ShopType（Daily, Weekly） + Clock | ItemTradeResetTypeも参考 |

---

## まとめ

コード調査により、交換所機能の実装において考慮すべき追加要件・制約が明らかになりました。

特に重要な点は以下の通りです:

- **既存基盤の活用**: RewardDelegator, UsrItemService, Clock等の既存機構を最大限活用する
- **トランザクション処理**: 交換処理の原子性を保証するため、既存のUseCaseパターンを踏襲する
- **ログ出力**: 運用・分析のため、交換履歴ログを必ず出力する
- **エラーハンドリング**: 既存のエラーコード体系に従い、統一されたエラー処理を実装する
- **法務的制約**: 消費タブのアイテム売却は法務NGのため実装しない

これらの要件を踏まえ、次のステージ（API設計、テーブル設計等）で具体的な実装方針を決定していきます。
