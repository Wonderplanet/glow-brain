# サーバーAPI要件書 - 交換所機能

## 1. ドキュメント情報
- **対象機能:** 交換所の実装
- **バージョン:** v.1.4.0
- **作成日:** 2025-11-26
- **参照ドキュメント:**
  - サーバー要件抽出.md
  - サーバー要件_コード調査追記.md
  - 03_サーバー仕様レビュー.md
  - 04_ゲーム体験仕様確認結果まとめ.md

---

## 2. 機能概要

### 2.1 ユーザーに提供するゲーム体験

交換所機能は、プレイヤーがゲーム内で獲得したアイテム、リソース、専用通貨を使用して、別のアイテムやキャラクター（またはそのピース）と交換できる機能です。

以下の3種類の交換所を提供します:

1. **通常交換所**
   - 恒常的に開催される交換所
   - 交換回数は毎月初日04:00に自動リセット
   - 継続的なプレイとリソース獲得の動機付け

2. **イベント交換所**
   - イベント開催期間に合わせた期間限定の交換所
   - イベント終了後すぐに非表示
   - 復刻時は新規交換所IDで管理

3. **キャラのかけらBOX交換所**
   - 既存のアイテムBOX内にあるキャラのかけら交換機能を移設
   - 無期限開催、リセットなし
   - キャラのかけらをかけらBOXに交換

### 2.2 サーバーAPIが果たす役割

- 交換所の開催期間管理とフィルタリング
- 交換ラインナップの期間管理と残り時間計算
- ユーザーごとの交換履歴管理と交換回数制御
- リソース消費と報酬付与のトランザクション処理
- 交換上限チェックとバリデーション
- まとめて交換の個数計算とバリデーション
- 原画アイテムの特別処理（原画+かけら16個の同時付与）
- 複数リソースを同時に消費する交換のサポート
- 交換履歴ログの記録

---

## 3. API要件一覧

### 3.1 交換所マスタデータ管理

#### 要件 REQ-MASTER-1: 交換所の種別管理
- **要件ID:** REQ-MASTER-1
- **概要:**
  - 交換所は3種類のカテゴリーに分類され、それぞれ異なる開催期間とリセット方式を持つ
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - Page 6: 交換所のカテゴリー（通常、イベント、キャラのかけらBOX）
  - APIで実現すべき内容:
    - 交換所マスタには以下の種別設定を管理:
      - **通常交換所**: 無期限開催、月次リセット（毎月初日04:00）
      - **イベント交換所**: イベント開催期間に準拠、リセットなし（復刻時は新規ID発行）
      - **キャラのかけらBOX交換所**: 無期限開催、リセットなし
- **既存実装との関連:**
  - Shop機能のShopType（Daily, Weekly, Coin）と類似
  - ItemTradeResetType（None, Daily, Weekly, Monthly）を参考
- **備考:**
  - プランナー確認結果（Q3）により、リセット処理はバッチではなくユーザーアクセス時判定で実装

---

#### 要件 REQ-MASTER-2: 交換所の開催期間管理
- **要件ID:** REQ-MASTER-2
- **概要:**
  - 交換所には開催期間（start_date, end_date）を設定し、開催期間外の交換所は非表示とする
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - Page 6: 交換所バナーの表示制御、開催期間の設定
  - APIで実現すべき内容:
    - 交換所マスタには`start_date`と`end_date`を設定
    - NULLの場合は無期限として扱う
    - 現在時刻が開催期間外の場合、交換所一覧取得APIで除外
    - 開催期間内の交換所のみをクライアントに返却
  - 条件・制約:
    - `start_date`が未到来の交換所は非表示
    - `end_date`が過去の交換所は非表示
    - イベント交換所は終了後すぐに非表示（猶予期間なし）
  - データ管理要件:
    - 交換所マスタに`start_date`, `end_date`カラムを保持
- **既存実装との関連:**
  - MstShopItemRepository::getActiveShopItemById()の開催期間チェックと同様
- **備考:**
  - プランナー確認結果（Q10）により、イベント交換所は終了後すぐ非表示と確定

---

#### 要件 REQ-MASTER-3: 交換所の残り時間計算
- **要件ID:** REQ-MASTER-3
- **概要:**
  - 交換所の残り時間を計算し、「dd日tt時間」または「期限なし」の形式で返却する
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - Page 6: 開催期間バナー表示「🕐マーク+期限なし」または「🕐マーク+残りdd日tt時間」
  - APIで実現すべき内容:
    - 無期限（end_date = NULL）の場合: 「期限なし」を返却
    - 期限あり（end_date設定済み）の場合: `end_date - 現在時刻`を計算し、「dd日tt時間」形式で返却
    - 日数は切り上げ、時間は切り捨て（例: 1日23時間30分 → 1日23時間）
  - 条件・制約:
    - 現在時刻がend_dateを過ぎている場合、交換所自体を非表示とするため、残り時間は計算不要
- **備考:**
  - 残り時間の表示形式はクライアント側で整形する想定だが、サーバーが計算したデータを返却

---

#### 要件 REQ-MASTER-4: 復刻時の交換所ID管理
- **要件ID:** REQ-MASTER-4
- **概要:**
  - イベント交換所を復刻する際、新規の交換所IDを発行し、過去の交換履歴と区別して管理する
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - Page 6: 復刻時は交換所IDを新規で切り直す
  - APIで実現すべき内容:
    - 復刻イベントでは、既存の交換所IDを再利用せず、新規の交換所IDを発行
    - 新規交換所IDに対応するユーザー交換履歴は新規作成される（交換回数0からスタート）
    - ラインナップは同じ内容を再設定する（新規ラインナップIDを作成する想定）
  - データ管理要件:
    - 復刻時のマスタデータ運用で対応するため、サーバー側でリセット処理を実装する必要はない
- **既存実装との関連:**
  - Shop機能でも交換所IDごとにユーザー交換履歴を管理するパターンと同様
- **備考:**
  - プランナー確認結果（Q8）により、実装でのリセット処理は不要、マスタデータ運用で対応と確定
  - 不明点: 復刻時のラインナップIDは既存を再利用か新規作成かが未確定（暫定的には新規作成で進める）

---

### 3.2 交換ラインナップ管理

#### 要件 REQ-LINEUP-1: ラインナップの詳細設定管理
- **要件ID:** REQ-LINEUP-1
- **概要:**
  - 各ラインナップには、報酬アイテム、必要リソース、交換期間、交換上限数を個別に設定可能
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - Page 7: ラインナップごとに設定可能な項目（アイテムID、数量、期間、上限数、必要リソース）
  - APIで実現すべき内容:
    - ラインナップマスタに以下の項目を設定:
      - ラインナップID（主キー）
      - 交換所ID（外部キー）
      - 報酬リソースタイプ（Item, Unit, Coin, Emblem, Prism等）
      - 報酬リソースID（アイテムID、キャラID等）
      - 報酬数量（1回の交換で付与される数）
      - 必要リソースタイプ（Item, Coin, Diamond等）
      - 必要リソースID（アイテムIDなど、Coinの場合はNULL）
      - 必要リソース数（1回の交換に必要な数）
      - 交換上限数（NULL時は無制限）
      - 交換期間開始日時（start_date、NULL時は無期限）
      - 交換期間終了日時（end_date、NULL時は無期限）
  - データ管理要件:
    - ラインナップマスタテーブルに上記カラムを保持
- **既存実装との関連:**
  - MstShopItemテーブルの構造と類似
- **備考:**
  - 複数リソース消費が必要な場合（プランナー確認結果Q1で実装必要と確定）、テーブル設計の拡張が必要

---

#### 要件 REQ-LINEUP-2: ラインナップの交換期間フィルタリング
- **要件ID:** REQ-LINEUP-2
- **概要:**
  - ラインナップの交換期間（start_date, end_date）をチェックし、期間外のラインナップは非表示とする
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - Page 7: 交換が開始日になっていないラインナップはラインナップ画面自体に表示されない
  - APIで実現すべき内容:
    - ラインナップ取得時、現在時刻が`start_date`〜`end_date`の範囲内のラインナップのみを返却
    - `start_date`が未到来のラインナップは除外
    - `end_date`が過去のラインナップは除外
    - 両方NULLの場合は常に表示対象
  - 条件・制約:
    - サーバー側で期間外のラインナップを除外し、クライアントに返却しない
- **既存実装との関連:**
  - MstShopItemRepository::getActiveShopItemById()と同様の期間チェック
- **備考:**
  - 交換所自体の開催期間とは独立して、ラインナップごとに個別の交換期間を持つ

---

#### 要件 REQ-LINEUP-3: ラインナップの残り時間計算
- **要件ID:** REQ-LINEUP-3
- **概要:**
  - ラインナップの交換期間の残り時間を計算し、「dd日tt時間」形式で返却する
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - Page 7: 交換が開始されたラインナップは「残り dd日tt時間」と表示
  - APIで実現すべき内容:
    - ラインナップの`end_date`と現在時刻を比較し、残り時間を計算
    - 「dd日tt時間」形式で返却
    - `end_date`がNULLの場合は無期限として扱う
- **備考:**
  - 残り時間の表示形式はクライアント側で整形する想定

---

#### 要件 REQ-LINEUP-4: NULL設定時の無期限・無制限制御
- **要件ID:** REQ-LINEUP-4
- **概要:**
  - 交換期限・交換上限数がNULLまたは未設定の場合、無期限・無制限として扱う
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - Page 7: 期限や上限数にNULL設定または設定値が存在しない場合は無期限、無制限
  - APIで実現すべき内容:
    - `end_date`がNULLの場合、交換期限チェックをスキップ（無期限）
    - `tradable_count`がNULLの場合、交換上限チェックをスキップ（無制限）
  - 条件・制約:
    - NULL判定は厳密に行う（0とNULLは区別）
- **既存実装との関連:**
  - ShopService::validateTradeCount()でNULL時は早期リターン
- **備考:**
  - コード調査（要件C-7）で既存実装パターンを確認済み

---

### 3.3 ユーザー交換履歴管理

#### 要件 REQ-HISTORY-1: 交換回数の二重管理
- **要件ID:** REQ-HISTORY-1
- **概要:**
  - ユーザーの交換履歴は、リセット可能な`trade_count`と、リセット不可能な通算`trade_total_count`の2つのカウンタで管理する
- **詳細仕様:**
  - コード調査追記の記載:
    - 要件C-1: trade_countとtrade_total_countの二重管理
  - APIで実現すべき内容:
    - ユーザー交換履歴テーブルに以下の2つのカラムを保持:
      - `trade_count`: 現在の交換期間内の交換回数（リセット対象）
      - `trade_total_count`: 通算交換回数（リセット対象外、永続）
    - 交換実行時、両カウンタを同時にインクリメント（+1）
    - リセット時、`trade_count`のみを0にリセット、`trade_total_count`は継続
  - データ管理要件:
    - ユーザー交換履歴テーブルに`trade_count`, `trade_total_count`, `last_reset_at`を保持
  - 検証・チェック要件:
    - 交換上限チェックは`trade_count`を使用
- **既存実装との関連:**
  - UsrShopItem::incrementTradeCount()と同様のロジック
- **備考:**
  - プランナー確認結果（Q2）により、`trade_total_count`はゲーム仕様として使用すると確定
  - クライアントへのレスポンスに`trade_total_count`を含める必要あり

---

#### 要件 REQ-HISTORY-2: リセットタイミングの判定
- **要件ID:** REQ-HISTORY-2
- **概要:**
  - 交換回数のリセット判定は、Clock機能のメソッド（isFirstMonth等）を使用する
- **詳細仕様:**
  - コード調査追記の記載:
    - 要件C-2: リセットタイミングの判定はClock機能を利用
  - APIで実現すべき内容:
    - ユーザーのアクセス時（交換所ラインナップ取得時、交換実行時）にリセット判定を実行
    - Clock機能の`isFirstMonth(last_reset_at)`メソッドを使用してリセット要否を判定
    - リセットが必要な場合、`trade_count`を0にリセットし、`last_reset_at`を現在時刻で更新
  - 条件・制約:
    - 通常交換所: Monthlyリセット（毎月初日04:00基準）
    - イベント交換所: リセットなし
    - キャラのかけらBOX交換所: リセットなし
    - リセット基準時刻はClockの設定（04:00）に従う
- **既存実装との関連:**
  - ShopService::resetUsrShopItem()とClock::isFirstMonth()の組み合わせ
- **備考:**
  - プランナー確認結果（Q3）により、バッチ処理ではなくアクセス時判定で実装と確定

---

#### 要件 REQ-HISTORY-3: 交換履歴のキャッシュ管理
- **要件ID:** REQ-HISTORY-3
- **概要:**
  - ユーザーの交換履歴データは、UsrModelManagerによってキャッシュ管理される
- **詳細仕様:**
  - コード調査追記の記載:
    - 要件C-13: UsrModelManagerによるキャッシュ管理
  - APIで実現すべき内容:
    - ユーザー交換履歴モデルは`UsrEloquentModel`を継承
    - `makeModelKey()`メソッドでキャッシュキーを生成（例: `{usr_user_id}{lineup_id}`）
    - UsrModelManagerによる自動キャッシュ機構を活用
  - データ管理要件:
    - ユーザー交換履歴テーブルのユニークキーは`usr_user_id`と`lineup_id`の複合キー
- **既存実装との関連:**
  - UsrShopItem::makeModelKey()と同様の実装
- **備考:**
  - パフォーマンス要件として、既存のキャッシュ機構を踏襲

---

### 3.4 交換実行処理

#### 要件 REQ-EXCHANGE-1: 交換実行の事前バリデーション
- **要件ID:** REQ-EXCHANGE-1
- **概要:**
  - 交換実行前に、交換所・ラインナップの有効性、交換回数、リソース所持数を検証する
- **詳細仕様:**
  - サーバー仕様レビューの記載:
    - 2.4.1: 事前チェック（バリデーション）の順序
  - APIで実現すべき内容:
    - 以下の順序でバリデーションを実施:
      1. 交換所の存在チェック: 交換所IDが存在し、開催期間内か
      2. ラインナップの存在チェック: ラインナップIDが存在し、交換期間内か
      3. 交換回数のリセット判定: リセットが必要な場合、`trade_count`を0にリセット
      4. 交換上限チェック: `trade_count < tradable_count`または`tradable_count IS NULL`
      5. リソース所持数チェック: 必要リソースを十分に所持しているか
      6. 交換個数の妥当性チェック: `交換個数 >= 1`かつ`交換個数 <= 残り交換可能回数`かつ`所持リソース / 必要リソース >= 交換個数`
  - 検証・チェック要件:
    - いずれかのチェックで失敗した場合、適切なエラーコードをスローし、トランザクションを実行しない
- **既存実装との関連:**
  - ShopTradeShopItemUseCase::execute()のバリデーション処理と同様
- **備考:**
  - まとめて交換時の個数検証（要件REQ-EXCHANGE-8）も参照

---

#### 要件 REQ-EXCHANGE-2: トランザクション内でのリソース消費と報酬付与
- **要件ID:** REQ-EXCHANGE-2
- **概要:**
  - 交換処理（リソース消費と報酬付与）は、トランザクション内で原子性を保証する
- **詳細仕様:**
  - コード調査追記の記載:
    - 要件C-3: 交換実行はトランザクション内で原子性を保証
  - APIで実現すべき内容:
    - `UseCaseTrait::applyUserTransactionChanges()`メソッド内でトランザクション処理を実施
    - トランザクション内で以下を実行:
      1. リソース消費処理
      2. 報酬付与処理
    - トランザクション外で以下を実行（トランザクション前）:
      1. 交換回数のインクリメント
    - 例外が発生した場合、全ての変更をロールバック
  - 条件・制約:
    - リソース消費と報酬付与は同一トランザクション内で完結
    - トランザクション処理の途中でエラーが発生した場合、全ての変更が取り消される
- **既存実装との関連:**
  - ShopTradeShopItemUseCase::execute()のトランザクション処理と同様
- **備考:**
  - 実装時は既存のUseCaseパターンを踏襲

---

#### 要件 REQ-EXCHANGE-3: リソース消費処理
- **要件ID:** REQ-EXCHANGE-3
- **概要:**
  - 交換に必要なリソース（コイン、アイテム、ダイヤ等）を消費する
- **詳細仕様:**
  - コード調査追記の記載:
    - 要件C-5: 交換コストの種別（CostType）は既存パターンを踏襲
    - 要件C-6: アイテム消費はUsrItemServiceを経由
  - APIで実現すべき内容:
    - コストタイプに応じて以下のサービスを呼び出してリソースを消費:
      - CostType = Coin: `UserDelegator::consumeCoin()`
      - CostType = Diamond: `AppCurrencyDelegator::consumeDiamond()`
      - CostType = PaidDiamond: `AppCurrencyDelegator::consumePaidDiamond()`
      - CostType = Item: `UsrItemService::consumeItem()`
    - 各消費サービスは、所持数チェック、不足時のエラー（`LACK_OF_RESOURCES`）、ログ出力を自動的に処理
  - 条件・制約:
    - リソース不足時は`LACK_OF_RESOURCES`エラーをスロー
  - データ管理要件:
    - 消費ログは各サービスが自動的に記録（log_items, log_coin等）
- **既存実装との関連:**
  - ShopService::consumeCost()と同様のロジック
- **備考:**
  - 複数リソース消費が必要な場合（プランナー確認結果Q1で実装必要と確定）、複数のリソースを順次消費する処理を実装

---

#### 要件 REQ-EXCHANGE-4: 報酬付与処理
- **要件ID:** REQ-EXCHANGE-4
- **概要:**
  - 交換で獲得する報酬（アイテム、キャラ、コイン等）をユーザーに付与する
- **詳細仕様:**
  - コード調査追記の記載:
    - 要件C-4: 報酬付与はRewardDelegator経由で一元管理
  - APIで実現すべき内容:
    - `RewardDelegator::addReward()`で報酬をリストに追加
    - `RewardDelegator::sendRewards()`で一括配布を実行
    - 報酬タイプ（Item, Unit, Coin, FreeDiamond, Stamina, Emblem, Exp等）ごとに専用のSendServiceが自動的に呼び出される
    - 各SendServiceは、リソースの加算、上限チェック、ログ出力、ミッション連携を自動的に処理
  - 条件・制約:
    - アイテム所持上限超過時は、自動的にコイン等に変換される（既存のReward基盤の仕組み）
    - ユニット既所持の場合は、かけらに変換される
  - データ管理要件:
    - 報酬付与ログは各SendServiceが自動的に記録
- **既存実装との関連:**
  - ShopService::tradeShopItem()と同様のRewardDelegator利用パターン
- **備考:**
  - 既存のReward基盤を活用することで、複雑な報酬変換処理を自動化

---

#### 要件 REQ-EXCHANGE-5: 交換回数のインクリメント
- **要件ID:** REQ-EXCHANGE-5
- **概要:**
  - 交換実行時、`trade_count`と`trade_total_count`の両方をインクリメントする
- **詳細仕様:**
  - コード調査追記の記載:
    - 要件C-1: 交換履歴の二重管理（trade_count と trade_total_count）
  - APIで実現すべき内容:
    - 交換実行時、`trade_count`と`trade_total_count`を両方+1
    - `trade_count`はリセット対象、`trade_total_count`は永続カウンタ
  - データ管理要件:
    - ユーザー交換履歴テーブルの`trade_count`, `trade_total_count`を更新
- **既存実装との関連:**
  - UsrShopItem::incrementTradeCount()と同様
- **備考:**
  - まとめて交換の場合、交換個数分のインクリメントを実施

---

#### 要件 REQ-EXCHANGE-6: 交換ログの保存
- **要件ID:** REQ-EXCHANGE-6
- **概要:**
  - 交換実行時には、交換ログ（ユーザーID、交換物ID、交換回数、コストタイプ、コスト数、実際に受け取った報酬）を保存する
- **詳細仕様:**
  - コード調査追記の記載:
    - 要件C-8: 交換ログの保存（log_trade_shop_items相当）
  - APIで実現すべき内容:
    - 交換実行時に以下の情報をログテーブルに保存:
      - `usr_user_id`: ユーザーID
      - `lineup_id`: 交換ラインナップID
      - `trade_count`: 交換回数（何回目の交換か）
      - `cost_type`: 消費したコストタイプ
      - `cost_amount`: 消費したコスト数
      - `received_reward`: 実際にユーザーが受け取った報酬情報（JSON）
      - `created_at`: 交換実行日時
  - データ管理要件:
    - 交換ログテーブルに上記カラムを保持
    - `received_reward`には、RewardDelegatorから取得した実際の配布済み報酬情報を格納
- **既存実装との関連:**
  - LogTradeShopItemRepository::create()と同様のログ保存処理
- **備考:**
  - 運用上の分析・トラブルシューティングのため、ログ出力は必須

---

#### 要件 REQ-EXCHANGE-7: エラーハンドリング
- **要件ID:** REQ-EXCHANGE-7
- **概要:**
  - 交換処理で発生するエラーに対して、適切なエラーコードをスローする
- **詳細仕様:**
  - サーバー仕様レビューの記載:
    - 2.4.3: エラーハンドリング
  - APIで実現すべき内容:
    - 以下のエラーコードをスロー:
      - `MST_NOT_FOUND`: 交換所・ラインナップが見つからない、または期間外
      - `SHOP_TRADE_COUNT_LIMIT`: 交換上限到達
      - `LACK_OF_RESOURCES`: リソース不足
      - `INVALID_PARAMETER`: 交換個数が不正（1未満または上限超過）
  - 条件・制約:
    - エラーコードは既存のShop機能と統一（200番台）
- **既存実装との関連:**
  - ErrorCode定数の既存定義を活用
- **備考:**
  - 交換所専用の新しいエラーコードが必要な場合は、200番台で追加定義

---

#### 要件 REQ-EXCHANGE-8: まとめて交換の個数検証
- **要件ID:** REQ-EXCHANGE-8
- **概要:**
  - まとめて交換時、交換個数は最小1個、最大は交換上限残数と所持リソースから計算可能な個数の小さい方とする
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - Page 7: 交換可能上限数まで交換に必要なリソースを所持している場合は、まとめて交換できる
  - APIで実現すべき内容:
    - 交換可能個数の計算:
      1. 交換上限の残数: `tradable_count - trade_count`（tradable_countがNULLの場合は無制限）
      2. 所持リソースから計算可能な交換回数: `所持リソース数 / 必要リソース数`（小数点以下切り捨て）
      3. 最大交換個数 = min(1, 2)
    - 交換個数のバリデーション:
      - `交換個数 >= 1`
      - `交換個数 <= 最大交換個数`
    - バリデーション失敗時は`INVALID_PARAMETER`エラーをスロー
  - 条件・制約:
    - 交換個数は最小1個（0個の交換は不可）
- **既存実装との関連:**
  - 既存のShop機能では単一交換のみのため、まとめて交換は新規実装
- **備考:**
  - プランナー確認結果（Q6）により、初期交換個数はクライアント側の画面仕様であり、サーバー考慮不要

---

### 3.5 原画アイテムの特別処理

#### 要件 REQ-ORIGINAL-1: 原画の付与方法
- **要件ID:** REQ-ORIGINAL-1
- **概要:**
  - 原画を交換した際、原画アイテム（完成品）と原画のかけら16個を同時に付与する
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - Page 8: 原画を交換すると、既存の原画のかけら演出がかけら16ピース分再生される
  - APIで実現すべき内容:
    - 原画を交換した際、RewardDelegatorに以下の2つの報酬を登録:
      1. 原画アイテム（Item、数量1）
      2. 原画のかけら（Item、数量16）
    - クライアント側で16ピース演出を実行するために必要なデータ（かけら16個）をサーバーが提供
    - 付与後のユーザーデータは「完全に完成した状態」として記録される
  - 条件・制約:
    - 原画のラインナップには、かけら単位での設定はできない（完成品のみ）
- **既存実装との関連:**
  - 既存コードで原画の特別処理の実装例は見つからなかったため、新規実装
- **備考:**
  - プランナー確認結果（Q4）により、原画のかけらも原画も付与して、完全に完成した状態で記録すると確定

---

### 3.6 複数リソース消費のサポート

#### 要件 REQ-MULTI-COST-1: 複数リソース消費の実装
- **要件ID:** REQ-MULTI-COST-1
- **概要:**
  - 1つのラインナップで複数種類のリソース（例: コイン1000 + アイテムA×10）を同時に消費できる
- **詳細仕様:**
  - プランナー確認結果の記載:
    - Q1: 複数リソース消費の機能は実装する
  - APIで実現すべき内容:
    - 1つのラインナップに対して、複数種類のコスト（例: コイン + アイテム）を設定可能
    - 交換実行時、全てのコストを順次消費
    - いずれかのコストが不足している場合、`LACK_OF_RESOURCES`エラーをスロー
  - 条件・制約:
    - 複数リソース消費の最大組み合わせ数は未確定（暫定的には2種類まで想定）
    - バリデーション順序は未確定（暫定的にはマスタデータの定義順）
    - トランザクション順序は未確定（暫定的にはバリデーション順と同じ）
  - データ管理要件:
    - 交換コストテーブルを1:N構造に拡張、または1レコードに複数カラムを持たせる
  - 検証・チェック要件:
    - 全てのコストについて所持数チェックを実施
    - 1つでも不足している場合はエラー
- **備考:**
  - プランナー確認結果（Q1）により実装必要と確定したが、詳細仕様（最大組み合わせ数、バリデーション順序等）は未確定
  - 次のStageで詳細設計時に再確認が必要
  - 工数見積もり: +3人日

---

### 3.7 非機能要件

#### 要件 REQ-NON-FUNC-1: パフォーマンス要件
- **要件ID:** REQ-NON-FUNC-1
- **概要:**
  - ラインナップ一覧取得時のレスポンスタイムを最小化する
- **詳細仕様:**
  - APIで実現すべき内容:
    - UsrModelManagerのキャッシュ機構を活用し、DBアクセスを最小化
    - リセット判定は毎回DBアクセスせず、キャッシュ上で判定
    - 残り時間計算は効率的なアルゴリズムで実装
  - 条件・制約:
    - ラインナップ一覧取得のレスポンスタイムは、既存のShop機能と同等レベルを目標
- **既存実装との関連:**
  - UsrModelManagerのキャッシュ機構を踏襲
- **備考:**
  - 具体的なレスポンスタイム目標値は未設定

---

#### 要件 REQ-NON-FUNC-2: トランザクション整合性
- **要件ID:** REQ-NON-FUNC-2
- **概要:**
  - 交換時のリソース消費と報酬付与の原子性を保証する
- **詳細仕様:**
  - コード調査追記の記載:
    - 要件C-3: 交換実行はトランザクション内で原子性を保証
  - APIで実現すべき内容:
    - リソース消費と報酬付与は同一トランザクション内で完結
    - トランザクション処理の途中でエラーが発生した場合、全ての変更が取り消される
- **備考:**
  - 要件REQ-EXCHANGE-2と同じ

---

#### 要件 REQ-NON-FUNC-3: 同時実行制御
- **要件ID:** REQ-NON-FUNC-3
- **概要:**
  - 同一ユーザーの重複交換リクエストを制御する
- **詳細仕様:**
  - APIで実現すべき内容:
    - 同一ユーザーが同時に複数の交換リクエストを送信した場合、適切に排他制御を実施
    - ユーザーモデルのロック機構を活用
  - 条件・制約:
    - リソース消費と報酬付与がトランザクション内で実行されるため、DB側のトランザクション分離レベルで制御
- **備考:**
  - 具体的な実装方式（楽観的ロック、悲観的ロック等）は実装時に決定

---

#### 要件 REQ-NON-FUNC-4: ログ記録
- **要件ID:** REQ-NON-FUNC-4
- **概要:**
  - 交換実行時の詳細ログを記録する
- **詳細仕様:**
  - APIで実現すべき内容:
    - 交換実行時の詳細ログ（要件REQ-EXCHANGE-6）を記録
    - リソース消費ログ（log_items, log_coin等）を記録
    - 報酬付与ログを記録
  - データ管理要件:
    - ログは永続的に保存（削除しない）
- **備考:**
  - 運用上の分析・トラブルシューティングのため、ログ出力は必須

---

#### 要件 REQ-NON-FUNC-5: ミッション連携
- **要件ID:** REQ-NON-FUNC-5
- **概要:**
  - アイテム取得、交換実行などの行動は、ミッションシステムへのトリガー送信が必要
- **詳細仕様:**
  - コード調査追記の記載:
    - 要件C-16: ミッション連携（アイテム取得、交換実行等）
  - APIで実現すべき内容:
    - 報酬付与時、各SendServiceがミッショントリガーを自動的に送信
    - 交換実行時、適切なミッショントリガーを送信（例: 「交換所で〇回交換した」というミッション）
  - 条件・制約:
    - ミッション連携は既存のReward基盤が自動的に処理
- **備考:**
  - 具体的なミッション定義は未確定

---

## 4. 要件間の依存関係

### 4.1 前提となる要件

- **REQ-EXCHANGE-1（事前バリデーション）** は **REQ-MASTER-2（開催期間管理）**、**REQ-LINEUP-2（交換期間フィルタリング）**、**REQ-HISTORY-1（交換回数管理）** が実現されていることを前提とする
- **REQ-EXCHANGE-2（トランザクション処理）** は **REQ-EXCHANGE-3（リソース消費）**、**REQ-EXCHANGE-4（報酬付与）**、**REQ-EXCHANGE-5（交換回数インクリメント）** を包含する
- **REQ-MULTI-COST-1（複数リソース消費）** は **REQ-EXCHANGE-3（リソース消費）** の拡張版

### 4.2 同時に実現すべき要件

- **REQ-EXCHANGE-3（リソース消費）** と **REQ-EXCHANGE-4（報酬付与）** は同一トランザクション内で同時に実現される必要がある
- **REQ-HISTORY-1（交換回数の二重管理）** と **REQ-HISTORY-2（リセットタイミング判定）** は密接に関連し、同時に実装される必要がある

---

## 5. 非機能要件

### 5.1 パフォーマンス要件

- ラインナップ一覧取得のレスポンスタイムは、既存のShop機能と同等レベルを目標（具体的な目標値は未設定）
- UsrModelManagerのキャッシュ機構を活用し、DBアクセスを最小化
- リセット判定は毎回DBアクセスせず、キャッシュ上で判定
- 残り時間計算は効率的なアルゴリズムで実装

### 5.2 セキュリティ要件

- 同一ユーザーの重複交換リクエストを適切に排他制御
- クライアントからの交換個数パラメータを厳密にバリデーション（上限超過、不正な値の検出）
- トランザクション処理により、リソースの不正増減を防止

### 5.3 可用性要件

- トランザクション処理の途中でエラーが発生した場合、全ての変更をロールバック
- エラーハンドリングを適切に実施し、エラー発生時もデータの整合性を保証
- ログ記録により、障害発生時のトラブルシューティングを可能に

### 5.4 その他の非機能要件

- **ログ記録**: 交換実行時の詳細ログ、リソース消費ログ、報酬付与ログを永続的に記録
- **監視**: 交換実行数、エラー発生率を監視可能にする（具体的な監視方法は実装時に決定）
- **運用**: 交換所マスタデータ、ラインナップマスタデータの追加・変更は、管理ツール（admin）で実施（本要件書の対象外）

---

## 6. データ要件

### 6.1 永続化が必要なデータ

#### データ項目A: 交換所マスタデータ
- **内容:** 交換所ID、カテゴリ、開催期間（start_date, end_date）
- **用途:** 交換所の開催期間管理とフィルタリング
- **保持期間:** 永久（過去の交換所も履歴として保持）
- **関連要件:** REQ-MASTER-1, REQ-MASTER-2, REQ-MASTER-4

#### データ項目B: 交換ラインナップマスタデータ
- **内容:** ラインナップID、交換所ID、報酬アイテムID/数量、必要リソースID/数量、交換期間、交換上限数
- **用途:** 交換ラインナップの期間管理、報酬・コスト設定
- **保持期間:** 永久（過去のラインナップも履歴として保持）
- **関連要件:** REQ-LINEUP-1, REQ-LINEUP-2, REQ-LINEUP-4

#### データ項目C: 交換コストマスタデータ（複数リソース消費対応）
- **内容:** ラインナップID、コストタイプ、コストID、コスト数
- **用途:** 複数リソース消費のコスト設定
- **保持期間:** 永久
- **関連要件:** REQ-MULTI-COST-1

#### データ項目D: ユーザー交換履歴
- **内容:** ユーザーID、ラインナップID、交換回数（trade_count）、通算交換回数（trade_total_count）、最終リセット日時（last_reset_at）
- **用途:** ユーザーごとの交換回数管理と交換上限チェック
- **保持期間:** 永久（ユーザーの交換履歴として保持）
- **関連要件:** REQ-HISTORY-1, REQ-HISTORY-2, REQ-HISTORY-3

#### データ項目E: 交換ログ
- **内容:** ユーザーID、ラインナップID、交換回数、コストタイプ、コスト数、実際に受け取った報酬（JSON）、交換実行日時
- **用途:** 運用分析、トラブルシューティング
- **保持期間:** 永久（削除しない）
- **関連要件:** REQ-EXCHANGE-6

#### データ項目F: リソース消費ログ（log_items, log_coin等）
- **内容:** ユーザーID、リソースID、消費数、消費日時、消費理由
- **用途:** リソース消費履歴の記録
- **保持期間:** 永久
- **関連要件:** REQ-EXCHANGE-3

### 6.2 一時的に管理が必要なデータ

#### データ項目G: ユーザー交換履歴のキャッシュ
- **内容:** ユーザーID、ラインナップID、交換回数等
- **用途:** パフォーマンス向上のため、UsrModelManagerでキャッシュ管理
- **保持期間:** セッション中のみ（永続化はDBで実施）
- **関連要件:** REQ-HISTORY-3

---

## 7. 外部システム連携要件

### 7.1 クライアント連携

- **交換所一覧取得:**
  - クライアントは交換所一覧を取得し、開催期間と残り時間を表示
  - サーバーは開催期間内の交換所のみを返却
- **交換ラインナップ取得:**
  - クライアントは特定交換所のラインナップ一覧を取得し、交換可能回数と残り時間を表示
  - サーバーは交換期間内のラインナップのみを返却
- **交換実行:**
  - クライアントは交換個数を指定して交換リクエストを送信
  - サーバーはバリデーション後、リソース消費と報酬付与を実行
- **原画の16ピース演出:**
  - クライアントは原画交換時、サーバーから付与された原画のかけら16個を受け取り、16ピース演出を実行

### 7.2 他API機能との連携

- **Reward機能との連携:**
  - 報酬付与はRewardDelegator経由で実行
  - 各SendServiceが報酬タイプごとに自動的に呼び出される
- **Item機能との連携:**
  - アイテムをコストとする交換は、UsrItemService::consumeItem()を使用
  - アイテムの付与はItemSendServiceが自動的に処理
- **Mission機能との連携:**
  - 交換実行時、ミッショントリガーを送信
  - 報酬付与時、各SendServiceがミッショントリガーを自動的に送信
- **Clock機能との連携:**
  - リセットタイミングの判定にClock::isFirstMonth()等を使用

### 7.3 外部サービス連携

- 該当なし（現時点では外部サービスとの連携は不要）

---

## 8. 残存する不明点・要確認事項

### 8.1 まだ不明な仕様

#### 不明点1: 複数リソース消費の詳細仕様
- **何が不明か:**
  - 複数リソース消費の最大組み合わせ数（2種類まで？ 3種類以上？ 無制限？）
  - 複数リソース消費時のバリデーション順序（どのリソースから先にチェックするか）
  - 複数リソース消費時のトランザクション順序（どのリソースから先に消費するか）
  - 複数リソース消費時のログ出力形式（JSON配列？複数レコード？）
- **実装への影響:**
  - テーブル設計（交換コストテーブルの1:N化、または正規化）
  - バリデーションロジックの拡張
  - APIレスポンス形式の拡張
  - 工数見積もり: +3人日
- **確認すべき相手:**
  - プランナー（複数リソース消費の具体的なユースケース、最大組み合わせ数）

#### 不明点2: アイテムタブ分類のクライアント側実装方針
- **何が不明か:**
  - クライアント側でタブ分類を行う際、どの項目（ItemType、ItemGroupType、その他）を使用して判定するか
  - サーバー側が返却するデータ形式に追加が必要か
- **実装への影響:**
  - APIレスポンス形式に影響する可能性（ただし、プランナー確認結果Q5で「サーバー考慮不要」と確定したため、影響は最小限）
- **確認すべき相手:**
  - クライアント側の実装担当者

#### 不明点3: 復刻時のラインナップID運用
- **何が不明か:**
  - 復刻時に「ラインナップはそのまま」という表現が、既存ラインナップIDを再利用するのか、同じ内容の新しいラインナップIDを作成するのか
- **実装への影響:**
  - データの独立性、マスタデータ管理方式に影響
  - 実装上は新規ラインナップIDを作成する方が安全
- **確認すべき相手:**
  - マスタデータ運用担当者（プランナー）

#### 不明点4: 原画のコスト設定方針
- **何が不明か:**
  - 原画を交換するために必要なコストの設定方針（例: 特別に高いコスト、通常のかけら交換と同等など）
- **実装への影響:**
  - マスタデータ設計、ゲームバランスに影響
  - ただし、実装上はマスタデータで設定可能なため、サーバー実装への直接的な影響は小さい
- **確認すべき相手:**
  - プランナー

### 8.2 実装時に判断が必要な事項

#### 判断事項1: 複数リソース消費のテーブル設計
- **内容:**
  - 交換コストテーブルを1:N構造に正規化するか、1レコードに複数カラムを持たせるか
- **選択肢:**
  - 選択肢A: 交換コストテーブルを正規化（1:N構造）
    - メリット: 柔軟性が高い、将来的な拡張に対応しやすい
    - デメリット: クエリが複雑になる、JOIN処理が増える
  - 選択肢B: 1レコードに複数カラムを持たせる（cost_type_1, cost_id_1, cost_amount_1, cost_type_2, ...）
    - メリット: クエリがシンプル、パフォーマンスが高い
    - デメリット: 柔軟性が低い、最大組み合わせ数に制限がある
- **推奨:**
  - 暫定的には選択肢Aを推奨（柔軟性とメンテナンス性を重視）
  - 不明点1の詳細仕様が確定した後、最終決定

#### 判断事項2: まとめて交換の個数制御
- **内容:**
  - クライアントからの交換個数パラメータをそのまま受け取るか、サーバー側で最大交換個数を計算して返却するか
- **選択肢:**
  - 選択肢A: クライアントからの交換個数パラメータを受け取り、サーバー側でバリデーション
    - メリット: クライアント側で柔軟に個数を指定可能
    - デメリット: バリデーション処理が複雑
  - 選択肢B: サーバー側で最大交換個数を計算してクライアントに返却し、クライアントは最大値以下の個数のみを送信
    - メリット: バリデーション処理がシンプル
    - デメリット: クライアント側の実装が複雑になる可能性
- **推奨:**
  - 選択肢Aを推奨（既存のShop機能と同様のパターン）

---

## 9. 要件確定度の評価

### 9.1 全体評価

- **要件の確定度:** 約85%
- **API実装に必要な要件情報の充足度:** やや不足
  - 不足内容: 複数リソース消費の詳細仕様（最大組み合わせ数、バリデーション順序等）
- **実装開始の可否:** 条件付き可
  - **条件:** 複数リソース消費の詳細設計（最大組み合わせ数、バリデーション順序、ログ形式等）を完了すること

### 9.2 カテゴリ別評価

#### カテゴリA: 交換所マスタデータ管理
- **確定度:** 95%
- **課題:** 復刻時のラインナップID運用方針の確認が必要
- **実装準備状況:** 実装開始可能

#### カテゴリB: 交換ラインナップ管理
- **確定度:** 90%
- **課題:** 複数リソース消費のテーブル設計が必要
- **実装準備状況:** 単一リソース消費については実装開始可能、複数リソース消費については詳細設計が必要

#### カテゴリC: ユーザー交換履歴管理
- **確定度:** 100%
- **課題:** なし
- **実装準備状況:** 実装開始可能

#### カテゴリD: 交換実行処理
- **確定度:** 90%
- **課題:** 複数リソース消費の詳細仕様が必要
- **実装準備状況:** 単一リソース消費については実装開始可能、複数リソース消費については詳細設計が必要

#### カテゴリE: 原画アイテムの特別処理
- **確定度:** 100%
- **課題:** なし
- **実装準備状況:** 実装開始可能

#### カテゴリF: 複数リソース消費のサポート
- **確定度:** 50%
- **課題:** 詳細仕様（最大組み合わせ数、バリデーション順序、ログ形式等）が未確定
- **実装準備状況:** 詳細設計が必要

---

## 10. 次のステップ

### 10.1 要件確定のために必要なアクション

- [ ] **優先度: 高** 複数リソース消費の詳細設計（最大組み合わせ数、バリデーション順序、ログ形式等）
  - 確認相手: プランナー
  - 確認内容: 複数リソース消費の具体的なユースケース、最大何種類のリソースを同時消費する想定か
  - 確認タイミング: 次のStage（API設計、テーブル設計）の開始前（1週間以内）

- [ ] **優先度: 中** 原画のコスト設定方針の確認
  - 確認相手: プランナー
  - 確認内容: 原画の交換コストはどのように設定するか、通常のかけら交換と比べて特別な考慮が必要か
  - 確認タイミング: マスタデータ設計時（API設計と並行可能）

- [ ] **優先度: 低** 復刻時のラインナップID運用方針の確認
  - 確認相手: マスタデータ運用担当者（プランナー）
  - 確認内容: 復刻時に「ラインナップはそのまま」という表現が、既存ラインナップIDを再利用するのか、新しいラインナップIDを作成するのか
  - 確認タイミング: マスタデータ設計時

- [ ] **優先度: 低** クライアント側とのタブ分類仕様の合意
  - 確認相手: クライアント側の実装担当者
  - 確認内容: アイテムBOXの3タブ分類を行う際、どの項目を使用して判定するか、サーバー側から追加で返却してほしいデータ項目があるか
  - 確認タイミング: API設計時

### 10.2 実装設計へ向けて

- [ ] **優先度: 高** テーブル設計
  - 交換所マスタテーブル
  - 交換ラインナップマスタテーブル
  - 交換コストマスタテーブル（複数リソース消費対応）
  - ユーザー交換履歴テーブル
  - 交換ログテーブル

- [ ] **優先度: 高** API設計
  - 交換所一覧取得API
  - 交換ラインナップ取得API
  - 交換実行API
  - 交換履歴取得API

- [ ] **優先度: 中** マスタデータ設計
  - 交換所マスタデータの設定項目
  - 交換ラインナップマスタデータの設定項目
  - 交換コストマスタデータの設定項目（複数リソース対応）
  - 原画のコスト設定方針の反映

- [ ] **優先度: 中** エラーコード定義
  - 交換所専用のエラーコード（200番台）を追加定義

- [ ] **優先度: 低** 技術選定
  - （現時点では既存基盤を活用するため、特別な技術選定は不要）

---

**作成日:** 2025-11-26
**作成者:** サーバー開発チーム
**次のステップ:** API設計、テーブル設計の開始
