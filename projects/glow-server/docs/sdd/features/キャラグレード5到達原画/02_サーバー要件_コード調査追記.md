# サーバー要件（コード調査による追加・補足）- キャラグレード5到達原画

## サーバー要件（コード調査による追加・補足）

### 要件C-1: グレードアップAPIの実装構造
- 種別: コードから判明した追加要件
- 関連機能: キャラグレード5到達原画 / グレードアップ処理
- 関連ファイル:
  - `api/app/Http/Controllers/UnitController.php` の `gradeUp`
  - `api/app/Domain/Unit/UseCases/UnitGradeUpUseCase.php` の `exec`
  - `api/app/Domain/Unit/Services/UnitGradeUpService.php` の `gradeUp`
- 内容の要約:
  - グレードアップ処理は、既存のAPIエンドポイント `/unit/grade_up` で実行され、UseCase→Service層の構造で実装されている
- 詳細:
  - グレードアップは `POST /unit/grade_up` エンドポイントで実行される
  - リクエストパラメータは `usrUnitId` のみで、現在のグレードから1つ上のグレードに上げる処理となっている
  - UseCaseパターンで実装され、トランザクション管理は `UseCaseTrait` の `applyUserTransactionChanges` メソッドで行われる
  - レスポンスには更新後のユニット情報と、変更されたユーザーアイテム情報が含まれる
- 元になったコードの抜粋:
  ```php
  // UnitController.php
  public function gradeUp(UnitGradeUpUseCase $useCase): JsonResponse
  {
      $validated = $this->request->validate([
          'usrUnitId' => 'required',
      ]);
      $user = $this->request->user();
      $usrUnitId = $validated['usrUnitId'];
      $resultData = $useCase->exec($user, $usrUnitId);
      return $this->responseFactory->createUnitGradeUpResponse($resultData);
  }
  ```
- 備考:
  - 仕様書には明記されていないが、既存のAPI構造を前提とした原画付与の実装が必要

### 要件C-2: グレードアップ時のアイテム消費とバリデーション
- 種別: コードから判明した追加要件
- 関連機能: キャラグレード5到達原画 / グレードアップ処理
- 関連ファイル:
  - `api/app/Domain/Unit/Services/UnitGradeUpService.php` の `gradeUp`
  - `api/app/Domain/Resource/Mst/Repositories/MstUnitGradeUpRepository.php`
- 内容の要約:
  - グレードアップ時には、mst_unit_grade_upsテーブルの設定に基づいてアイテム消費が行われ、アイテム不足時はエラーとなる
- 詳細:
  - `MstUnitGradeUpRepository::getByUnitLabelAndGradeLevel` で次のグレードの設定を取得
  - 該当する設定がない場合はエラー（第3引数 `true` で必須チェック）
  - `ItemDelegator::useItemByMstItemId` でキャラのかけらアイテムを消費
  - かけら数は `MstUnitGradeUp::require_amount` で定義
  - アイテム消費後にユニットの `grade_level` を1増やし、`UsrUnitSummary::grade_level_total_count` を累計でカウント
- 元になったコードの抜粋:
  ```php
  $mstUnitGradeUp = $this->mstUnitGradeUpRepository->getByUnitLabelAndGradeLevel(
      $mstUnit->getUnitLabel(),
      $afterGradeLevel,
      true  // エラー発生フラグ
  );
  $this->itemDelegator->useItemByMstItemId(
      $usrUserId,
      $mstUnit->getFragmentMstItemId(),
      $mstUnitGradeUp->getRequireAmount(),
      new JoinLogTrigger($logUnitGradeUp),
  );
  ```
- 備考:
  - グレード5到達時の原画付与は、このアイテム消費とグレードレベル更新の後に実行する必要がある

### 要件C-3: グレードアップ時のミッショントリガー送信
- 種別: コードから判明した追加要件
- 関連機能: キャラグレード5到達原画 / ミッション連携
- 関連ファイル:
  - `api/app/Domain/Unit/Services/UnitGradeUpService.php` の `gradeUp`
  - `api/app/Domain/Unit/Services/UnitMissionTriggerService.php` の `sendGradeUpTrigger`
  - `api/app/Domain/Mission/Enums/MissionCriterionType.php`
- 内容の要約:
  - グレードアップ時には、ミッションシステムへのトリガー送信が自動で行われる（`SPECIFIC_UNIT_GRADE_UP_COUNT`）
- 詳細:
  - グレードアップ完了後、`UnitMissionTriggerService::sendGradeUpTrigger` が呼ばれる
  - `MissionCriterionType::SPECIFIC_UNIT_GRADE_UP_COUNT` タイプのミッショントリガーが送信される
  - トリガーには `mst_unit_id` と更新後の `grade_level` が含まれる
  - このトリガーにより「特定キャラをグレードXまで強化」系のミッションが自動的に進行する
- 元になったコードの抜粋:
  ```php
  // UnitGradeUpService.php
  $this->unitMissionTriggerService->sendGradeUpTrigger($usrUnit);
  
  // UnitMissionTriggerService.php
  public function sendGradeUpTrigger(UsrUnitInterface $usrUnit): void {
      $this->missionDelegator->addTrigger(
          new MissionTrigger(
              MissionCriterionType::SPECIFIC_UNIT_GRADE_UP_COUNT->value,
              $usrUnit->getMstUnitId(),
              $usrUnit->getGradeLevel(),
          )
      );
  }
  ```
- 備考:
  - 原画獲得機能追加時も、このミッション連携は継続して動作する必要がある

### 要件C-4: グレードアップログの記録
- 種別: コードから判明した追加要件
- 関連機能: キャラグレード5到達原画 / ログ管理
- 関連ファイル:
  - `api/app/Domain/Unit/Services/UnitGradeUpService.php` の `gradeUp`
  - `api/app/Domain/Unit/Repositories/LogUnitGradeUpRepository.php`
- 内容の要約:
  - グレードアップ時には、`log_unit_grade_ups` テーブルにログレコードが作成され、変更前後のグレードレベルが記録される
- 詳細:
  - `LogUnitGradeUpRepository::create` でログレコードを作成
  - ログには `usr_user_id`, `mst_unit_id`, `before_grade_level`, `after_grade_level` が記録される
  - このログは、アイテム消費ログとの紐付けにも使用される（`JoinLogTrigger`）
  - 原画獲得処理を追加する場合、このログとの関連付けが必要になる可能性がある
- 元になったコードの抜粋:
  ```php
  $logUnitGradeUp = $this->logUnitGradeUpRepository->create(
      $usrUserId,
      $mstUnit->getId(),
      $beforeGradeLevel,
      $afterGradeLevel,
  );
  ```
- 備考:
  - 原画獲得の記録は別のログテーブルで管理される可能性が高いが、グレードアップログとの関連は検討が必要

### 要件C-5: 報酬付与システムの実装パターン
- 種別: コードから判明した追加要件
- 関連機能: キャラグレード5到達原画 / 報酬付与
- 関連ファイル:
  - `api/app/Domain/Reward/Delegators/RewardDelegator.php`
  - `api/app/Domain/Reward/Services/RewardSendService.php`
  - `api/app/Domain/Reward/Services/ArtworkSendService.php`
  - `api/app/Domain/Encyclopedia/Delegators/EncyclopediaDelegator.php`
- 内容の要約:
  - ゲーム内の報酬付与は、RewardDelegatorを介した統一的な仕組みで実装されており、原画（ARTWORK）も報酬タイプとして定義されている
- 詳細:
  - 報酬付与の流れ: `RewardDelegator::addReward/addRewards` → `RewardDelegator::sendRewards`
  - `RewardType::ARTWORK` が定義されており、`ArtworkSendService` が対応
  - `ArtworkSendService` は内部で `EncyclopediaDelegator::grantArtworksWithFragments` を呼び出す
  - 原画付与時には、原画の全てのかけらも同時に付与される仕様
  - 重複した原画の場合、自動的にコインに変換される機能も存在（`ArtworkConvertService`）
- **実装パターンの適用範囲**:
  - **ステージクリア報酬、ミッション報酬、ガチャ報酬など、全ての報酬付与シーンに適用可能**
  - **今回のキャラグレード5到達時の原画付与もこのパターンを適用可能**
- **実装方針の背景**:
  - 報酬付与を統一的に管理することで、コードの重複を防ぎ、ログ記録やトランザクション管理を一元化
  - 複数の報酬タイプを同時に処理できる設計（コイン+原画+アイテムなどの組み合わせ対応）
- **代替案が必要になる条件**:
  - 報酬付与のタイミングが特殊で、既存のAPI処理フローに組み込めない場合
  - **今回のグレード5到達時の原画付与は、既存のグレードアップAPI処理内で実行できるため、この条件には該当しない**
- 元になったコードの抜粋:
  ```php
  // RewardDelegator.php
  public function addRewards(Collection $rewards): void {
      $this->rewardManager->addRewards($rewards);
  }
  public function sendRewards(
      string $usrUserId,
      int $platform,
      CarbonImmutable $now,
      ?RewardSendPolicy $policy = null,
  ): void {
      $this->rewardSendService->sendRewards($usrUserId, $platform, $now, $policy);
  }
  
  // ArtworkSendService.php
  public function send(RewardSendContext $context): RewardSent {
      $this->encyclopediaDelegator->grantArtworksWithFragments($usrUserId, $newMstArtworkIds);
      return new RewardSent($rewards);
  }
  ```
- 備考:
  - グレードアップ時の原画付与は、このRewardDelegatorパターンを使用するのが既存実装との整合性が高い

### 要件C-6: 原画とかけらの管理構造
- 種別: コードから判明した追加要件
- 関連機能: キャラグレード5到達原画 / データ管理
- 関連ファイル:
  - `api/app/Domain/Encyclopedia/Services/EncyclopediaService.php`
  - `api/app/Domain/Encyclopedia/Repositories/UsrArtworkRepository.php`
  - `api/app/Domain/Encyclopedia/Repositories/UsrArtworkFragmentRepository.php`
- 内容の要約:
  - 原画は `usr_artworks` テーブルで管理され、原画のかけらは `usr_artwork_fragments` テーブルで管理される別々のデータ構造
- 詳細:
  - `usr_artworks`: ユーザーが獲得した原画を記録（`usr_user_id`, `mst_artwork_id`）
  - `usr_artwork_fragments`: ユーザーが獲得した原画のかけらを記録（`usr_user_id`, `mst_artwork_id`, `mst_artwork_fragment_id`）
  - `EncyclopediaService::grantArtworksWithFragments` メソッドで原画と全かけらを同時付与
  - 原画獲得済みかどうかの判定は `UsrArtworkRepository::getByMstArtworkId` の存在チェックで行う
  - かけらが全て揃った場合に原画が自動的に完成する処理も存在（`EncyclopediaService::registerArtworkIfFragmentsComplete`）
- 元になったコードの抜粋:
  ```php
  // EncyclopediaService.php
  public function grantArtworksWithFragments(string $usrUserId, Collection $mstArtworkIds): void
  {
      // 原画とかけらを同時付与
      foreach ($mstArtworkIds as $mstArtworkId) {
          // 原画データ登録
          // 全かけらデータ登録
      }
  }
  ```
- 備考:
  - キャラIDと原画IDのマッピングは、新たにマスタデータ（例: `mst_unit_artworks`）として定義する必要がある

### 要件C-7: 重複原画のコイン変換処理
- 種別: コードから判明した追加要件
- 関連機能: キャラグレード5到達原画 / 重複処理
- 関連ファイル:
  - `api/app/Domain/Encyclopedia/Services/ArtworkConvertService.php` の `convertDuplicatedArtworkToCoin`
  - `api/app/Domain/Encyclopedia/Constants/EncyclopediaConstant.php`
- 内容の要約:
  - 既に獲得済みの原画が報酬として付与される場合、自動的にコインに変換される処理が存在する
- 詳細:
  - `ArtworkConvertService::convertDuplicatedArtworkToCoin` で重複原画をコインに変換
  - 変換レートは `EncyclopediaConstant::DUPLICATED_ARTWORK_TO_COIN_CONVERSION_RATE` で定義
  - 初獲得の原画と重複獲得の原画を区別して処理
  - コイン変換時にも適切なログが記録される
  - 重複判定は `UsrArtworkRepository` で既存データの有無をチェック
- 元になったコードの抜粋:
  ```php
  // ArtworkConvertService.php
  public function convertDuplicatedArtworkToCoin(
      string $usrUserId,
      Collection $rewards,
  ): void {
      // 重複した原画が配布される場合にコインに変換する
      // 初獲得原画の場合は変換せずに付与
      // 重複獲得原画の変換処理
  }
  ```
- 備考:
  - グレード5到達時の原画付与でも、既に獲得済みの場合はコイン変換が発生する可能性がある
  - 仕様書には記載がないため、クライアント側の演出との整合性確認が必要

### 要件C-8: トランザクション処理と冪等性
- 種別: コードから判明した追加要件
- 関連機能: キャラグレード5到達原画 / トランザクション管理
- 関連ファイル:
  - `api/app/Domain/Common/Traits/UseCaseTrait.php` の `applyUserTransactionChanges`
  - `api/app/Domain/Unit/UseCases/UnitGradeUpUseCase.php`
- 内容の要約:
  - グレードアップAPIを含む全てのユーザーデータ更新処理は、UseCaseTraitのトランザクション管理機能で囲まれており、ロールバック対応が可能
- 詳細:
  - `applyUserTransactionChanges` メソッドがトランザクション開始・コミット・ロールバックを管理
  - 複数のデータベースコネクションに対応（水平/垂直分割を想定）
  - 例外発生時は自動的にロールバック
  - UsrModelManager と LogModelManager を使用したリポジトリであれば、一括保存処理が遅延実行される
  - グレードアップ処理中にエラーが発生した場合、ユニットのグレード更新、アイテム消費、ログ記録が全て取り消される
- 元になったコードの抜粋:
  ```php
  // UnitGradeUpUseCase.php
  public function exec(CurrentUser $user, string $usrUnitId): UnitGradeUpResultData
  {
      $usrUnit = $this->unitGradeUpService->gradeUp($usrUnitId, $user->id);
      // トランザクション処理
      $this->applyUserTransactionChanges();
      // レスポンス作成
      return new UnitGradeUpResultData($usrUnit, $this->usrModelDiffGetService->getChangedUsrItems());
  }
  ```
- 備考:
  - 原画付与処理を追加する場合も、同じトランザクション内で実行されるため、原画付与失敗時は全体がロールバックされる

### 要件C-9: ユーザーデータの変更差分管理
- 種別: コードから判明した追加要件
- 関連機能: キャラグレード5到達原画 / レスポンスデータ
- 関連ファイル:
  - `api/app/Domain/Resource/Usr/Services/UsrModelDiffGetService.php`
  - `api/app/Domain/Unit/UseCases/UnitGradeUpUseCase.php`
  - `api/app/Http/ResponseFactories/UnitResponseFactory.php`
- 内容の要約:
  - API処理中に変更されたユーザーデータは、UsrModelDiffGetServiceで自動的に収集され、レスポンスに含まれる
- 詳細:
  - `UsrModelDiffGetService::getChangedUsrItems` で処理中に変更された全てのユーザーデータを取得
  - 変更されたデータのみがレスポンスに含まれる（効率化）
  - グレードアップ時は、ユニット情報、アイテム情報、ユーザーサマリー情報などが変更差分として返される
  - 原画を付与する場合、`usr_artworks` と `usr_artwork_fragments` の変更も自動的にレスポンスに含まれる
  - クライアントはこの差分情報を使ってUIを更新する
- 元になったコードの抜粋:
  ```php
  // UnitGradeUpUseCase.php
  return new UnitGradeUpResultData(
      $usrUnit, 
      $this->usrModelDiffGetService->getChangedUsrItems()
  );
  ```
- 備考:
  - 原画付与後、クライアントが原画獲得演出を表示するために必要な情報が、このレスポンスに自動的に含まれる

### 要件C-10: 既存ユーザーへの原画付与処理パターン
- 種別: コードから判明した追加要件
- 関連機能: キャラグレード5到達原画 / 既存ユーザー対応
- 関連ファイル:
  - `api/app/Domain/Unit/Repositories/UsrUnitRepository.php`
  - `api/database/migrations/2025_01_29_033017_alter_usr_units.php`
- 内容の要約:
  - 機能リリース時に既にグレード5に到達しているユーザーへの原画付与は、バッチ処理または初回アクセス時判定で実装する必要がある
- 詳細:
  - `usr_units` テーブルには `grade_level` カラムが存在し、現在のグレードレベルが記録されている
  - 機能リリース時、`grade_level >= 5` のレコードを持つユーザーが対象
  - 実装パターンとしては以下の2つが考えられる:
    1. バッチ処理: 全ユーザーの `grade_level` を確認し、条件に合う場合に原画を付与
    2. アクセス時判定: キャラ詳細画面などへのアクセス時に、未獲得フラグをチェックして付与
  - 原画の付与済み/未付与の判定には、`usr_artworks` テーブルの存在チェックを使用
  - 仕様書の要件5「機能リリース時に既にグレード5に強化完了している場合は、そのキャラのキャラ詳細画面に遷移した際に、原画完成演出（画面）を表示する」との整合性が必要
- **実装パターンの適用範囲**:
  - **既存ユーザーへの一括付与が必要な全ての報酬・アイテムに適用可能**
- **実装方針の背景**:
  - バッチ処理: 全ユーザーに確実に付与できるが、処理時間とサーバー負荷が懸念
  - アクセス時判定: サーバー負荷を分散できるが、アクセスしないユーザーには付与されない
  - 既存のShop機能などでは、アクセス時判定パターンが採用されている（Clock機能を使った日次リセットなど）
- **代替案が必要になる条件**:
  - 対象ユーザー数が非常に多く、バッチ処理の実行時間が許容範囲を超える場合
  - 原画付与を「必ず全員に行う」必要がある場合（アクセス時判定では不十分）
  - **今回の機能では、仕様書に「キャラ詳細画面に遷移した際に演出表示」とあるため、アクセス時判定パターンが適している**
- 元になったコードの抜粋:
  ```php
  // usr_unitsテーブル構造（マイグレーションファイルより）
  // `grade_level` int(10) unsigned NOT NULL DEFAULT '0',
  
  // 既存ユーザー判定例（疑似コード）
  $usrUnit = $this->usrUnitRepository->getById($unitId, $usrUserId);
  if ($usrUnit->getGradeLevel() >= 5) {
      $mstArtworkId = $this->getArtworkIdByUnitId($usrUnit->getMstUnitId());
      if (!$this->usrArtworkRepository->getByMstArtworkId($usrUserId, $mstArtworkId)) {
          // 原画未獲得の場合、付与処理を実行
      }
  }
  ```
- 備考:
  - 仕様書の要件5を満たすため、キャラ詳細画面の表示処理内で原画未獲得チェックと演出トリガーの実装が必要
  - 演出表示フラグの管理（一度表示したら次回は表示しない）も検討が必要

### 要件C-11: グレードレベルの範囲とバリデーション
- 種別: コードから判明した追加要件
- 関連機能: キャラグレード5到達原画 / データ整合性
- 関連ファイル:
  - `api/app/Domain/Resource/Mst/Repositories/MstUnitGradeUpRepository.php`
  - `api/database/migrations/mst/2024_11_12_035821_remove_drop_and_premium_n_to_unit_label.php`
- 内容の要約:
  - グレードレベルは unit_label（レアリティ）ごとに異なる最大値が設定されており、不正なグレードアップはマスタデータの存在チェックで防止される
- 詳細:
  - `mst_unit_grade_ups` テーブルに、`unit_label` と `grade_level` の組み合わせでグレードアップ設定を管理
  - UNIQUE KEY `uk_unit_label_grade_level` により、同じグレードの重複設定を防止
  - `MstUnitGradeUpRepository::getByUnitLabelAndGradeLevel` の第3引数を `true` にすることで、存在しないグレードへのアップ時にエラー
  - リリース時はURキャラのみグレード5が設定されるため、他のレアリティではグレード5へのアップができない（マスタデータ未設定）
  - 原画獲得機能もURキャラのみに紐付ける設定が必要
- 元になったコードの抜粋:
  ```php
  // MstUnitGradeUpRepository.php
  public function getByUnitLabelAndGradeLevel(
      string $unitLabel,
      int $gradeLevel,
      bool $throwErrorIfNotFound = false
  ): ?MstUnitGradeUpEntity {
      // 該当するマスタデータが存在しない場合、$throwErrorIfNotFoundがtrueならエラー
  }
  ```
- 備考:
  - 原画獲得設定を追加する際、unit_labelによるフィルタリングを考慮する必要がある

### 要件C-12: ミッション連携と原画完成トリガー
- 種別: コードから判明した追加要件
- 関連機能: キャラグレード5到達原画 / ミッション連携
- 関連ファイル:
  - `api/app/Domain/Encyclopedia/Services/EncyclopediaMissionTriggerService.php`
  - `api/app/Domain/Mission/Entities/Criteria/ArtworkCompletedCountCriterion.php`
  - `api/app/Domain/Mission/Entities/Criteria/SpecificArtworkCompletedCountCriterion.php`
  - `api/app/Domain/Mission/Entities/Criteria/SpecificSeriesArtworkCompletedCountCriterion.php`
- 内容の要約:
  - 原画獲得時には、原画完成系のミッション（「原画をYつ完成させよう」など）へのトリガー送信が必要
- 詳細:
  - `EncyclopediaMissionTriggerService::sendFirstArtworkCompleteTrigger` で原画完成ミッションのトリガーを送信
  - 以下のミッションタイプが存在:
    - `ArtworkCompletedCountCriterion`: 原画をYつ完成させよう
    - `SpecificArtworkCompletedCountCriterion`: 指定原画XをYつ完成させよう（実質Y=1固定）
    - `SpecificSeriesArtworkCompletedCountCriterion`: 指定作品Xの原画をYつ完成させよう
  - 重複なしでカウントするミッションのため、初完成した原画のIDのみをトリガーに含める
  - グレード5到達時の原画付与でも、このトリガー送信を実装する必要がある
- 元になったコードの抜粋:
  ```php
  // EncyclopediaMissionTriggerService.php
  /**
   * 原画完成系のミッションの内で、初めて完成したもののみを対象とした重複なしでカウントするミッションのトリガーを送信する
   * @param Collection<string> $mstArtworkIds mst_artwork.id 初完成した原画のID
   */
  public function sendFirstArtworkCompleteTrigger(Collection $mstArtworkIds): void
  ```
- 備考:
  - グレードアップ時の原画付与処理内で、このミッショントリガー送信を忘れずに実装する必要がある

### 要件C-13: マスタデータの設定構造
- 種別: コードから判明した追加要件
- 関連機能: キャラグレード5到達原画 / マスタデータ管理
- 関連ファイル:
  - `api/database/migrations/mst/2024_11_12_035821_remove_drop_and_premium_n_to_unit_label.php`
- 内容の要約:
  - 新機能追加時には、キャラIDと原画IDを紐付ける新しいマスタテーブル（例: `mst_unit_artworks`）の定義が必要
- 詳細:
  - 現状、`mst_units` テーブルには原画関連のカラムが存在しない
  - `mst_artworks` テーブルには原画の基本情報が存在するが、キャラとの紐付けはない
  - 以下の情報を持つマスタテーブルの追加が必要:
    - `mst_unit_id`: 対象キャラのID
    - `mst_artwork_id`: 獲得できる原画のID
    - `grade_level`: 原画が獲得できるグレードレベル（将来的な拡張を考慮）
    - `release_key`: リリース管理用のキー
  - または、`mst_unit_grade_ups` テーブルに `mst_artwork_id` カラムを追加する方法も検討可能
- 備考:
  - マスタデータの設計は、将来的にグレード5以外でも原画を獲得できるようになる可能性を考慮すべき
  - 仕様書の要件2「リリース時はURキャラのみに設定する」を反映するため、unit_labelでのフィルタリングも必要

## サーバー要件サマリー

コード調査により、合計13個の追加サーバー要件を洗い出しました。主な要件は以下の通りです：

### 既存実装との連携
- グレードアップAPIの構造とトランザクション管理（要件C-1, C-8）
- アイテム消費とバリデーション（要件C-2）
- ミッショントリガー送信（グレードアップ、原画完成）（要件C-3, C-12）
- グレードアップログの記録（要件C-4）

### 報酬付与システム
- RewardDelegatorパターンによる統一的な報酬付与（要件C-5）
- 原画とかけらのデータ管理構造（要件C-6）
- 重複原画のコイン変換処理（要件C-7）

### レスポンス管理
- ユーザーデータの変更差分自動収集とレスポンス生成（要件C-9）

### 既存ユーザー対応
- グレード5到達済みユーザーへの原画付与パターン（アクセス時判定）（要件C-10）

### データ整合性
- グレードレベルの範囲とバリデーション（要件C-11）
- マスタデータの設計と紐付け（要件C-13）

これらの要件は、仕様書から抽出された要件（01_サーバー要件抽出.md）を補完し、実装時に考慮すべき技術的な制約や前提条件を明確にしています。
