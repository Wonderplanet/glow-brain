# API実装全体概要設計 - キャラグレード5到達原画

## 1. ドキュメント情報
- **対象機能:** キャラグレード5到達原画
- **作成日:** 2026-01-21
- **参照ドキュメント:** 05_サーバーAPI要件書.md

## 2. API実装全体像

### 2.1 関連するAPIエンドポイント一覧

| エンドポイント | 種別 | 関連要件ID | 概要 |
|-------------|------|-----------|------|
| POST /unit/grade_up | 既存改修 | REQ-GRADEUP-1, REQ-GRADEUP-2, REQ-GRADEUP-3, REQ-GRADEUP-4, REQ-GRADEUP-5 | グレードアップ時の原画付与処理を追加 |
| POST /unit/receive_grade_up_reward | 新規作成 | REQ-EXISTING-1, REQ-EXISTING-2 | 既存ユーザー向けの報酬受け取りAPI |
| GET /game/update_and_fetch | 既存改修 | - | ユニット情報にlast_reward_grade_level値を含める |
| マスタデータ配信 | 既存利用 | REQ-MST-1, REQ-CLIENT-1, REQ-CLIENT-2 | 新規マスタデータ `mst_unit_grade_up_rewards` を配信 |

### 2.2 新規作成APIエンドポイント

#### POST /unit/receive_grade_up_reward
- **関連要件:** REQ-EXISTING-1, REQ-EXISTING-2
- **役割:** グレード5到達済みユニットの未受け取り報酬（原画）を受け取る
- **新規作成が必要な理由:** 
  - 既存の汎用データ取得API（`GET /game/fetch`）に報酬付与処理を組み込むのは設計として不適切
  - 報酬受け取りという明確な責務を持つ専用APIが必要
  - クライアント側で `last_reward_grade_level < grade_level` を判定し、ユニット詳細画面を開いた時に呼び出す
  - トランザクション管理、エラーハンドリング、ログ記録を適切に実装可能

### 2.3 既存API改修エンドポイント

#### POST /unit/grade_up
- **関連要件:** REQ-GRADEUP-1, REQ-GRADEUP-2, REQ-GRADEUP-3, REQ-GRADEUP-4, REQ-GRADEUP-5
- **現在の機能:** 
  - キャラのグレードを1つ上げる
  - アイテム（かけら）を消費
  - グレードアップログを記録
  - グレードアップミッショントリガーを送信
- **改修内容:**
  1. グレードアップ成功時、`usr_unit.last_reward_grade_level < grade_level` に設定
  2. 到達グレードが報酬獲得対象か判定（`mst_unit_grade_up_rewards` を参照。resource_type/resource_id/resource_amountで管理）
  3. 対象の場合、RewardDelegatorで報酬を付与（現状はArtwork（原画）のみ対応）
  4. 報酬付与後、`usr_unit.last_reward_grade_level = 現在のグレードレベル` に設定
  5. 原画完成ミッショントリガーを送信（Artworkの場合のみ）
  6. 重複原画の場合、自動的にコイン変換（Artworkの場合のみ）
  7. レスポンスに報酬獲得情報を含める（UsrModelDiffGetServiceで自動収集）
- **改修理由:** 
  - グレードアップ時の報酬付与は、既存のグレードアップ処理フロー内で実現可能
  - 既存のRewardDelegatorパターンを使用することで、報酬付与処理を統一的に実装

#### POST /unit/receive_grade_up_reward（新規作成）
- **関連要件:** REQ-EXISTING-1, REQ-EXISTING-2
- **機能概要:**
  - グレード5到達済みで未受け取りの報酬を受け取る専用API（現状は原画のみ対応）
  - ユニット詳細画面を開いた時にクライアントから呼び出される
- **リクエスト:**
  - `usrUnitIds`: 報酬受け取り対象のユニットIDリスト（配列）
- **処理内容:**
  1. 各ユニットに対して以下の判定を実行:
     - 該当ユニットがグレード5以上か
     - `usr_unit.last_reward_grade_level < grade_level` か
     - 該当ユニットに報酬が設定されているか（`mst_unit_grade_up_rewards` を参照。resource_type/resource_id/resource_amountで管理）
     - 該当報酬が未獲得か（resource_typeに応じて判定。現状はArtworkのみで `usr_artworks` を確認）
  2. 条件を満たすユニットに対して報酬を付与
  3. `usr_unit.last_reward_grade_level = 現在のグレードレベル` に更新
  4. 原画完成ミッショントリガーを送信（Artworkの場合のみ）
- **レスポンス:**
  - 付与した報酬情報
  - 更新されたユニット情報
  - 演出表示フラグ（`is_new_grade_up_reward: true`）
- **実装理由:**
  - 機能リリース時に既にグレード5のキャラを所持しているユーザーへの対応
  - クライアント側で報酬未受け取りを判定し、ユーザーの意図的なアクションで受け取る
  - 報酬受け取りという明確な責務を持つ専用API

#### GET /game/update_and_fetch（既存API改修）
- **関連要件:** クライアント側での報酬未受け取り判定に必要
- **現在の機能:**
  - ゲーム全体のデータを取得（ユニット情報を含む）
  - クライアントの定期的なデータ同期に使用
- **改修内容:**
  - ユニット情報に `last_reward_grade_level` フィールドを追加
  - クライアントはこのフラグを確認し、`false` の場合にユニット詳細画面で報酬受け取りAPIを呼び出す
- **改修理由:**
  - `usr_unit` テーブルに新規カラムを追加するため、レスポンスに自動的に含まれる
  - クライアント側で報酬未受け取りの判定に使用するための情報提供
  - サーバー側の処理変更は不要（既存の UsrModelDiffGetService で自動収集）

#### マスタデータ配信（既存システム利用）
- **関連要件:** REQ-MST-1, REQ-CLIENT-1, REQ-CLIENT-2
- **現在の機能:** 
  - ゲーム起動時、マスタデータ更新時にマスタデータを配信
- **改修内容:**
  1. 新規マスタテーブル `mst_unit_grade_up_rewards` を配信対象に追加
  2. クライアントはこのマスタデータをダウンロードして保持
- **改修理由:** 
  - クライアント側でグレードアップ確認ダイアログや必殺ワザ詳細画面の表示判定に使用
  - サーバー側の新規API作成が不要

## 3. 要件とAPIの対応関係

### 3.1 要件 REQ-MST-1: キャラと報酬のマッピング情報管理
- **実現に必要なAPI:**
  - マスタデータ配信（既存利用）
- **実装概要:**
  - 新規マスタテーブル `mst_unit_grade_up_rewards` を作成
  - resource_type, resource_id, resource_amountで報酬を管理（現状はArtworkのみ対応）
  - 既存のマスタデータ配信システムで配信
- **備考:** 新規API不要、マスタデータ管理のみで実現

### 3.2 要件 REQ-GRADEUP-1: グレードアップ時の報酬付与処理
- **実現に必要なAPI:**
  - POST /unit/grade_up（既存改修）
- **実装概要:**
  - グレードアップ処理内で報酬付与判定を実行
  - RewardDelegatorで報酬を付与（resource_typeに応じて処理。現状はArtworkのみ）
  - 既存のトランザクション管理を活用
- **備考:** 既存の報酬付与パターンを再利用

### 3.3 要件 REQ-GRADEUP-2: グレードアップ時の報酬未受け取りフラグ設定
- **実現に必要なAPI:**
  - POST /unit/grade_up（既存改修）
- **実装概要:**
  - グレードアップ成功時にフラグをfalseに設定
  - 原画付与後にフラグをtrueに設定
- **備考:** REQ-GRADEUP-1と同じエンドポイントで実現

### 3.4 要件 REQ-GRADEUP-3: グレードアップ時の重複報酬処理
- **実現に必要なAPI:**
  - POST /unit/grade_up（既存改修）
- **実装概要:**
  - 既存の `ArtworkConvertService` を呼び出し
  - 重複原画を自動的にコイン変換（Artworkの場合のみ）
- **備考:** 既存のコイン変換ロジックを再利用

### 3.5 要件 REQ-GRADEUP-4: グレードアップAPIレスポンスの拡張
- **実現に必要なAPI:**
  - POST /unit/grade_up（既存改修）
- **実装概要:**
  - `UsrModelDiffGetService` で変更差分を自動収集
  - 報酬獲得情報がレスポンスに含まれる
- **備考:** 既存の変更差分収集機能を活用

### 3.6 要件 REQ-GRADEUP-5: ミッショントリガーの送信
- **実現に必要なAPI:**
  - POST /unit/grade_up（既存改修）
- **実装概要:**
  - `EncyclopediaMissionTriggerService::sendFirstArtworkCompleteTrigger` を呼び出し
  - 原画完成ミッショントリガーを送信（Artworkの場合のみ）
- **備考:** 既存のミッション連携パターンを活用

### 3.7 要件 REQ-EXISTING-1: 既存ユーザーへの報酬付与判定
- **実現に必要なAPI:**
  - POST /unit/receive_grade_up_reward（新規作成）
- **実装概要:**
  - クライアント側で `last_reward_grade_level < grade_level` を判定
  - ユニット詳細画面を開いた時に報酬受け取りAPIを呼び出し
  - 条件を満たす場合、報酬を付与（現状はArtworkのみ）
- **備考:** クライアント側の判定により、ユーザーの意図的なアクションで受け取る

### 3.8 要件 REQ-EXISTING-2: 既存ユーザーへの演出表示制御
- **実現に必要なAPI:**
  - POST /unit/receive_grade_up_reward（新規作成）
- **実装概要:**
  - レスポンスに `is_new_grade_up_reward: true` を含める
  - クライアント側で演出を表示
- **備考:** REQ-EXISTING-1と同じエンドポイントで実現

### 3.9 要件 REQ-CLIENT-1: グレードアップ確認ダイアログ用の情報提供
- **実現に必要なAPI:**
  - マスタデータ配信（既存利用）
- **実装概要:**
  - `mst_unit_grade_up_rewards` を配信
  - クライアント側で表示判定を実装
- **備考:** サーバー側の新規API不要

### 3.10 要件 REQ-CLIENT-2: 必殺ワザ詳細画面用の情報提供
- **実現に必要なAPI:**
  - マスタデータ配信（既存利用）
- **実装概要:**
  - `mst_unit_grade_up_rewards` を配信
  - クライアント側で表示判定を実装
- **備考:** サーバー側の新規API不要

## 4. 既存APIだけでは実現困難な項目

### 4.1 既存ユーザーへの原画付与（REQ-EXISTING-1, REQ-EXISTING-2）

- **困難な理由:**
  - 報酬付与処理を既存の汎用データ取得API（`GET /game/fetch`）に組み込むのは設計として不適切
  - 以下の理由から専用APIが必要:
    1. **責務の分離:** データ取得APIに報酬付与という副作用を持つ処理を含めるべきではない
    2. **トランザクション管理:** 報酬付与は明確なトランザクション境界が必要
    3. **エラーハンドリング:** 報酬付与失敗時の適切なエラーメッセージとリトライ処理が必要
    4. **パフォーマンス:** 全ユニット取得時に毎回判定処理を実行するのは非効率
    5. **ユーザー体験:** ユーザーの意図的なアクション（ユニット詳細画面を開く）で受け取るべき
  - クライアント側で `last_reward_grade_level < grade_level` を判定し、必要な時のみAPIを呼び出す設計が適切

- **解決策:** 新規API `POST /unit/receive_grade_up_reward` を作成

### 4.2 既存APIの改修で対応可能な項目
- REQ-GRADEUP-1〜5: POST /unit/grade_up の改修で対応可能
- REQ-MST-1, REQ-CLIENT-1, REQ-CLIENT-2: マスタデータ配信で対応可能

## 5. 実装優先順位

### 5.1 優先度：高（基盤となる実装）
1. **マスタデータ管理**
   - `mst_unit_grade_up_rewards` テーブル作成
   - `usr_unit.last_reward_grade_level` カラム追加
   - マスタデータ配信設定
   - **理由:** 全ての要件の前提となる基盤

2. **POST /unit/grade_up の改修**
   - グレードアップ時の原画付与処理（REQ-GRADEUP-1〜5）
   - **理由:** 機能の中心となるAPI、新規ユーザーの体験に直結

### 5.2 優先度：中（既存ユーザー対応）
1. **POST /unit/receive_grade_up_reward の新規作成**
   - 既存ユーザーへの原画付与・演出表示制御（REQ-EXISTING-1, REQ-EXISTING-2）
   - **理由:** 機能リリース時に既にグレード5のキャラを所持しているユーザーへの対応

### 5.3 実装順序の推奨

#### フェーズ1: データ基盤構築
1. マスタテーブル `mst_unit_grade_up_rewards` のDDL作成・実行
2. `usr_unit` テーブルへの `last_reward_grade_level` カラム追加マイグレーション作成・実行
3. マスタデータ配信設定の追加

#### フェーズ2: グレードアップAPI改修
1. `UnitGradeUpService` に原画付与ロジックを追加
   - フラグ設定（false → true）
   - 原画付与判定
   - RewardDelegatorによる報酬付与
   - ミッショントリガー送信
   - ログ記録
2. ユニットテスト・統合テスト

#### フェーズ3: 既存ユーザー対応API新規作成
1. 新規API `POST /unit/receive_grade_up_reward` を作成
   - リクエストパラメータ定義（ユニットIDリスト）
   - 原画付与判定ロジック
   - 原画付与処理（RewardDelegator使用）
   - フラグ更新
   - ログ記録
   - ミッショントリガー送信
   - レスポンス定義（原画情報、演出表示フラグ）
2. ユニットテスト・統合テスト

#### フェーズ4: 統合テスト・動作確認
1. グレードアップから原画獲得までの一連のフロー確認
2. 既存ユーザーへの原画付与フロー確認
3. クライアントとの連携確認

## 6. APIエンドポイント実装の注意点

### 6.1 POST /unit/grade_up の改修における注意点
1. **トランザクション整合性:**
   - 原画付与処理は既存のトランザクション内で実行
   - エラー発生時は全体がロールバック（グレードアップ、アイテム消費、原画付与の全て）

2. **既存機能への影響:**
   - グレードアップの基本処理（アイテム消費、グレードレベル更新、ログ記録）は変更しない
   - 既存のミッショントリガー（`SPECIFIC_UNIT_GRADE_UP_COUNT`）は継続して送信
   - 原画完成ミッショントリガーは追加で送信

3. **パフォーマンス:**
   - 原画付与処理を追加しても、レスポンスタイムを大幅に増加させない
   - 目標: 既存処理 + 50ms以内

4. **冪等性:**
   - 同じグレードで複数回原画が付与されないよう、`last_reward_grade_level` 値で制御

### 6.2 POST /unit/receive_grade_up_reward の新規作成における注意点
1. **リクエスト設計:**
   - 複数ユニットの一括受け取りに対応（配列でユニットIDを受け取る）
   - クライアント側で `last_reward_grade_level < grade_level` のユニットのみを送信
   - 単一ユニットでも配列形式で送信（APIの一貫性）

2. **トランザクション管理:**
   - 複数ユニットの報酬付与を同一トランザクション内で実行
   - 一部失敗時の処理方針を明確化（全体ロールバック or 個別処理）
   - エラー発生時の適切なロールバック

3. **パフォーマンス:**
   - 対象ユニット数が多い場合の処理時間を考慮
   - 目標: 1ユニットあたり50ms以内
   - 一括処理の上限を設定（例: 最大10ユニット）

4. **冪等性:**
   - 同じリクエストを複数回受け取っても安全に処理
   - `last_reward_grade_level` 値で重複付与を防止
   - 既に受け取り済みの場合はエラーではなく、成功レスポンスを返す

5. **エラーハンドリング:**
   - 条件を満たさないユニットIDが含まれる場合の処理
   - マスタデータ不整合時のエラーメッセージ
   - クライアントへの明確なエラー通知

6. **ミッション連携:**
   - 原画完成ミッショントリガーの確実な送信
   - グレードアップAPIと同じミッション連携ロジックを使用

### 6.3 マスタデータ配信における注意点
1. **クライアントとの連携:**
   - マスタデータの形式をクライアントと合意
   - クライアント側の判定ロジックとの整合性を確認

2. **データ整合性:**
   - `mst_unit_id` の存在チェック
   - `mst_artwork_id` の存在チェック
   - `grade_level` の妥当性チェック

## 7. まとめ

### 7.1 API実装の全体像
本機能は、既存APIの改修と新規APIの作成で実現します。

**改修対象API:**
1. POST /unit/grade_up（既存改修）

**新規作成API:**
1. POST /unit/receive_grade_up_reward（新規作成）

**既存利用:**
1. マスタデータ配信（既存利用）

### 7.2 実装のポイント
1. **既存パターンの活用:**
   - RewardDelegatorパターン
   - トランザクション管理
   - ミッション連携
   - アクセス時判定

2. **責務の分離:**
   - グレードアップ時の処理は `POST /unit/grade_up` に集約
   - 既存ユーザー対応は `POST /unit/receive_grade_up_rewards` に集約
   - クライアント表示判定はクライアント側に委譲
   - データ取得と報酬付与を明確に分離

3. **既存機能への影響最小化:**
   - 既存の処理フローを変更しない
   - 新規処理を追加する形で実装
   - トランザクション整合性を保証

### 7.3 実装の見積もり
- マスタデータ設計・マイグレーション: 0.5〜1日
- POST /unit/grade_up 改修: 1.5〜2.5日
- POST /unit/receive_grade_up_reward 新規作成: 1.5〜2日
- APIレスポンス修正: 0.5日
- ユニットテスト・統合テスト: 1〜2日
- **合計: 5〜8日**

### 7.4 次のステップ
次のドキュメント「サーバーAPI機能要件実装設計」では、以下の詳細設計を行います:
- データベース設計（テーブル定義、カラム定義、制約）
- ドメイン設計（サービス層、リポジトリ層、エンティティ）
- APIリクエスト・レスポンス仕様
- エラーハンドリング
- テストケース設計
