# サーバーAPI要件書

## 1. ドキュメント情報
- 対象機能: 交換所
- 作成日: 2025-11-26
- 参照ドキュメント:
  - 01_サーバー要件抽出.md
  - 02_サーバー要件_コード調査追記.md
  - 03_サーバー仕様レビュー.md
  - 04_ゲーム体験仕様確認結果まとめ.md

## 2. 機能概要

### ユーザーに提供するゲーム体験
交換所は、ユーザーがゲーム内で獲得した特定のアイテムやリソース、専用通貨を使用して、別のアイテムやキャラクター、原画などと交換できる機能です。通常交換所（恒常、月次リセット）、イベント交換所（期間限定）、キャラのかけらBOX交換所の3つのカテゴリーがあり、複数の交換所をバナーで切り替えながら利用できます。各交換所には複数のラインナップが設定され、それぞれに交換アイテム、必要リソース、期間、上限数が個別に設定されています。

### サーバーAPIが果たす役割
サーバーAPIは以下の役割を果たします：
- 有効な交換所とラインナップの一覧を提供
- ユーザーごとの交換履歴を管理し、残り交換可能回数を算出
- 交換上限とリセット周期（日次/週次/月次）に基づく自動リセット処理
- 交換実行時のリソース消費、アイテム付与、トランザクション管理
- 複数種類のリソースを同時に消費する交換の実行
- 交換ログの記録と監査証跡の提供
- お知らせやIGNからの特定交換所への直接遷移対応

## 3. API要件一覧

### 3.1 マスタデータ参照・管理

#### 要件 M-1: 交換所マスタの管理と取得
- **要件ID:** REQ-M-1
- **概要:**
  - 複数の独立した交換所を管理し、有効な交換所の一覧を提供する
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - Page 6: 「交換所は、交換所一覧画面で複数の独立した交換所を専用バナーで切り替えれる構造とします」
    - 「交換所一覧画面に表示可能な交換所バナー数は、無制限になります」
  - APIで実現すべき内容:
    - 交換所マスタを管理する（交換所自体を独立したマスタデータとして扱う）
    - 各交換所には以下の情報を持たせる:
      - 交換所ID（主キー）
      - 交換所名（例: 「通常交換所」「ダンダダンいいジャン祭交換所」）
      - 交換所カテゴリー（NORMAL/EVENT/FRAGMENT_BOX）
      - 開催期間（start_at, end_at）
      - バナー画像URL
      - 表示順（sort_order）
      - 有効フラグ（is_active）
    - 現在時刻で有効な交換所のみを取得して返却する
  - 条件・制約:
    - 交換所IDが未設定または無効な場合は表示しない
    - 開催期間がNULLの場合は無期限として扱う
    - 開催期間外または is_active=false の交換所は非表示
    - 交換所一覧は表示順（sort_order）でソートして返却
  - データ管理要件:
    - 交換所マスタテーブル（mst_exchanges）を新規作成
    - 交換所の開催期間、カテゴリー、表示状態を管理
  - 検証・チェック要件:
    - 開催期間の妥当性検証（start_at <= end_at）
    - 現在時刻が開催期間内であることの確認
- **既存実装との関連:**
  - 既存のショップアイテム機能では、ラインナップのみをマスタ管理していたが、交換所機能では交換所とラインナップの階層構造を持つ
- **備考:**
  - プランナー確認結果（Q1）により、交換所マスタの作成が確定

#### 要件 M-2: 交換所ラインナップマスタの管理と取得
- **要件ID:** REQ-M-2
- **概要:**
  - 各交換所に属するラインナップを管理し、有効なラインナップの一覧を提供する
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - Page 7: 「それぞれ個々に設定できるものは以下になります」として、ラインナップIDや交換アイテム、必要リソース、交換期間、上限数が列挙されている
  - APIで実現すべき内容:
    - ラインナップマスタを管理する
    - 各ラインナップには以下の情報を持たせる:
      - ラインナップID（主キー）
      - 所属交換所ID（外部キー、mst_exchange_shop_id）
      - 交換アイテム種別（reward_type: ITEM/UNIT/ART/EMBLEM/PRISM/COIN）
      - 交換アイテムID（reward_id）
      - 交換アイテム個数（reward_amount）
      - 交換期間（start_at, end_at）
      - 交換上限数（limit_count、NULLの場合は無制限）
      - リセット周期（reset_type: NONE/DAILY/WEEKLY/MONTHLY）
      - 表示順（sort_order）
    - 指定された交換所IDに属するラインナップを全件取得
    - 各ラインナップの交換期間をチェックし、期間内のもののみ返却
  - 条件・制約:
    - 交換期間が未到来のラインナップは非表示
    - 交換期間が終了したラインナップは非表示
    - 交換期間がNULLの場合は無期限として扱う
    - 交換上限がNULLの場合は無制限として扱う
  - データ管理要件:
    - ラインナップマスタテーブル（mst_exchange_lineups）を新規作成
    - 交換所IDとの紐付け（外部キー制約）
  - 検証・チェック要件:
    - 交換期間の妥当性検証（start_at <= end_at）
    - 現在時刻が交換期間内であることの確認
    - 交換所IDの存在確認
- **既存実装との関連:**
  - 既存の`MstShopItem`の構造を参考に設計
  - `getActiveXxxById`メソッドで有効期間チェックを実施するパターンを踏襲
- **備考:**
  - プランナー確認結果（Q11）により、イベント交換所でも日次/週次リセットを設定可能にする

#### 要件 M-3: 複数リソース消費の管理
- **要件ID:** REQ-M-3
- **概要:**
  - 1回の交換で複数種類のリソース（コイン、アイテムなど）を同時に消費する設定を管理する
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - Page 11: 「※ 複数リソース消費が必要なら + 3」（工数見積もり）
  - APIで実現すべき内容:
    - 1つのラインナップに対して複数のコストを設定可能にする
    - 各コストには以下の情報を持たせる:
      - コスト種別（cost_type: ITEM/COIN）
      - コストID（cost_id）
      - コスト個数（cost_amount）
    - ラインナップ取得時に、全てのコスト情報を含めて返却
  - 条件・制約:
    - 1つのラインナップに0個以上のコストを設定可能
    - コストが0個の場合は無料交換として扱う
  - データ管理要件:
    - ラインナップコストテーブル（mst_exchange_lineup_costs）を新規作成
    - ラインナップIDとの紐付け（外部キー制約）
    - 1ラインナップに対してN個のコストレコードを持つ（1:N関係）
  - 検証・チェック要件:
    - コスト個数が正の整数であることを確認
    - 同一リソースが重複して設定されていないかを確認
- **既存実装との関連:**
  - 既存のショップアイテム機能では単一コストのみ対応（cost_type, cost_amount）
  - 複数コストは新規実装が必要
- **備考:**
  - プランナー確認結果（Q2）により、複数リソース消費の実装が確定（+3人日の工数増加）

#### 要件 M-4: 多様なアイテムタイプの交換対応
- **要件ID:** REQ-M-4
- **概要:**
  - アイテム、キャラ、原画、エンブレム、プリズム、コインなど多様なリソースタイプを交換アイテムとして扱う
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - Page 7: 「アイテム、キャラ、原画、エンブレム、プリズム、コインをラインナップに設定することができます」
  - APIで実現すべき内容:
    - reward_typeとreward_idの組み合わせで、様々なリソースタイプを表現
    - 各リソースタイプに応じた付与処理を実装
    - RewardDelegator経由で報酬を配布し、既存の報酬システムと統合
  - 条件・制約:
    - 原画は「かけら単位での設定はできない」ため、reward_amountは常に1
    - 原画交換時は「かけら16ピース分の演出が再生される」ため、クライアントに演出フラグを返却
  - データ管理要件:
    - reward_typeとreward_idをラインナップマスタに保存
  - 検証・チェック要件:
    - reward_typeが有効な値であることを確認
    - reward_idが対応するマスタに存在することを確認
- **既存実装との関連:**
  - `RewardDelegator`を使用した報酬配布パターンを踏襲
  - `ShopItemReward`のように、交換所用のRewardクラス（`ExchangeLineupReward`など）を作成
- **備考:**
  - 原画交換の特殊処理（かけら演出）はクライアント側で実装

#### 要件 M-5: お知らせ・IGNからの特定交換所への直接遷移
- **要件ID:** REQ-M-5
- **概要:**
  - お知らせやIGN（インゲームノーティフィケーション）から特定の交換所に直接遷移できるようにする
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - Page 11: 「お知らせ・IGNからの交換所TOP画面への誘導設定を可能にする」
  - APIで実現すべき内容:
    - 交換所ID指定での取得APIを提供
    - お知らせやIGNのリンクに交換所IDをパラメータとして含める
    - 指定された交換所IDの詳細情報とラインナップ一覧を返却
  - 条件・制約:
    - 交換所IDが無効または期間外の場合はエラーを返す
    - 交換所一覧取得APIと特定交換所取得APIの両方を提供
  - データ管理要件:
    - 既存の交換所マスタを利用（新規テーブル不要）
  - 検証・チェック要件:
    - 交換所IDの存在確認
    - 交換所の開催期間チェック
- **既存実装との関連:**
  - お知らせやIGNのリンク形式は既存の他機能と同様のパターンを踏襲
- **備考:**
  - プランナー確認結果（Q10）により、特定交換所への直接遷移が確定

### 3.2 ユーザーデータ管理（交換履歴）

#### 要件 U-1: ユーザーごとの交換履歴の永続化
- **要件ID:** REQ-U-1
- **概要:**
  - ユーザーごとに、各ラインナップの交換回数と最終リセット日時をDBで永続管理する
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - Page 7: 「交換上限数は、ユーザーごとで可変式で交換した数が反映されるようにする」
  - APIで実現すべき内容:
    - ユーザー交換履歴テーブル（usr_exchange_lineup）を管理
    - 各レコードには以下の情報を持たせる:
      - ユーザーID（usr_user_id）
      - ラインナップID（mst_exchange_lineup_id）
      - 現在期間内の交換回数（exchange_count）
      - 累計交換回数（exchange_total_count）
      - 最終リセット日時（last_reset_at）
    - 初回交換時に新規レコードを作成
    - 交換実行時に交換回数をインクリメント
  - 条件・制約:
    - プライマリキー: (usr_user_id, mst_exchange_lineup_id)
    - exchange_countはリセット周期に応じてリセットされる
    - exchange_total_countは累計値でリセットされない
  - データ管理要件:
    - usr_exchange_lineupsテーブルを新規作成
    - インデックス: usr_user_id, mst_exchange_lineup_id
  - 検証・チェック要件:
    - ラインナップIDの存在確認
    - 交換回数が負の値にならないことを確認
- **既存実装との関連:**
  - 既存の`UsrShopItem`テーブルと同様の構造
  - `trade_count`と`trade_total_count`の管理パターンを踏襲
- **備考:**
  - UsrModelManagerによるキャッシュ管理が必要（要件 U-5参照）

#### 要件 U-2: 交換回数のリセット周期による自動リセット処理
- **要件ID:** REQ-U-2
- **概要:**
  - 交換所の種類やラインナップの設定に応じて、自動的に交換回数をリセットする
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - Page 6: 「アイテムの交換期間は1ヶ月毎で自動リセットになります。毎月初日の04:00にリセットされます」
  - APIで実現すべき内容:
    - リセット周期（NONE/DAILY/WEEKLY/MONTHLY）に基づいて、自動リセット判定を実行
    - リクエスト時判定方式を採用（バッチ処理ではなく、ユーザーが交換実行時に判定）
    - `last_reset_at`と現在時刻を比較し、期間経過判定を行う
    - リセット時は`exchange_count`を0にリセットし、`last_reset_at`を更新
  - 条件・制約:
    - reset_type=NONEの場合はリセットしない
    - reset_type=DAILYの場合、前日以前であればリセット
    - reset_type=WEEKLYの場合、前週以前であればリセット
    - reset_type=MONTHLYの場合、前月以前であればリセット
    - リセット判定は交換実行前に必ず実施
  - データ管理要件:
    - last_reset_atカラムで最終リセット日時を管理
  - 検証・チェック要件:
    - 現在時刻とlast_reset_atの比較による期間判定
- **既存実装との関連:**
  - 既存の`ShopService::resetUsrShopItem`メソッドのロジックを参考
  - `Clock`サービスの`isFirstToday`、`isFirstWeek`メソッドを使用
  - MONTHLYは新規実装が必要（`isFirstMonth`メソッドの追加）
- **備考:**
  - プランナー確認結果（Q3）により、リクエスト時判定方式が確定
  - プランナー確認結果（Q11）により、イベント交換所でも日次/週次リセットを設定可能

#### 要件 U-3: 交換回数上限の検証処理
- **要件ID:** REQ-U-3
- **概要:**
  - 交換実行前に、現在の交換回数とマスタで定義された上限回数を比較し、上限超過時はエラーを返す
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - Page 7: 「交換上限数が残っていない場合は、ボタンが『交換済み』という表示になりタップできなくなります」
  - APIで実現すべき内容:
    - 交換実行前に、`exchange_count`とマスタの`limit_count`を比較
    - `exchange_count >= limit_count`の場合は、`GameException`をスローしてエラーを返す
    - limit_countがNULLの場合は無制限として扱い、チェックをスキップ
  - 条件・制約:
    - 上限チェックはリセット判定の後に実施
    - クライアント側で事前チェックしていても、サーバー側で二重チェックが必須
  - データ管理要件:
    - 既存のusr_exchange_lineupとmst_exchange_lineupを使用
  - 検証・チェック要件:
    - 交換回数が上限に達している場合、エラーメッセージ「交換上限に達しています」を返す
- **既存実装との関連:**
  - 既存の`ShopService::validateTradeCount`メソッドのパターンを踏襲
- **備考:**
  - なし

#### 要件 U-4: 復刻時の交換所ID切り直しと履歴管理
- **要件ID:** REQ-U-4
- **概要:**
  - イベント交換所を復刻する際、新しい交換所IDを発番し、ユーザー交換履歴は新規作成される
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - Page 6: 「復刻時は交換所IDを新規で切り直して、設定を行います」
  - APIで実現すべき内容:
    - 復刻時は新しい交換所IDとラインナップIDを発番
    - 新しいラインナップIDに対するユーザー交換履歴は新規作成される
    - 旧交換所の履歴はそのまま保持される（削除されない）
  - 条件・制約:
    - ユーザー交換履歴のキーは(usr_user_id, mst_exchange_lineup_id)のため、新しいラインナップIDになれば自動的に新規レコードになる
    - 旧交換所の履歴は参照されないが、削除もしない
  - データ管理要件:
    - 既存のusr_exchange_lineupテーブルを使用
  - 検証・チェック要件:
    - 新旧のラインナップIDが異なることを確認
- **既存実装との関連:**
  - 新規実装（既存にないパターン）
- **備考:**
  - プランナー確認結果（Q4）により、新規ID発番と履歴の新規作成が確定

#### 要件 U-5: UsrModelManagerによるキャッシュ管理
- **要件ID:** REQ-U-5
- **概要:**
  - ユーザーごとの交換履歴データをUsrModelManagerでキャッシュ管理し、重複クエリを防ぐ
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - （明示的な記載なし、パフォーマンス要件として必要）
  - APIで実現すべき内容:
    - UsrExchangeLineupモデルに`makeModelKey`メソッドを実装
    - キーは`usr_user_id + mst_exchange_lineup_id`の連結文字列
    - UsrModelManagerを使用して、メモリ上でモデルをキャッシュ
  - 条件・制約:
    - キャッシュキーはDBスキーマのユニークキーと一致させる
  - データ管理要件:
    - UsrModelManagerの仕組みを利用
  - 検証・チェック要件:
    - キャッシュキーの一意性を保証
- **既存実装との関連:**
  - 既存の`UsrShopItem::makeModelKey`のパターンを踏襲
- **備考:**
  - パフォーマンス上必須の要件

### 3.3 交換処理・トランザクション

#### 要件 T-1: 交換実行のトランザクション管理
- **要件ID:** REQ-T-1
- **概要:**
  - 交換処理全体（コスト消費、報酬付与、カウント更新）を1つのトランザクションで実行し、原子性を保証する
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - （暗黙的に要求される、エラー時のロールバックが必要）
  - APIで実現すべき内容:
    - UseCaseで`applyUserTransactionChanges`を使用してトランザクション制御
    - トランザクション内で以下を実行:
      1. 複数コストの消費（ループ処理）
      2. 報酬配布実行（RewardDelegator経由）
      3. 交換回数のインクリメント（exchange_count, exchange_total_count）
      4. 交換ログの記録
    - エラー時は自動的にロールバック
  - 条件・制約:
    - トランザクション内の処理が全て成功するか、全て失敗するかのどちらか
    - 部分的な成功は許容しない
  - データ管理要件:
    - トランザクション制御はアプリケーション層で実施
  - 検証・チェック要件:
    - トランザクション内で例外が発生した場合、全ての変更がロールバックされることを確認
- **既存実装との関連:**
  - 既存の`ShopTradeShopItemUseCase`のトランザクション管理パターンを踏襲
  - `UseCaseTrait::applyUserTransactionChanges`メソッドを使用
- **備考:**
  - トランザクションの粒度は交換1回ごと

#### 要件 T-2: 複数リソースの同時消費処理
- **要件ID:** REQ-T-2
- **概要:**
  - 1回の交換で複数種類のリソース（コイン、アイテムなど）を順次消費する
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - Page 11: 「※ 複数リソース消費が必要なら + 3」
  - APIで実現すべき内容:
    - ラインナップに設定された全てのコストをループで順次消費
    - 各コストについて、所持数チェックと消費処理を実行
    - cost_type=COINの場合、`AppCurrencyDelegator`で消費
    - cost_type=ITEMの場合、`UsrItemService::consumeItem`で消費
  - 条件・制約:
    - 全てのコストについて所持数が十分であることを事前にチェック
    - 1つでも所持数が不足している場合、交換全体を拒否
  - データ管理要件:
    - mst_exchange_lineup_costテーブルから全コストを取得
  - 検証・チェック要件:
    - 各コストについて、所持数 >= 消費数 を確認
    - 不足している場合、どのリソースが不足しているかを明示
- **既存実装との関連:**
  - 既存の`ShopService::consumeCost`の拡張版として実装
  - 単一コストの消費処理を複数回実行するパターン
- **備考:**
  - プランナー確認結果（Q2）により、複数リソース消費の実装が確定

#### 要件 T-3: RewardDelegatorを経由した報酬配布
- **要件ID:** REQ-T-3
- **概要:**
  - 交換アイテムの付与はRewardDelegatorを経由して行い、既存の報酬配布システムと統合する
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - Page 7: 「アイテム、キャラ、原画、エンブレム、プリズム、コインをラインナップに設定することができます」
  - APIで実現すべき内容:
    - 交換対象のアイテムを`ExchangeLineupReward`（または類似のRewardクラス）として作成
    - `RewardDelegator::addReward`で報酬を追加
    - トランザクション内で`RewardDelegator::sendRewards`を実行して報酬を配布
  - 条件・制約:
    - RewardDelegatorを使用することで、上限チェック、所持数更新などが自動的に実施される
  - データ管理要件:
    - 報酬配布処理は既存のRewardDelegatorに委譲
  - 検証・チェック要件:
    - 報酬配布が正常に完了したことを確認
- **既存実装との関連:**
  - 既存の`ShopItemReward`のパターンを踏襲
  - `RewardDelegator`の既存機能を活用
- **備考:**
  - RewardDelegatorを使用することで、報酬配布ロジックの重複を防ぐ

#### 要件 T-4: まとめて交換（複数回交換）の対応
- **要件ID:** REQ-T-4
- **概要:**
  - ユーザーが指定した回数分、同じラインナップを連続して交換する
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - Page 7: 「交換可能上限数まで交換に必要なリソースを所持している場合は、まとめて交換できるようにします」
    - 「交換数は±1、±10、最大、最小で変更できます」
  - APIで実現すべき内容:
    - 交換リクエストに交換回数（amount）パラメータを受け取る
    - 指定された回数分、コストを消費し、報酬を配布
    - 交換回数は1回のトランザクションで一括処理
  - 条件・制約:
    - 交換回数が残り交換可能回数を超えている場合はエラー
    - 必要なリソースが不足している場合はエラー
    - 「最大」の計算はクライアント側で実施（サーバーは指定された回数をバリデーションするのみ）
  - データ管理要件:
    - 1回のトランザクションで複数回分の交換を処理
  - 検証・チェック要件:
    - 交換回数が正の整数であることを確認
    - 残り回数と所持数の両方をチェック
- **既存実装との関連:**
  - 既存のショップアイテム機能でもまとめて交換に対応
- **備考:**
  - プランナー確認結果（Q9）により、「最大」の計算はクライアント側で実施

### 3.4 リソース所持数検証

#### 要件 V-1: リソース所持数の事前チェック
- **要件ID:** REQ-V-1
- **概要:**
  - 交換に必要なリソース（コイン、アイテム等）をユーザーが十分に所持しているか、事前にチェックする
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - Page 7: 「交換に必要なリソース数が交換数に応じて足りている場合は黒数字ですが不足している場合は赤数字で表示されるようにします」
  - APIで実現すべき内容:
    - 交換実行前に、全てのコストについて所持数をチェック
    - `AppCurrencyDelegator`や`UsrItemService`の消費メソッド内で、所持数 >= 消費数 の検証が行われる
    - 不足している場合、`GameException`をスローして明確なエラーメッセージを返す
  - 条件・制約:
    - 複数コストの場合、全てのコストについてチェックを実施
    - 1つでも不足していれば交換全体を拒否
  - データ管理要件:
    - 既存のユーザーリソース管理テーブルを参照
  - 検証・チェック要件:
    - コイン不足の場合: 「コインが不足しています」
    - アイテム不足の場合: 「{アイテム名}が不足しています」
- **既存実装との関連:**
  - 既存の`AppCurrencyDelegator`、`UsrItemService`の検証機能を利用
- **備考:**
  - サーバー側でも二重チェックが必須（クライアント側のチェックは補助的）

#### 要件 V-2: 交換期間の有効性チェック
- **要件ID:** REQ-V-2
- **概要:**
  - 交換実行時に、ラインナップの交換期間が有効であることを検証する
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - Page 7: 「交換期限は、end_dateの設定内容を表示します」
  - APIで実現すべき内容:
    - 交換実行前に、現在時刻がラインナップの交換期間内であることを確認
    - マスタ取得時に`getActiveXxxById`メソッドを使用して有効期間チェックを実施
    - 期間外の場合、例外をスローして「交換期間外です」というエラーを返す
  - 条件・制約:
    - start_at <= 現在時刻 < end_at
    - start_atまたはend_atがNULLの場合は無期限として扱う
  - データ管理要件:
    - mst_exchange_lineupのstart_atとend_atを使用
  - 検証・チェック要件:
    - 現在時刻と交換期間の比較
- **既存実装との関連:**
  - 既存の`MstShopItemRepository::getActiveShopItemById`のパターンを踏襲
- **備考:**
  - マスタ取得時点でチェックすることで、無効なラインナップへのアクセスを防ぐ

### 3.5 ログ・監査証跡

#### 要件 L-1: 交換ログの記録と監査証跡
- **要件ID:** REQ-L-1
- **概要:**
  - 交換実行時に、誰が、いつ、何を、何個交換したかをログテーブルに記録する
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - （明示的な記載なし、運用上必須の要件）
  - APIで実現すべき内容:
    - 交換ログテーブル（log_trade_exchange_lineup）にレコードを作成
    - 各レコードには以下の情報を含める:
      - ユーザーID
      - ラインナップID
      - 交換回数（何回目の交換か）
      - 消費したコスト情報（JSON配列）
      - 配布された報酬情報（JSON配列）
      - 交換日時
  - 条件・制約:
    - ログ記録は交換トランザクション内で実施
    - ログ記録に失敗した場合、交換全体をロールバック
  - データ管理要件:
    - log_trade_exchange_lineupsテーブルを新規作成
    - インデックス: usr_user_id, mst_exchange_lineup_id, created_at
  - 検証・チェック要件:
    - ログレコードが正常に作成されたことを確認
- **既存実装との関連:**
  - 既存の`LogTradeShopItemRepository`のパターンを踏襲
- **備考:**
  - 不正防止、問い合わせ対応、データ分析のために必須

### 3.6 パフォーマンス・最適化

#### 要件 P-1: 交換所一覧・ラインナップ一覧のデータ取得最適化
- **要件ID:** REQ-P-1
- **概要:**
  - 交換所一覧画面では、全ての有効な交換所とラインナップを一括で取得し、N+1問題を回避する
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - （明示的な記載なし、パフォーマンス要件として必要）
  - APIで実現すべき内容:
    - 有効な交換所マスタを全件取得
    - 各交換所に属するラインナップを一括で取得（1クエリで取得）
    - ユーザー交換履歴を一括で取得し、ラインナップと突合
    - リセット判定も一括で行い、DBアクセスを最小化
  - 条件・制約:
    - 交換所ごとにクエリを発行しない（N+1問題を回避）
    - ラインナップごとにクエリを発行しない
  - データ管理要件:
    - 一括取得のためのリポジトリメソッドを実装
  - 検証・チェック要件:
    - SQLクエリの実行回数を確認し、N+1が発生していないことを検証
- **既存実装との関連:**
  - 既存の`ShopService::fetchResetActiveUsrShopItemsWithoutSyncModels`のパターンを踏襲
- **備考:**
  - ユーザー体験に直結する重要な要件

### 3.7 実装不要の機能（確定事項）

#### 要件 N-1: 初回無料・広告視聴機能は実装不要
- **要件ID:** REQ-N-1
- **概要:**
  - 交換所では、初回無料や広告視聴で交換できる機能は実装しない
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - （明示的な記載なし）
  - APIで実現すべき内容:
    - 実装不要
  - 条件・制約:
    - ラインナップマスタには`is_first_time_free`フラグや`cost_type=AD`のような設定は不要
  - データ管理要件:
    - 該当カラムを作成しない
  - 検証・チェック要件:
    - なし
- **既存実装との関連:**
  - 既存のショップアイテム機能には存在するが、交換所では不要
- **備考:**
  - プランナー確認結果（Q7）により、実装不要が確定

#### 要件 N-2: ミッション・クエストトリガーは実装不要
- **要件ID:** REQ-N-2
- **概要:**
  - 交換実行時にミッションやクエストのトリガーを発火する機能は実装しない
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - （明示的な記載なし）
  - APIで実現すべき内容:
    - 実装不要
  - 条件・制約:
    - `TradeExchangeItemLogTrigger`のようなトリガーは作成しない
  - データ管理要件:
    - なし
  - 検証・チェック要件:
    - なし
- **既存実装との関連:**
  - 既存のショップアイテム機能には存在するが、交換所では不要
- **備考:**
  - プランナー確認結果（Q12）により、実装不要が確定（将来的に必要になった場合は追加実装）

#### 要件 N-3: キャラのかけらBOX交換所は既存機能を利用
- **要件ID:** REQ-N-3
- **概要:**
  - キャラのかけらBOX交換所は、既存の`ItemExchangeSelectItemUseCase`の実装をそのまま利用する
- **詳細仕様:**
  - ゲーム体験仕様書の記載:
    - Page 6: 「現状アイテムBOX内にあるキャラのかけらをかけらBOXに交換する交換所になりますが、それをそのままここに持ってきたものになります」
  - APIで実現すべき内容:
    - 新規実装不要
    - 交換所一覧画面から既存のキャラのかけらBOX交換画面への遷移リンクを提供するのみ
  - 条件・制約:
    - サーバー側での新規実装は不要
  - データ管理要件:
    - 既存テーブルをそのまま利用
  - 検証・チェック要件:
    - なし
- **既存実装との関連:**
  - 既存の`ItemExchangeSelectItemUseCase`をそのまま利用
- **備考:**
  - プランナー確認結果（Q5）により、既存実装の利用が確定

## 4. 要件間の依存関係

### 4.1 前提となる要件

- 要件 M-2（ラインナップマスタ）は 要件 M-1（交換所マスタ）が実現されていることを前提とする
  - ラインナップは交換所に属するため、交換所マスタが存在する必要がある

- 要件 U-1（交換履歴の永続化）は 要件 M-2（ラインナップマスタ）が実現されていることを前提とする
  - 交換履歴はラインナップIDをキーとして管理するため

- 要件 T-1（トランザクション管理）は 要件 T-2（複数リソース消費）と 要件 T-3（報酬配布）が実現されていることを前提とする
  - トランザクション内でコスト消費と報酬配布を実行するため

### 4.2 同時に実現すべき要件

- 要件 M-3（複数リソース消費）と 要件 T-2（複数リソース消費処理）は同時に実現される必要がある
  - マスタデータの設計と実行ロジックが連動している

- 要件 U-2（リセット処理）と 要件 U-3（上限検証）は同時に実現される必要がある
  - リセット後の交換回数を使って上限チェックを行うため

## 5. 非機能要件

### 5.1 パフォーマンス要件

- 交換所一覧取得APIのレスポンスタイム: 1秒以内
  - N+1問題を回避し、一括取得で実現（要件 P-1）

- 交換実行APIのレスポンスタイム: 1秒以内
  - トランザクション処理を含むが、十分な速度を保つ

- 同時接続数: 既存のショップアイテム機能と同等の性能を保つ
  - UsrModelManagerによるキャッシュ管理で重複クエリを削減（要件 U-5）

### 5.2 セキュリティ要件

- リソース所持数の不正操作防止:
  - サーバー側で必ず所持数チェックを実施（要件 V-1）
  - クライアント側のチェックは補助的なものとし、サーバー側を信頼する

- 交換上限の不正突破防止:
  - サーバー側で交換回数と上限を検証（要件 U-3）

- トランザクションの原子性保証:
  - コスト消費と報酬配布を1つのトランザクションで実行（要件 T-1）

- 監査証跡の記録:
  - 全ての交換実行をログに記録（要件 L-1）

### 5.3 可用性要件

- エラーハンドリング:
  - トランザクション内でエラーが発生した場合、自動的にロールバック（要件 T-1）
  - ユーザーに分かりやすいエラーメッセージを返す

- データ整合性:
  - 交換回数、所持数、交換ログの整合性を保つ

### 5.4 その他の非機能要件

- ログ記録:
  - 全ての交換実行をログテーブルに記録（要件 L-1）
  - 運用時の問い合わせ対応、不正検知に活用

- 拡張性:
  - 将来的にミッション連携が必要になった場合、トリガーを追加できる設計にする
  - 新しいリソースタイプが追加された場合も対応可能にする

## 6. データ要件

### 6.1 永続化が必要なデータ

- **交換所マスタ（mst_exchanges）**:
  - 内容: 交換所の基本情報（ID、名前、カテゴリー、開催期間、バナーURL等）
  - 用途: 交換所一覧の表示、交換所の有効性判定
  - 保持期間: 永久
  - 関連要件: REQ-M-1

- **ラインナップマスタ（mst_exchange_lineups）**:
  - 内容: 各ラインナップの詳細情報（ID、交換アイテム、交換期間、上限数、リセット周期等）
  - 用途: ラインナップ一覧の表示、交換処理の実行
  - 保持期間: 永久
  - 関連要件: REQ-M-2

- **ラインナップコストマスタ（mst_exchange_lineup_costs）**:
  - 内容: 各ラインナップの必要コスト情報（コスト種別、ID、個数）
  - 用途: 交換時のコスト消費処理
  - 保持期間: 永久
  - 関連要件: REQ-M-3

- **ユーザー交換履歴（usr_exchange_lineup）**:
  - 内容: ユーザーごとの交換回数と最終リセット日時
  - 用途: 交換上限の管理、リセット判定
  - 保持期間: 永久
  - 関連要件: REQ-U-1, REQ-U-2, REQ-U-3

- **交換ログ（log_trade_exchange_lineup）**:
  - 内容: 交換実行の詳細ログ（ユーザーID、ラインナップID、コスト、報酬、日時）
  - 用途: 監査証跡、問い合わせ対応、データ分析
  - 保持期間: 永久（または運用ポリシーに従って定期削除）
  - 関連要件: REQ-L-1

### 6.2 一時的に管理が必要なデータ

- **UsrModelManagerによるキャッシュ**:
  - 内容: リクエスト処理中のユーザー交換履歴データ
  - 用途: 重複クエリの削減、パフォーマンス向上
  - 保持期間: リクエスト処理中のみ（メモリ上）
  - 関連要件: REQ-U-5

## 7. 外部システム連携要件

### 7.1 クライアント連携

- **交換所一覧データの送信**:
  - 有効な交換所とラインナップの一覧をクライアントに送信
  - 開催期間の残り時間情報を含める
  - ユーザーの交換履歴と残り回数を含める

- **交換実行結果の送信**:
  - 交換後の所持数、残り回数を返却
  - 原画交換の場合、演出フラグを返却

### 7.2 他API機能との連携

- **報酬配布システムとの連携**:
  - RewardDelegatorを経由して報酬を配布（要件 T-3）
  - 既存の報酬配布ロジック（上限チェック、所持数更新等）を活用

- **リソース管理システムとの連携**:
  - AppCurrencyDelegator、UsrItemServiceを使用してコストを消費（要件 T-2）
  - 既存のリソース管理機能と統合

- **キャラのかけらBOX交換所との連携**:
  - 既存の`ItemExchangeSelectItemUseCase`への遷移を提供（要件 N-3）

### 7.3 外部サービス連携

- **お知らせ・IGNとの連携**:
  - お知らせやIGNから特定の交換所に直接遷移できるようにする（要件 M-5）
  - 交換所IDをパラメータとして受け取り、該当する交換所を表示

## 8. 残存する不明点・要確認事項

### 8.1 まだ不明な仕様

- **なし（全ての不明点が解決済み）**

### 8.2 実装時に判断が必要な事項

- **複数リソース消費のマスタ設計方法**:
  - 何が不明か: 別テーブル方式とJSON配列方式のどちらを採用するか
  - 実装への影響: DB設計とマイグレーションの方針
  - 確認すべき相手: 技術リーダー
  - 推奨: 別テーブル方式（mst_exchange_lineup_cost）が管理しやすい

- **月次リセットの判定メソッド**:
  - 何が不明か: Clock serviceに`isFirstMonth`メソッドが存在するか
  - 実装への影響: 新規実装が必要かどうか
  - 確認すべき相手: 既存コードの調査
  - 推奨: 既存の`isFirstToday`、`isFirstWeek`のパターンに従って実装

- **交換所一覧取得APIのエンドポイント設計**:
  - 何が不明か: 1つのエンドポイントで全交換所を返すか、カテゴリー別に分けるか
  - 実装への影響: API設計の方針
  - 確認すべき相手: クライアント開発者
  - 推奨: 1つのエンドポイントで全交換所を返し、クライアント側でカテゴリーを振り分ける

## 9. 要件確定度の評価

### 9.1 全体評価

- **要件の確定度: 100%**
- **API実装に必要な要件情報の充足度: 十分**
- **実装開始の可否: 可**

### 9.2 カテゴリ別評価

- **マスタデータ参照・管理: 100%確定**
  - 交換所マスタの階層構造が確定
  - 複数リソース消費の実装が確定
  - 実装準備状況: DB設計とマイグレーションに着手可能

- **ユーザーデータ管理（交換履歴）: 100%確定**
  - リセット周期の実装方式が確定（リクエスト時判定）
  - 復刻時の履歴管理が確定
  - 実装準備状況: テーブル設計とリセットロジックの実装に着手可能

- **交換処理・トランザクション: 100%確定**
  - トランザクション管理の方針が確定
  - 複数リソース消費の処理が確定
  - 実装準備状況: UseCase実装に着手可能

- **リソース所持数検証: 100%確定**
  - バリデーションロジックが明確
  - 実装準備状況: 既存のパターンを踏襲して実装可能

- **ログ・監査証跡: 100%確定**
  - ログ記録の内容が明確
  - 実装準備状況: ログテーブル設計に着手可能

- **パフォーマンス・最適化: 100%確定**
  - N+1問題回避の方針が確定
  - 実装準備状況: 一括取得ロジックの実装に着手可能

- **実装不要の機能: 100%確定**
  - 初回無料、広告視聴、ミッション連携が不要と確定
  - 実装準備状況: 工数削減につながる

## 10. 次のステップ

### 10.1 要件確定のために必要なアクション

- [x] ゲーム体験仕様の確認完了
- [x] サーバー実装に必要な仕様の確定
- [x] プランナーへの確認項目（Q1〜Q12）の解決

### 10.2 実装設計へ向けて

- [ ] **次のステージ（Stage 6: API実装全体概要設計）に進む**
- [ ] DB設計の詳細化:
  - mst_exchanges（交換所マスタ）
  - mst_exchange_lineups（ラインナップマスタ）
  - mst_exchange_lineup_costs（ラインナップコストマスタ）
  - usr_exchange_lineups（ユーザー交換履歴）
  - log_trade_exchange_lineups（交換ログ）
- [ ] APIエンドポイント設計:
  - GET /exchanges（交換所一覧取得）
  - GET /exchanges/{id}（特定交換所取得）
  - POST /exchanges/lineups/{lineupId}/trade（交換実行）
- [ ] ドメイン層の設計:
  - ExchangeEntity
  - ExchangeLineupEntity
  - UsrExchangeLineup
  - ExchangeService
  - ExchangeLineupService
  - ExchangeTradeUseCase
- [ ] 技術選定:
  - 複数リソース消費のマスタ管理方法（別テーブル推奨）
  - 月次リセットの判定ロジック（Clock::isFirstMonth実装）

---

## まとめ

全ての確認項目（12項目）について、プランナーからの明確な回答が得られ、サーバー実装に必要な仕様が100%確定しました。

**重要な確定事項:**
1. 交換所マスタを独立して管理する（階層構造）
2. 複数リソース消費を実装する（+3人日）
3. 月次リセットはリクエスト時判定方式を採用
4. 復刻時は新規IDを発番し、履歴は新規作成される
5. 初回無料・広告視聴・ミッション連携は実装しない（工数削減）
6. キャラのかけらBOX交換所は既存機能を利用（新規実装不要）

**次のステップ:**
本要件書を基に、Stage 6（API実装全体概要設計）、Stage 7（サーバーAPI設計書作成）、Stage 8（サーバーAPI機能要件実装設計）に進み、具体的なAPI設計とDB設計を詳細化します。
