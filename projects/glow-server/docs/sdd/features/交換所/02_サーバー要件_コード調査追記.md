# サーバー要件（コード調査による追加・補足）：交換所

## サーバー要件（コード調査による追加・補足）

### 要件C-1: ユーザーごとの交換履歴管理の永続化
- 種別: コードから判明した追加要件
- 関連機能: 交換所 / ショップアイテム交換
- 関連ファイル:
  - `api/app/Domain/Shop/Models/UsrShopItem.php`
  - `api/app/Domain/Shop/Repositories/UsrShopItemRepository.php`
- 内容の要約:
  - ユーザーごとの交換回数と最終リセット日時をDBで永続管理する必要がある
- 詳細:
  - 既存のショップアイテム機能では、`usr_shop_item`テーブルで以下を管理している
    - `trade_count`: 現在期間内の交換回数
    - `trade_total_count`: 累計交換回数
    - `last_reset_at`: 最終リセット日時
  - これにより、日次・週次・月次などのリセット周期に対応している
  - 交換所でも同様のテーブル構造が必要となる
- 元になったコードの抜粋:
  ```php
  // UsrShopItem.php
  protected $fillable = [
      'usr_user_id',
      'id',
      'mst_shop_item_id',
      'trade_count',
      'trade_total_count',
      'last_reset_at',
  ];
  ```
- 備考:
  - 仕様書では「ユーザーごとで可変式で交換した数が反映される」と記載されているが、DBスキーマとして具体的にどう管理するかは明示されていない

### 要件C-2: 交換回数のリセット周期による自動リセット処理
- 種別: コードから判明した追加要件
- 関連機能: 交換所 / デイリー・ウィークリーリセット
- 関連ファイル:
  - `api/app/Domain/Shop/Services/ShopService.php` の `resetUsrShopItem`メソッド
- 内容の要約:
  - 交換所の種類（デイリー、ウィークリー、月次等）に応じて、自動的に交換回数をリセットする処理が必要
- 詳細:
  - 既存のショップアイテム機能では、`ShopType`（DAILY, WEEKLY, COIN等）に基づいて自動リセットを実装している
  - `resetUsrShopItem`メソッドで、`last_reset_at`と現在時刻を比較し、期間経過判定を行っている
  - リセット時は`trade_count`を0にリセットし、`last_reset_at`を更新する
  - 交換所でも、通常交換所（月次リセット）、イベント交換所（期間限定）などの種類に応じた自動リセット処理が必要
- 元になったコードの抜粋:
  ```php
  public function resetUsrShopItem(
      UsrShopItemInterface $usrShopItem,
      MstShopItemEntity $mstShopItem,
      CarbonImmutable $now
  ): bool {
      $shopType = $mstShopItem->getShopType();
      if ($shopType === ShopType::DAILY->value) {
          if ($this->clock->isFirstToday($usrShopItem->getLastResetAt())) {
              $usrShopItem->reset($now);
              return true;
          }
      } elseif ($shopType === ShopType::WEEKLY->value) {
          if ($this->clock->isFirstWeek($usrShopItem->getLastResetAt())) {
              $usrShopItem->reset($now);
              return true;
          }
      }
      return false;
  }
  ```
- 備考:
  - 仕様書では「毎月初日の04:00にリセット」と記載されているが、コード上でどのように実装するか（バッチ処理 or リクエスト時判定）は明示されていない

### 要件C-3: 交換回数上限の検証処理
- 種別: コードから判明した追加要件
- 関連機能: 交換所 / 交換上限チェック
- 関連ファイル:
  - `api/app/Domain/Shop/Services/ShopService.php` の `tradeShopItem`メソッド
  - `api/app/Domain/Shop/Services/ShopService.php` の `validateTradeCount`メソッド（参照）
- 内容の要約:
  - 交換実行前に、現在の交換回数とマスタで定義された上限回数を比較し、上限超過時はエラーを返す必要がある
- 詳細:
  - 既存のショップアイテム機能では、`validateTradeCount`メソッドで交換回数の上限検証を実施している
  - 交換回数が上限に達している場合、`GameException`をスローする
  - 交換所でも同様の検証ロジックが必要
- 元になったコードの抜粋:
  ```php
  public function tradeShopItem(
      CurrentUser $user,
      MstShopItemEntity $mstShopItem,
      UsrShopItemInterface $usrShopItem,
      CarbonImmutable $now
  ): void {
      // リセットの必要があれば実行
      $this->resetUsrShopItem($usrShopItem, $mstShopItem, $now);

      // 交換回数の検証
      $this->validateTradeCount($mstShopItem->getTradableCount(), $usrShopItem->getTradeCount());

      // ...
  }
  ```
- 備考:
  - 仕様書では「交換上限数が残っていない場合は、ボタンが『交換済み』という表示になりタップできなくなる」と記載されているが、サーバー側でも二重チェックが必要

### 要件C-4: 初回無料および特定コストタイプの特殊処理
- 種別: コードから判明した追加要件
- 関連機能: 交換所 / コスト消費処理
- 関連ファイル:
  - `api/app/Domain/Shop/Services/ShopService.php` の `consumeCost`メソッド
- 内容の要約:
  - 交換回数が1回目で「初回無料」設定の場合、コスト消費をスキップする処理が必要
- 詳細:
  - 既存のショップアイテム機能では、`isFirstTimeFree()`フラグと`tradeCount`を組み合わせて初回無料判定を行っている
  - `costType`が`FREE`または`AD`（広告視聴）の場合もコスト消費をスキップする
  - 交換所でも、初回無料や広告視聴で交換可能なラインナップが想定される
- 元になったコードの抜粋:
  ```php
  public function consumeCost(
      string $usrUserId,
      int $tradeCount,
      MstShopItemEntity $mstShopItem,
      // ...
  ): void {
      if ($tradeCount === 1 && $mstShopItem->isFirstTimeFree()) {
          // 初回無料の場合はコスト消費なし
          return;
      }

      $costType = $mstShopItem->getCostType();
      if ($costType === ShopItemCostType::FREE->value) {
          // 無料の場合はコスト消費しない
          return;
      }
      if ($costType === ShopItemCostType::AD->value) {
          // 広告の場合はコスト消費しない
          return;
      }
      // ...
  }
  ```
- 備考:
  - 仕様書には初回無料や広告視聴による交換の記載がないが、将来的な拡張性として考慮すべき要件

### 要件C-5: 交換ログの記録と監査証跡
- 種別: コードから判明した追加要件
- 関連機能: 交換所 / ログ記録
- 関連ファイル:
  - `api/app/Domain/Shop/Repositories/LogTradeShopItemRepository.php`
  - `api/app/Domain/Shop/Services/ShopService.php` の `tradeShopItem`メソッド
- 内容の要約:
  - 交換実行時に、誰が、いつ、何を、何個交換したかをログテーブルに記録する必要がある
- 詳細:
  - 既存のショップアイテム機能では、`log_trade_shop_items`テーブルに以下の情報を記録している
    - ユーザーID
    - 商品ID
    - 交換回数（何回目の交換か）
    - コストタイプとコスト数
    - 配布された報酬情報
  - 交換所でも同様のログ記録が必要（不正防止、問い合わせ対応、データ分析のため）
- 元になったコードの抜粋:
  ```php
  // 交換ログの保存
  $this->logTradeShopItemRepository->create(
      $user->id,
      $mstShopItem->getId(),
      $usrShopItem->getTradeCount(),
      $mstShopItem->getCostType(),
      $mstShopItem->getCostAmount(),
      $this->rewardDelegator->getSentRewards(ShopItemReward::class),
  );
  ```
- 備考:
  - 仕様書にはログ記録についての明示的な記載がないが、運用上必須の要件

### 要件C-6: 報酬配布処理との連携
- 種別: コードから判明した追加要件
- 関連機能: 交換所 / 報酬配布システム
- 関連ファイル:
  - `api/app/Domain/Reward/Delegators/RewardDelegator.php`
  - `api/app/Domain/Shop/Services/ShopService.php` の `tradeShopItem`メソッド
- 内容の要約:
  - 交換アイテムの付与は、RewardDelegatorを経由して行う必要がある
- 詳細:
  - 既存のショップアイテム機能では、交換対象のアイテムを`ShopItemReward`として`RewardDelegator`に追加し、一括で配布している
  - RewardDelegatorは、アイテム、コイン、キャラ、原画など多様なリソースタイプに対応している
  - 交換所でも、`RewardDelegator`経由で交換アイテムを配布することで、既存の報酬配布ロジック（上限チェック、所持数更新、ミッショントリガー等）を活用できる
- 元になったコードの抜粋:
  ```php
  // 交換物の付与
  $reward = new ShopItemReward(
      $resourceType,
      $mstShopItem->getResourceId(),
      $resourceAmount,
      $mstShopItem->getId(),
  );
  $this->rewardDelegator->addReward($reward);

  // ...トランザクション内で...
  $this->rewardDelegator->sendRewards($user->id, $platform, $now);
  ```
- 備考:
  - 仕様書には「アイテム、キャラ、原画、エンブレム、プリズム、コインをラインナップに設定できる」と記載されているが、具体的な配布方法は明示されていない

### 要件C-7: UseCaseレベルでのトランザクション管理
- 種別: コードから判明した追加要件
- 関連機能: 交換所 / トランザクション処理
- 関連ファイル:
  - `api/app/Domain/Shop/UseCases/ShopTradeShopItemUseCase.php`
  - `api/app/Domain/Common/Traits/UseCaseTrait.php` の `applyUserTransactionChanges`メソッド
- 内容の要約:
  - 交換処理全体（コスト消費、報酬付与、カウント更新）を1つのトランザクションで実行する必要がある
- 詳細:
  - 既存のショップアイテム機能では、UseCaseで`applyUserTransactionChanges`を使用してトランザクション制御を行っている
  - トランザクション内で、コスト消費と報酬配布を原子性を保って実行している
  - エラー時は自動的にロールバックされる
- 元になったコードの抜粋:
  ```php
  $this->applyUserTransactionChanges(function () use (
      $usrUserId,
      $mstShopItem,
      $usrShopItem,
      $platform,
      $billingPlatform,
      $now,
  ) {
      // コスト消費
      $this->shopService->consumeCost(/* ... */);

      // 報酬配布実行
      $this->rewardDelegator->sendRewards($usrUserId, $platform, $now);
  });
  ```
- 備考:
  - 仕様書では「エラー時のロールバック処理が必要」と記載されているが、具体的な実装方法は明示されていない

### 要件C-8: アイテム選択型交換の実装パターン
- 種別: コードから判明した追加要件
- 関連機能: 交換所 / キャラのかけらBOX交換所
- 関連ファイル:
  - `api/app/Domain/Item/UseCases/ItemExchangeSelectItemUseCase.php`
  - `api/app/Domain/Item/Services/ItemService.php` の `applyWithSelectItem`メソッド
- 内容の要約:
  - キャラのかけらBOX交換所のように、「特定のアイテムを消費して、複数の選択肢から1つを選んで交換する」パターンが存在する
- 詳細:
  - 既存のアイテムBOX機能では、`ItemExchangeSelectItemUseCase`で以下の処理を実装している
    1. 消費するアイテム（かけらBOX）のマスタ取得
    2. 選択された交換先アイテムのマスタ取得
    3. アイテム種別ごとの効果反映（`applyWithSelectItem`）
    4. コストの消費（かけらBOXを減らす）
    5. 報酬配布実行（選択されたかけらを付与）
  - 交換所のキャラのかけらBOX交換所でも、同様の選択型交換ロジックが必要
- 元になったコードの抜粋:
  ```php
  public function exec(
      CurrentUser $user,
      int $platform,
      string $mstItemId,        // 消費するアイテムID（かけらBOX）
      string $selectMstItemId,  // 選択されたアイテムID（特定キャラのかけら）
      int $amount
  ): ItemExchangeSelectItemResultData {
      // アイテム種別ごとの効果反映
      $this->itemService->applyWithSelectItem($user->id, $platform, $mstItem, $selectMstItem, $amount, $now);

      // コストの消費
      $this->usrItemService->consumeItem(/* ... */);

      // 報酬配布実行
      $this->rewardDelegator->sendRewards($user->id, $platform, $now);
  }
  ```
- 備考:
  - 仕様書には「キャラのかけらBOX交換所は現状のものをそのまま持ってくる」と記載されているが、交換所の枠組み内での実装方法は明示されていない

### 要件C-9: 放置BOXアイテムの変換処理
- 種別: コードから判明した追加要件
- 関連機能: 交換所 / 放置収益連動報酬
- 関連ファイル:
  - `api/app/Domain/Item/Services/ItemIdleBoxService.php`
  - `api/app/Domain/Shop/Services/ShopService.php` の `tradeShopItem`メソッド
- 内容の要約:
  - 放置BOXアイテムのように、「消費時に放置時間に応じた実際の報酬量を動的に計算する」特殊なアイテムタイプが存在する
- 詳細:
  - 既存のアイテム機能では、`ItemIdleBoxService`で放置BOXアイテムを実際の報酬（コインやランクアップ素材）に変換している
  - 放置時間（分）を計算し、`IdleIncentiveDelegator`で実際の報酬量を算出する
  - 交換所でも、放置収益連動のアイテムをラインナップに設定する場合、同様の変換処理が必要
- 元になったコードの抜粋:
  ```php
  // ShopService.php
  if ($resourceType === ShopConstant::IDLE_INCENTIVE_COIN_RESOURCE_TYPE) {
      // 放置収益連動コインの場合はタイプをコインに置き換える
      $resourceType = $this->convertToRealResourceType($resourceType);
      // resourceAmountに放置収益の放置時間(h)が入っているので分換算して獲得コインを計算
      $idleMinutes = $resourceAmount * 60;
      $idleMinutesCoinAmountMap = $this->idleIncentiveDelegator->calcCoinRewardAmounts(
          $user->id,
          collect([$idleMinutes]),
          $now,
      );
      $resourceAmount = $idleMinutesCoinAmountMap->get($idleMinutes) ?? 0;
  }
  ```
- 備考:
  - 仕様書には放置収益連動アイテムについての記載がないが、既存機能との整合性を考慮すると対応が必要

### 要件C-10: マスタデータの有効期間チェック
- 種別: コードから判明した追加要件
- 関連機能: 交換所 / マスタデータ管理
- 関連ファイル:
  - `api/app/Domain/Resource/Mst/Repositories/MstShopItemRepository.php` の `getActiveShopItemById`メソッド
  - `api/app/Domain/Resource/Mst/Repositories/MstItemRepository.php` の `getActiveItemById`メソッド
- 内容の要約:
  - 交換所マスタやラインナップマスタの取得時に、現在時刻がマスタの有効期間内であることを検証する必要がある
- 詳細:
  - 既存のマスタリポジトリでは、`getActiveXxxById`メソッドで有効期間チェックを実施している
  - マスタデータに`start_at`と`end_at`カラムがあり、現在時刻がその範囲内にあるかを確認する
  - 無効なマスタを参照した場合は例外をスローする
- 元になったコードの抜粋:
  ```php
  $mstShopItem = $this->mstShopItemRepository->getActiveShopItemById($mstShopItemId, $now, true);
  ```
- 備考:
  - 仕様書では「交換期間（start_date/end_date）」と記載されているが、マスタデータレベルでの有効期間管理も必要

### 要件C-11: UsrModelManagerによるキャッシュ管理
- 種別: コードから判明した追加要件
- 関連機能: 交換所 / ユーザーデータキャッシュ
- 関連ファイル:
  - `api/app/Domain/Shop/Models/UsrShopItem.php` の `makeModelKey`メソッド
  - `api/app/Domain/Resource/Usr/Services/UsrModelManager.php`
- 内容の要約:
  - ユーザーごとの交換履歴データは、UsrModelManagerでキャッシュ管理される必要がある
- 詳細:
  - 既存のUsrモデルでは、`makeModelKey`メソッドでユニークキーを定義している
  - UsrModelManagerは、このキーを使ってメモリ上でモデルをキャッシュし、重複クエリを防いでいる
  - 交換所のUsrモデルでも、`usr_user_id + mst_exchange_item_id`などのキーでキャッシュ管理が必要
- 元になったコードの抜粋:
  ```php
  public function makeModelKey(): string
  {
      // UsrModelManagerのキャッシュ管理キーで、DBスキーマのユニークキーを使う
      return $this->usr_user_id . $this->mst_shop_item_id;
  }
  ```
- 備考:
  - 仕様書にはキャッシュ管理についての記載がないが、パフォーマンス上必須の要件

### 要件C-12: 複数リソースの同時消費処理
- 種別: 仕様書要件の補足
- 関連機能: 交換所 / コスト消費
- 関連ファイル:
  - `api/app/Domain/Shop/Services/ShopService.php` の `consumeCost`メソッド
- 内容の要約:
  - 現状のショップアイテム機能では1種類のコストしか消費できないが、交換所では複数種類のリソースを同時に消費する可能性がある
- 詳細:
  - 既存実装では、`costType`と`costAmount`が単一の値として定義されている
  - 仕様書の「工数」セクションで「複数リソース消費が必要なら +3」と記載されているため、将来的な拡張として複数コストの同時消費が想定される
  - 実装する場合、コストをJSON配列や別テーブルで管理し、ループで順次消費する必要がある
- 備考:
  - 仕様書では「複数リソース消費への対応可能性」として記載されているが、具体的な実装方法は明示されていない

### 要件C-13: ミッション・クエストトリガーの発火
- 種別: コードから判明した追加要件
- 関連機能: 交換所 / ミッション連携
- 関連ファイル:
  - `api/app/Domain/Resource/Entities/LogTriggers/TradeShopItemLogTrigger.php`
  - `api/app/Domain/Resource/Entities/CurrencyTriggers/TradeShopItemTrigger.php`
- 内容の要約:
  - 交換実行時に、ミッションやクエストの達成条件判定のためのトリガーを発火する必要がある
- 詳細:
  - 既存のショップアイテム機能では、交換時に`TradeShopItemLogTrigger`を使用してログを記録している
  - これにより、「ショップでアイテムを交換する」というミッション条件の判定が可能になる
  - 交換所でも、同様のトリガー（`TradeExchangeItemLogTrigger`など）が必要
- 元になったコードの抜粋:
  ```php
  $this->usrItemService->consumeItem(
      $user->id,
      $mstItem->getId(),
      $amount,
      new ItemFragmentBoxLogTrigger($mstItem),  // トリガー
  );
  ```
- 備考:
  - 仕様書にはミッション連携についての記載がないが、ゲーム設計上重要な要件

### 要件C-14: リソース所持数の事前チェック
- 種別: コードから判明した追加要件
- 関連機能: 交換所 / バリデーション
- 関連ファイル:
  - `api/app/Domain/Currency/Delegators/AppCurrencyDelegator.php`
  - `api/app/Domain/Item/Services/UsrItemService.php`
- 内容の要約:
  - 交換に必要なリソース（コイン、アイテム等）をユーザーが十分に所持しているか、事前にチェックする必要がある
- 詳細:
  - 既存の実装では、コスト消費時に所持数が不足していると`GameException`がスローされる
  - `AppCurrencyDelegator`や`UsrItemService`の消費メソッド内で、所持数 >= 消費数 の検証が行われる
  - 交換所でも、同様の事前チェックと明確なエラーメッセージが必要
- 備考:
  - 仕様書では「不足している場合は赤数字で表示される」と記載されているが、サーバー側でも検証が必須

### 要件C-15: 交換所一覧画面のデータ取得最適化
- 種別: コードから判明した追加要件
- 関連機能: 交換所 / 一覧画面API
- 関連ファイル:
  - `api/app/Domain/Shop/Services/ShopService.php` の `fetchResetActiveUsrShopItemsWithoutSyncModels`メソッド
- 内容の要約:
  - 交換所一覧画面では、全ての有効な交換所とラインナップを一括で取得し、N+1問題を回避する必要がある
- 詳細:
  - 既存のショップアイテム機能では、有効なマスタデータを全件取得し、ユーザーデータと突合している
  - リセット判定も一括で行い、DBアクセスを最小化している
  - 交換所でも、複数の交換所とその配下のラインナップを効率的に取得するAPIが必要
- 元になったコードの抜粋:
  ```php
  public function fetchResetActiveUsrShopItemsWithoutSyncModels(
      string $usrUserId,
      CarbonImmutable $now
  ): Collection {
      $mstShopItems = $this->mstShopItemRepository->getActiveShopItems($now)
          ->keyBy(fn(MstShopItemEntity $mstShopItem) => $mstShopItem->getId());
      $usrShopItems = $this->usrShopItemRepository->getByMstShopItemIds(/* ... */);

      foreach ($usrShopItems as $usrShopItem) {
          $this->resetUsrShopItem($usrShopItem, $mstShopItem, $now);
      }

      return $usrShopItems;
  }
  ```
- 備考:
  - 仕様書にはパフォーマンスに関する記載がないが、ユーザー体験に直結する重要な要件
