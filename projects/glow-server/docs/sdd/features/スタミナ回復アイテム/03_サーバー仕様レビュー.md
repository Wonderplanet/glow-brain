# サーバー実装観点の仕様レビュー（自動分析レポート）

## ドキュメント情報
- **対象機能**: スタミナ回復アイテム
- **レビュー日**: 2025-11-27
- **ステータス**: 初版（更新版）
- **レビュアー**: サーバー仕様レビュー自動分析

---

## 1. 要約

### 現時点での仕様の明瞭さ/不明瞭さの総評

**明確な部分**:
- 基本コンセプト（スタミナ上限値の半分を回復するアイテム）は明瞭
- 既存のスタミナ管理・アイテム管理システムが体系的に整備されており、実装パターンが確立されている
- 報酬配布システム（RewardDelegator）、アイテム使用API（/api/item/consume）など、必要な基盤は既に存在

**不明瞭な部分**:
- **スタミナ満タン時の使用可否**（既存の購入機能とは挙動が異なる可能性）
- **複数個使用時のUI/UX仕様**（一括使用の可否、上限超過時の制御方法）
- **ItemType定義の方針**（新規種別追加 vs 既存Etc種別の利用）

### 大きなリスク・不確定要素の概要

1. **ゲーム体験上の境界条件が未定義**
   - スタミナ満タン時のアイテム使用可否は、ユーザー体験に大きく影響するが仕様書に記載なし
   - 複数個使用時の挙動（上限超過時の処理）がUI設計に直結するが未確定

2. **既存実装との一貫性**
   - 既存のスタミナ購入機能（広告/プリズム）は満タン時エラーだが、アイテム使用で同じ制約にするか不明
   - ItemType定義の拡張方針が定まっていない

3. **実装範囲の不確定性**
   - 使用回数制限の有無が不明（仕様書に記載なし、実装する場合は影響範囲が拡大）
   - 自動選択機能の実装要否が不明（UI側実装の可能性あり）

**リスク評価**: 中程度
- 既存パターンの組み合わせで実装可能だが、ゲーム体験に関わる細部が未確定
- プランナー確認なしで実装を進めると、後戻りや手戻りのリスクあり

---

## 2. 仕様の詳細化（サーバー観点）

### 2.1 スタミナ回復アイテムの基本仕様

#### 2.1.1 回復量の計算

**計算式**:
```
回復量 = floor(スタミナ上限値 × 50 / 100)
```

**スタミナ上限値の構成**:
```php
スタミナ上限値 = レベル別スタミナ上限 + ショップパス効果による追加上限
```

**既存実装パターン**:
- UserBuyStaminaService::calcAddStamina() のロジックを流用
- 広告視聴スタミナ購入と同じ50%回復率

**システム制約**:
- システム絶対上限: 999（UserConstant::MAX_STAMINA）
- 回復後のスタミナ値が999を超える場合の挙動は未確定

#### 2.1.2 自然回復の適用タイミング

**処理順序**:
1. 自然回復を先に適用（UserService::recoveryStamina()）
2. 最新のスタミナ値を取得
3. アイテムによる回復を適用

**既存実装パターン**:
- UserBuyStaminaService::calcAddStamina() と同じフロー
- スタミナ関連処理の標準パターン

**自然回復の計算**:
- 3分で1回復（RECOVERY_STAMINA_MINUTE = 3）
- 自然回復はスタミナ上限値で打ち切り

### 2.2 アイテム管理仕様

#### 2.2.1 ItemType定義

**現状**:
- スタミナ回復アイテムの種別は未定義
- 既存のItemType Enumにはスタミナ回復用の種別が存在しない

**選択肢**:
- **案A**: 新規ItemType `StaminaRecovery` を追加（拡張性高い、スキーマ変更必要）
- **案B**: 既存の `Etc` 種別を使用（実装容易、種別判定が曖昧）

**影響範囲**:
- glow-schema/Schema/Item.yml への追加
- ItemService::apply() への処理分岐追加

#### 2.2.2 アイテム使用API

**既存API**:
```
POST /api/item/consume
params:
  - mstItemId: string
  - amount: int
response: ItemConsumeResultData
```

**実装方針**:
- 既存の `/api/item/consume` APIを拡張する形で実装
- ItemService::apply() にスタミナ回復処理を追加

**レスポンス構造**:
```yaml
ItemConsumeResult:
  usrItems: UsrItemData[]        # 使用後のアイテム一覧
  usrParameter: UsrParameterData # 使用後のスタミナ値含む
  itemRewards: ItemRewardData[]  # 獲得報酬（今回は空）
  usrItemTrade: UsrItemTradeData? # アイテム交換情報（今回は不要）
```

### 2.3 スタミナ上限制御仕様

#### 2.3.1 スタミナ満タン時の使用可否

**既存の購入機能の挙動**:
```php
if ($totalStamina <= $currentStamina) {
    throw new GameException(ErrorCode::USER_STAMINA_FULL, "stamina is full.");
}
```
- 現在スタミナ >= 上限値 の場合はエラー
- 上限値とイコールの場合も購入不可

**スタミナ回復アイテムの挙動（未確定）**:
- **選択肢A**: 満タン時は使用不可（既存と同じ）
- **選択肢B**: 満タン時も使用可能だが効果なし（アイテムは消費される）
- **選択肢C**: 満タン時も使用可能で、上限を超えて回復（仕様書の記載と矛盾）

**プランナー確認が必要**

#### 2.3.2 複数個使用時の上限制御

**現状の仕様書**:
- UI上「使用数: 10」と表示されているが、複数個一括使用の可否は不明

**システム絶対上限**:
- 999（UserConstant::MAX_STAMINA）を超えることはできない

**複数個使用時の挙動（未確定）**:
- **選択肢A**: UI側で上限を超えない個数のみ選択可能にする
  - サーバー側は指定された個数を全て消費・回復
  - 999を超える個数は選択不可（UI側で制御）

- **選択肢B**: サーバー側で999を超える分は廃棄（報酬配布パターン）
  ```php
  if ($afterAmount > $maxAmount) {
      $reward->setUnreceivedRewardReason(UnreceivedRewardReason::RESOURCE_OVERFLOW_DISCARDED);
      $afterAmount = $maxAmount;
  }
  ```
  - 超過分は廃棄され、アイテムだけ消費される
  - UnreceivedReasonで廃棄理由を記録

- **選択肢C**: サーバー側でエラーを返す（スタミナ購入パターン）
  ```php
  if ($this->mstConfigService->getUserStaminaMaxAmount() < $currentStamina + $addStamina) {
      throw new GameException(ErrorCode::USER_STAMINA_EXCEEDS_LIMIT, ...);
  }
  ```
  - 上限を超える使用数はエラー
  - アイテムは消費されない

**プランナー確認が必要**

### 2.4 報酬配布仕様

#### 2.4.1 配布経路

**仕様書記載の配布経路**:
- ログインボーナス
- ミッション報酬
- イベント報酬
- お詫び配布

**実装パターン**:
- RewardDelegator → ItemSendService の既存フローを利用
- 各配布経路で RewardDelegator::addReward(new ItemReward(...)) を呼び出し
- 一括配布実行: RewardDelegator::sendRewards()

**既存パターンの適用範囲に該当**: 実装方法は確定済み

#### 2.4.2 報酬配布時の上限処理

**既存実装**:
- アイテム報酬配布時、所持数上限（USER_ITEM_MAX_AMOUNT）を超える分は廃棄
- UnreceivedRewardReason::RESOURCE_OVERFLOW_DISCARDED を設定

**適用**:
- スタミナ回復アイテムの配布も同じ処理
- 所持数上限を超える場合は廃棄される

### 2.5 ログ記録仕様

#### 2.5.1 アイテム消費ログ

**記録内容**:
- テーブル: `log_items`
- アクション種別: `LogResourceActionType::USE`
- 記録情報:
  - 消費前の所持数
  - 消費後の所持数
  - アイテムID
  - トリガー情報（JSONで詳細を保存）

**既存パターンの適用範囲に該当**: UsrItemService::consumeItems() を利用

#### 2.5.2 スタミナ増加ログ

**記録内容**:
- テーブル: `log_staminas`
- アクション種別: `LogResourceActionType::ADD`
- 記録情報:
  - 回復前のスタミナ値
  - 回復後のスタミナ値
  - トリガー情報（「スタミナ回復アイテム使用」を含む）

**既存パターンの適用範囲に該当**: UserService経由で記録

#### 2.5.3 ログ分析要件

**仕様書の要件**:
> イベント開催期間中のアイテム使用状況を記録・分析できるようにする必要がある

**実装**:
- 上記ログ記録により、イベント期間との突合分析が可能
- トリガー情報にイベントIDを含めることで、イベント別の使用状況を集計可能

### 2.6 ミッショントリガー仕様

#### 2.6.1 アイテム獲得時のトリガー

**既存実装**:
```php
// UsrItemService.php - addItemByRewards()
$this->itemMissionTriggerService->sendItemCollectTrigger($mstItemId, $addAmount);
```

**適用**:
- スタミナ回復アイテム獲得時も自動的にトリガー送信される
- 「特定のアイテムを獲得する」ミッションに対応

**既存パターンの適用範囲に該当**: 追加実装不要

#### 2.6.2 アイテム使用時のトリガー（未確定）

**想定されるミッション**:
- 「スタミナ回復アイテムを使用する」
- 「スタミナ回復アイテムをN個使用する」

**確認が必要な点**:
- このようなミッションが存在するか
- 存在する場合、ItemService::apply() でトリガー送信を実装する必要がある

**プランナー確認が必要**

### 2.7 使用回数制限（未確定）

#### 2.7.1 既存の回数制限実装

**広告視聴スタミナ購入の例**:
- 日次回数制限あり（デフォルト: 1日1回）
- Clock機能を使ったアクセス時リセット（04:00 JST基準）
- UsrUserBuyCount テーブルで回数管理

**実装パターン**:
```php
// UserBuyStaminaService.php
private function resetDailyBuyStaminaAdCount(UsrUserBuyCountInterface $usrUserBuyCount): void
{
    $buyAt = $usrUserBuyCount->getDailyBuyStaminaAdAt();
    if (!is_null($buyAt) && !$this->clock->isFirstToday($buyAt)) {
        return; // 今日はまだリセット不要
    }
    $usrUserBuyCount->setDailyBuyStaminaAdCount(0);
}
```

#### 2.7.2 スタミナ回復アイテムの回数制限

**仕様書の記載**:
- 回数制限に関する記載なし

**実装方針の選択肢**:
- **選択肢A**: 回数制限なし（アイテム所持数のみが制約）
  - 実装がシンプル
  - 所持していればいくらでも使用可能

- **選択肢B**: 日次回数制限あり（Clock機能を使用）
  - 広告視聴と同様のパターン
  - ただし、仕様書に記載がないため要確認

**判断**:
- 仕様書に記載がないため、**回数制限なし（選択肢A）で実装**するのが妥当
- 後から追加する場合も、既存のClock機能パターンを適用可能

### 2.8 自動選択機能（未確定）

#### 2.8.1 仕様書の記載

> 自動選択機能の実装場所（クライアント/サーバー）はどちらか
> 自動選択の優先順位（回復量の少ない順/多い順、期限の近い順など）はどうするか

#### 2.8.2 実装方針の選択肢

**選択肢A**: クライアント側で実装
- クライアントがアイテム一覧を取得
- 使用するアイテムIDと個数を決定
- サーバーには `/api/item/consume` で通常通りリクエスト

**選択肢B**: サーバー側で実装
- 新規API `/api/item/consume_auto` を追加
- サーバー側で最適なアイテムを自動選択して消費
- 選択ロジックをサーバーで管理

**判断**:
- 現時点では自動選択機能の実装要否自体が不明
- UI側の設計にも依存するため、プランナー・クライアント側と要調整

**プランナー確認が必要**

---

## 3. 不明点・曖昧点・判断が必要な項目

### A. 仕様書に記載がなく判断不能な項目

#### A-1: スタミナ満タン時の使用可否

- **該当箇所**: 基本仕様全体
- **何が曖昧なのか**:
  - 既存のスタミナ購入（広告/プリズム）では、スタミナが上限値以上の場合は購入不可（エラー）
  - スタミナ回復アイテムも同じ制約にするか、異なる挙動にするか不明
- **サーバーとして明確化が必要な理由**:
  - ユーザー体験に直結する境界条件
  - エラーハンドリングの実装方針が変わる
  - UI側の実装（グレーアウト表示など）にも影響

#### A-2: 複数個使用時のUI/UX仕様

- **該当箇所**: 仕様書のUI画像「使用数: 10」
- **何が曖昧なのか**:
  - 複数個を一括使用できる仕様かどうか不明
  - 一括使用時のスタミナ上限制御（999超過防止）はUI側/サーバー側のどちらで行うか不明
- **サーバーとして明確化が必要な理由**:
  - 上限超過時の処理パターン（廃棄/エラー/UI制御）の選択に影響
  - レスポンス設計（廃棄した個数を返すか等）が変わる

#### A-3: 使用回数制限の有無

- **該当箇所**: 仕様書全体
- **何が曖昧なのか**:
  - 広告視聴スタミナ購入のような日次制限を設けるか不明
  - 仕様書には一切記載がない
- **サーバーとして明確化が必要な理由**:
  - 実装する場合、テーブル追加（UsrUserBuyCount的な管理）が必要
  - Clock機能を使ったリセット処理の実装が必要
  - ただし、記載がないため「制限なし」で実装するのが妥当と判断

#### A-4: 自動選択機能の実装要否と仕様

- **該当箇所**: 01_サーバー要件抽出.md の「不明点・確認事項」
- **何が曖昧なのか**:
  - 自動選択機能を実装するか不明
  - 実装する場合、クライアント側/サーバー側のどちらで行うか不明
  - 優先順位ロジック（回復量順/期限順など）が不明
- **サーバーとして明確化が必要な理由**:
  - サーバー側実装の場合、新規APIや選択ロジックの実装が必要
  - クライアント側実装の場合、サーバーは既存API `/api/item/consume` のみで対応可能

#### A-5: アイテム使用時のミッショントリガー

- **該当箇所**: 要件C-10（コード調査）
- **何が曖昧なのか**:
  - 「スタミナ回復アイテムを使用する」というミッションが存在するか不明
  - 存在する場合、トリガー送信の実装が必要
- **サーバーとして明確化が必要な理由**:
  - ミッショントリガー送信の実装要否が変わる
  - ただし、後から追加する場合も ItemService::apply() に1行追加するだけで対応可能

### B. 仕様書とコードの不一致

**該当なし**

- 仕様書の内容（スタミナ上限の半分回復）とコードの実装パターン（50%回復ロジック）は一致している
- 報酬配布の仕様もコードの実装パターンと整合している

### C. サーバー側で仕様確定が必要な項目

#### C-1: ItemType定義の方針

- **決める必要がある点**:
  - 新規ItemType `StaminaRecovery` を追加するか
  - 既存の `Etc` 種別を使用するか

- **サーバー側の判断**:
  - **新規種別を追加する方針を推奨**
  - 理由:
    - 拡張性が高い（将来的に異なる回復量のアイテムを追加可能）
    - 種別判定が明確（Etcは汎用的すぎる）
    - glow-schema変更の手間は限定的

- **プランナーへの確認ポイント**:
  - 確認不要（技術的な実装方針のため、サーバーチームで決定可能）

#### C-2: API設計の方針

- **決める必要がある点**:
  - 既存の `/api/item/consume` APIを拡張するか
  - スタミナ回復専用の新規APIを作成するか

- **サーバー側の判断**:
  - **既存API `/api/item/consume` の拡張を推奨**
  - 理由:
    - クライアント側の実装負担が軽い（既存のアイテム使用フローと統一）
    - サーバー側もItemService::apply()への分岐追加のみで対応可能
    - アイテム種別別の処理という既存パターンに合致

- **プランナーへの確認ポイント**:
  - 確認不要（技術的な実装方針のため、サーバーチームで決定可能）

### D. ゲーム体験的に不自然な可能性がある項目

#### D-1: スタミナ満タン時にアイテムが使用不可の場合の体験

- **問題点**:
  - 既存のスタミナ購入（広告/プリズム)は満タン時エラーだが、アイテムも同じ挙動にするとユーザー体験が悪化する可能性
  - 「アイテムを持っているのに使えない」状況が発生

- **想定される影響**:
  - ユーザーの不満（なぜアイテムを使えないのか理解できない）
  - 所持アイテムの使い道がない状況が発生（デッドストック）

- **考察**:
  - スタミナ購入（課金/広告）は「今すぐスタミナが欲しい時の選択肢」なので、満タン時の制約は合理的
  - スタミナ回復アイテムは「事前に入手しておき、必要な時に使う」ものなので、満タン時も使用可能にする方が自然な可能性
  - ただし、最終的な判断はゲーム体験の観点からプランナーが決定すべき

#### D-2: 複数個使用時に上限超過分が廃棄される場合の体験

- **問題点**:
  - ユーザーが「10個使う」を選択したが、実際には5個分しか効果がない（残り5個は廃棄）という状況が発生
  - 廃棄された旨の通知がないと、ユーザーは「アイテムを損した」と感じる可能性

- **想定される影響**:
  - ユーザーの不満・混乱
  - サポート問い合わせの増加

- **考察**:
  - UI側で「上限を超えない個数のみ選択可能」にする方が、ユーザー体験として優れている
  - サーバー側で廃棄する場合は、レスポンスに「廃棄した個数」を明示する必要がある

---

## 4. プランナーへ確認が必要な項目まとめ（最重要）

### Q1: スタミナ満タン時の使用可否について

スタミナが上限値に達している状態（満タン）の時、スタミナ回復アイテムを使用できるようにしますか?

**背景**:
- 既存のスタミナ購入（広告視聴・プリズム消費）では、満タン時は購入不可（エラー）という仕様
- スタミナ回復アイテムも同じ制約にするか、異なる挙動にするかで実装が変わる

**選択肢**:
- **A**: 満タン時は使用不可（既存のスタミナ購入と同じ挙動）
  - メリット: 既存仕様と統一感がある
  - デメリット: アイテムを持っているのに使えない状況が発生

- **B**: 満タン時も使用可能だが効果なし（アイテムは消費される）
  - メリット: ユーザーの操作を制限しない
  - デメリット: 無駄な消費が発生する可能性

- **C**: 満タン時も使用可能で、上限を超えて回復する
  - メリット: ユーザーにとって最も便利
  - デメリット: 「上限の半分回復」という仕様と矛盾、バランス崩れのリスク

**推奨**: 選択肢A（満タン時は使用不可）を推奨
- 理由: 既存仕様との統一性、実装の簡潔さ
- UI側で満タン時はアイテム使用ボタンをグレーアウトすることで、ユーザーの混乱を防げる

### Q2: 複数個使用時のスタミナ上限制御について

スタミナ回復アイテムを複数個使用する際、スタミナ上限（999）を超える使用はどのように制御しますか?

**背景**:
- UI画像に「使用数: 10」という表示があり、複数個を一括使用できる仕様と推測
- 現在スタミナ900、上限150の状態で10個（750回復）使用すると、999を超えてしまう

**選択肢**:
- **A**: UI側で上限を超えない個数のみ選択可能にする
  - 例: 上限まで2個で届く場合、3個以上は選択不可
  - メリット: ユーザーが無駄な消費をすることがない
  - デメリット: UI側の実装が複雑化

- **B**: サーバー側で999を超える分は廃棄（アイテムは消費される）
  - 例: 10個使用したが、実際には2個分の効果のみ（残り8個分は廃棄）
  - メリット: サーバー側の実装がシンプル（既存の報酬配布パターンを流用）
  - デメリット: ユーザーがアイテムを損する可能性

- **C**: サーバー側でエラーを返す（アイテムは消費されない）
  - 例: 10個使用しようとしたが、上限を超えるのでエラー
  - メリット: アイテムの無駄な消費を防げる
  - デメリット: ユーザー体験が悪い（エラーが頻発する可能性）

**推奨**: 選択肢A（UI側で制御）を推奨
- 理由: ユーザー体験が最も優れている
- サーバー側は指定された個数を全て消費・回復する単純な実装で済む
- 999を超える場合は999で打ち切る（min関数で制御）

### Q3: 自動選択機能の実装について

仕様書抽出の「不明点」に記載されていた「自動選択機能」は、実装する予定ですか?

**背景**:
- 仕様書の不明点に「自動選択機能の実装場所（クライアント/サーバー）」という記載があった
- ただし、機能の存在自体が確定していない

**確認事項**:
- 自動選択機能を実装するか?
- 実装する場合、どのような優先順位で選択するか?（回復量の少ない順/多い順、期限の近い順など）
- クライアント側/サーバー側のどちらで実装するか?

**判断**:
- 実装しない場合: 本項目は不要（ユーザーが手動で選択）
- 実装する場合: 別途詳細仕様の策定が必要

### Q4: アイテム使用ミッションの存在について

「スタミナ回復アイテムを使用する」というミッションは存在しますか?

**背景**:
- 既存のミッションシステムでは、アイテム獲得時のトリガー送信は実装済み
- アイテム使用時のトリガー送信は、ミッションが存在する場合のみ実装する必要がある

**確認事項**:
- 「スタミナ回復アイテムを使用する」ミッションが存在するか?
- 「スタミナ回復アイテムをN個使用する」という累計ミッションが存在するか?

**判断**:
- 存在しない場合: トリガー送信の実装は不要
- 存在する場合: ItemService::apply() でトリガー送信を実装

---

## 5. サーバー開発への影響まとめ

### 実装前に必ず詰めるべき論点

**必須確認事項（実装に影響大）**:
1. **Q1: スタミナ満タン時の使用可否** → エラーハンドリングの実装方針が変わる
2. **Q2: 複数個使用時の上限制御** → UI/サーバーの役割分担、レスポンス設計が変わる

**任意確認事項（実装に影響中）**:
3. **Q3: 自動選択機能の実装要否** → 実装する場合は追加設計が必要
4. **Q4: アイテム使用ミッション** → 実装する場合はトリガー送信の追加が必要

### 不明点が残る場合のリスク

**高リスク**:
- Q1・Q2が未確定のまま実装を進めると、手戻りが発生する可能性が高い
- ゲーム体験に直結する境界条件のため、後から変更するとクライアント側の実装も影響を受ける

**中リスク**:
- Q3・Q4が未確定でも、基本的な実装は進められる
- ただし、後から追加する場合は追加の工数が発生

### スケジュール・品質への影響

**見積もり**:
- **プランナー確認完了前**: 詳細設計・実装着手は不可（手戻りリスク大）
- **プランナー確認完了後**: 既存パターンの組み合わせで実装可能（実装難易度: 低〜中）

**実装規模の見積もり（プランナー確認後）**:
- ItemType定義追加: 0.5日（glow-schema変更、Enum追加）
- ItemService::apply()への処理追加: 1日（スタミナ回復ロジック、ログ記録）
- バリデーション実装: 0.5日（満タンチェック、上限チェック）
- テスト実装: 1日（Unit Test、Feature Test）
- 動作確認: 0.5日（ブラウザテスト、結合テスト）
- **合計: 約3.5日** （自動選択機能・使用回数制限を含まない場合）

**品質リスク**:
- 既存パターンを踏襲するため、新規実装のバグ混入リスクは低い
- ただし、境界条件（満タン時、上限超過時）のテストケースが重要

**推奨アプローチ**:
1. プランナーへの確認（Q1〜Q4）を最優先で実施
2. 確認完了後、詳細設計・実装着手
3. 段階的リリース（まず基本機能、自動選択・ミッションは後続）を検討

---

## 6. 技術的実装方針の提案

### 6.1 ItemType定義

**提案**: 新規ItemType `StaminaRecovery` を追加

**理由**:
- 拡張性が高い（将来的に異なる回復量のアイテムを追加可能）
- 種別判定が明確（Etcは汎用的すぎる）

**実装箇所**:
```yaml
# glow-schema/Schema/Item.yml
ItemType:
  - CharacterFragment
  - RankUpMaterial
  - RankUpMemoryFragment
  - StageMedal
  - IdleCoinBox
  - IdleRankUpMaterialBox
  - RandomFragmentBox
  - SelectionFragmentBox
  - GachaTicket
  - GachaMedal
  - StaminaRecovery  # ← 追加
  - Etc
```

### 6.2 API設計

**提案**: 既存の `/api/item/consume` APIを拡張

**理由**:
- クライアント側の実装負担が軽い
- サーバー側もItemService::apply()への分岐追加のみで対応可能

**実装箇所**:
```php
// ItemService.php - apply()
switch ($mstItem->getItemType()) {
    case ItemType::STAMINA_RECOVERY->value:
        $this->applyStaminaRecovery($userId, $mstItem, $amount, $now);
        break;
    // 既存の種別処理...
}
```

### 6.3 スタミナ回復処理の実装

**提案**: UserBuyStaminaService::calcAddStamina() のロジックを流用

**実装イメージ**:
```php
// ItemService.php
private function applyStaminaRecovery(
    string $userId,
    MstItemEntity $mstItem,
    int $amount,
    CarbonImmutable $now
): void {
    // 1. 自然回復を適用
    $usrUserParameter = $this->userService->recoveryStamina($userId, $now);

    // 2. スタミナ上限値を取得
    $levelStamina = $this->mstUserLevelRepository
        ->getByLevel($usrUserParameter->getLevel(), true)
        ->getStamina();
    $shopPassEffectData = $this->shopPassEffectDelegator
        ->getShopPassActiveEffectDataByUsrUserId($userId, $now);
    $totalStamina = $levelStamina + $shopPassEffectData->getStaminaAddRecoveryLimit();

    // 3. バリデーション（Q1の回答により実装方針が変わる）
    if ($totalStamina <= $usrUserParameter->getStamina()) {
        throw new GameException(ErrorCode::USER_STAMINA_FULL, "stamina is full.");
    }

    // 4. 回復量を計算（50%回復）
    $addStaminaPerItem = (int) floor($totalStamina * 50 / 100);
    $totalAddStamina = $addStaminaPerItem * $amount;

    // 5. システム上限チェック（Q2の回答により実装方針が変わる）
    $maxAmount = $this->mstConfigService->getUserStaminaMaxAmount();
    $afterStamina = $usrUserParameter->getStamina() + $totalAddStamina;
    if ($afterStamina > $maxAmount) {
        $afterStamina = $maxAmount; // 999で打ち切り
    }

    // 6. スタミナ加算
    $usrUserParameter->setStamina($afterStamina);

    // 7. ログ記録
    $this->logStaminaRepository->create(
        $userId,
        LogResourceActionType::ADD,
        $usrUserParameter->getStamina(), // 回復前
        $afterStamina, // 回復後
        ['trigger' => 'stamina_recovery_item', 'mstItemId' => $mstItem->getId()],
    );

    // 8. ミッショントリガー送信（Q4の回答により実装要否が変わる）
    // $this->itemMissionTriggerService->sendItemUseTrigger($mstItem->getId(), $amount);
}
```

### 6.4 報酬配布処理

**提案**: 既存のRewardDelegatorパターンを利用

**実装不要**: 既存の実装で対応可能

**使用例**:
```php
// ログインボーナスでスタミナ回復アイテムを配布
$this->rewardDelegator->addReward(new ItemReward(
    mstItemId: 'stamina_recovery_item_001',
    amount: 5,
));
$this->rewardDelegator->sendRewards($usrUserId, $platform, $now);
```

### 6.5 ログ記録処理

**提案**: 既存のログ記録パターンを利用

**実装箇所**:
- アイテム消費ログ: UsrItemService::consumeItems() で自動記録
- スタミナ増加ログ: 上記6.3の実装で記録

### 6.6 ミッショントリガー処理

**提案**: Q4の回答により実装要否を判断

**実装する場合**:
```php
// ItemService.php - applyStaminaRecovery()
$this->itemMissionTriggerService->sendItemUseTrigger($mstItem->getId(), $amount);
```

---

## 7. 次のステップ

### 7.1 即座に実施すべきこと

1. **プランナーへの確認**
   - 上記Q1〜Q4をプランナーに確認
   - 特にQ1・Q2は実装方針に大きく影響するため最優先

2. **クライアント側との仕様調整**
   - Q2（複数個使用時の制御）はUI設計と密接に関連
   - クライアント側の実装担当者と事前に調整

### 7.2 プランナー確認後の作業

1. **詳細設計書の作成**
   - API仕様書（リクエスト/レスポンス）
   - DB設計書（新規テーブルが必要な場合）
   - 処理フロー図

2. **実装**
   - glow-schema変更（ItemType追加）
   - ItemService::apply()への処理追加
   - テストコード実装

3. **テスト・動作確認**
   - Unit Test実行
   - Feature Test実行
   - ブラウザでの動作確認

4. **次のStage（要件定義書作成）へ進む**
   - 本レビュー結果とプランナー回答を元に、要件定義書を作成

---

## 8. 補足: 既存実装パターンのまとめ

### 適用可能な既存パターン

| パターン | 適用箇所 | 実装難易度 |
|---------|---------|----------|
| スタミナ回復計算 | UserBuyStaminaService::calcAddStamina() | 低 |
| 自然回復適用 | UserService::recoveryStamina() | 低 |
| 報酬配布 | RewardDelegator → ItemSendService | 低 |
| アイテム使用 | ItemService::apply() | 中 |
| ログ記録 | LogStaminaRepository, LogItemRepository | 低 |
| ミッショントリガー | ItemMissionTriggerService | 低 |

### 新規実装が必要な事項

| 事項 | 実装箇所 | 実装難易度 |
|------|---------|----------|
| ItemType定義追加 | glow-schema/Schema/Item.yml | 低 |
| スタミナ回復処理 | ItemService::applyStaminaRecovery() | 中 |
| バリデーション | 満タンチェック、上限チェック | 中 |

---

## 変更履歴

| 日付 | 変更内容 | 担当者 |
|------|---------|--------|
| 2025-11-27 | 初版作成 | サーバー仕様レビュー自動分析 |
| 2025-11-27 | テンプレート要件を反映し、更新版を作成 | サーバー仕様レビュー自動分析 |
