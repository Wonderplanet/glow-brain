# サーバー要件（コード調査による追加・補足）

## ドキュメント情報
- **対象機能**: スタミナ回復アイテム
- **調査日**: 2025-11-27
- **ステータス**: コード調査完了

---

## サーバー要件一覧（コード調査による追加）

### 要件C-1: スタミナ回復の計算ロジックと上限制御
- **種別**: コードから判明した追加要件
- **関連機能**: スタミナ回復全般（プリズム購入/広告視聴/アイテム）
- **関連ファイル**:
  - `api/app/Domain/User/Services/UserBuyStaminaService.php` の `calcAddStamina`, `buyStaminaAd`, `buyStaminaDiamond`
  - `api/app/Domain/User/Services/UserService.php` の `addStamina`, `addStaminaByRewards`
  - `api/app/Domain/User/Constants/UserConstant.php`
  - `api/app/Domain/User/Models/UsrUserParameter.php` の `addStamina`

- **内容の要約**:
  - スタミナ回復処理には「回復量の計算」「スタミナ上限値の取得」「システム上限値との比較」という3段階のチェックが必要

- **詳細**:

  既存のスタミナ購入機能（広告視聴/プリズム購入）では、以下の仕様が確立されている：

  1. **回復量の計算**:
     - 広告視聴: `BUY_STAMINA_AD_PERCENTAGE_OF_MAX_STAMINA = 50` → スタミナ上限の50%回復
     - プリズム購入: `BUY_STAMINA_DIAMOND_PERCENTAGE_OF_MAX_STAMINA = 100` → スタミナ上限の100%回復
     - 計算式: `(int) floor($totalStamina * $recoveryStaminaPercentage / 100)`

  2. **スタミナ上限値の取得**:
     ```php
     $levelStamina = $this->mstUserLevelRepository
         ->getByLevel($usrUserParameter->getLevel(), true)
         ->getStamina();
     $shopPassEffectData = $this->shopPassEffectDelegator
         ->getShopPassActiveEffectDataByUsrUserId($usrUserId, $now);
     $totalStamina = $levelStamina + $shopPassEffectData->getStaminaAddRecoveryLimit();
     ```
     - レベル別スタミナ上限 + ショップパス効果による追加上限

  3. **購入前バリデーション**:
     - 現在スタミナが上限値以上の場合はエラー（`ErrorCode::USER_STAMINA_FULL`）
     - 「上限値とイコールの場合も購入不可」という仕様

  4. **システム上限チェック**:
     ```php
     if ($this->mstConfigService->getUserStaminaMaxAmount() < $currentStamina + $addStamina) {
         throw new GameException(ErrorCode::USER_STAMINA_EXCEEDS_LIMIT, ...);
     }
     ```
     - `UserConstant::MAX_STAMINA = 999` がシステム絶対上限
     - この上限を超える回復はエラーとなる

  5. **スタミナ加算処理**:
     ```php
     // UsrUserParameter.php
     public function addStamina(int $stamina, int $maxStamina): void
     {
         $this->stamina = min($this->stamina + $stamina, $maxStamina);
     }
     ```
     - `min()` によってシステム上限で打ち切り

- **元になったコードの抜粋**:
  ```php
  // UserBuyStaminaService.php - calcAddStamina()
  private function calcAddStamina(string $usrUserId, CarbonImmutable $now, int $recoveryStaminaPercentage): int
  {
      $usrUserParameter = $this->userService->recoveryStamina($usrUserId, $now);
      $currentStamina = $usrUserParameter->getStamina();
      $levelStamina = $this->mstUserLevelRepository->getByLevel($usrUserParameter->getLevel(), true)->getStamina();
      $shopPassEffectData = $this->shopPassEffectDelegator->getShopPassActiveEffectDataByUsrUserId($usrUserId, $now);
      $totalStamina = $levelStamina + $shopPassEffectData->getStaminaAddRecoveryLimit();

      if ($totalStamina <= $currentStamina) {
          throw new GameException(ErrorCode::USER_STAMINA_FULL, ...);
      }

      $addStamina = (int) floor($totalStamina * $recoveryStaminaPercentage / 100);
      if ($this->mstConfigService->getUserStaminaMaxAmount() < $currentStamina + $addStamina) {
          throw new GameException(ErrorCode::USER_STAMINA_EXCEEDS_LIMIT, ...);
      }
      return $addStamina;
  }
  ```

- **備考**:
  - 仕様書では「スタミナ上限値の半分回復」という結果のみ記載
  - コードからは、ショップパス効果による上限値増加、システム絶対上限999、購入前バリデーションなど詳細な制約が判明
  - **スタミナ回復アイテムも同様の計算ロジックと制約を踏襲する必要がある**

---

### 要件C-2: 自然回復の適用タイミング
- **種別**: コードから判明した追加要件
- **関連機能**: スタミナ回復全般
- **関連ファイル**:
  - `api/app/Domain/User/Services/UserService.php` の `recoveryStamina`, `addStamina`, `addStaminaByRewards`
  - `api/app/Domain/User/Services/UserBuyStaminaService.php` の `buyStaminaAd`, `calcAddStamina`

- **内容の要約**:
  - スタミナ回復処理（購入・アイテム使用）の前に、必ず自然回復分を先に適用する

- **詳細**:

  既存のスタミナ関連処理では、以下のパターンが確立されている：

  1. **自然回復の適用**:
     - スタミナ増加処理の前に `recoveryStamina()` を呼び出し
     - 自然回復分を反映した最新のスタミナ値を取得してから処理を開始

  2. **適用箇所**:
     - スタミナ購入（広告/プリズム）: `calcAddStamina()` 内で `recoveryStamina()` 呼び出し
     - 報酬によるスタミナ付与: `addStaminaByRewards()` 冒頭で `recoveryStamina()` 呼び出し
     - スタミナ消費: `consumeStamina()` 冒頭で `recoveryStamina()` 呼び出し

  3. **自然回復の計算ロジック**:
     ```php
     // UserService.php - getRecoveredStamina()
     $recoveryStaminaMinute = $this->mstConfigService->getRecoveryStaminaMinute();
     $staminaUpdatedAt = new CarbonImmutable($usrUserParameter->getStaminaUpdatedAt());
     $diffMinutes = (int) $staminaUpdatedAt->diffInMinutes($now, true);
     $recoveryStamina = (int) ($diffMinutes / $recoveryStaminaMinute + $stamina);
     return min($recoveryStamina, $maxStamina);
     ```
     - `RECOVERY_STAMINA_MINUTE = 3` → 3分で1回復
     - 自然回復はスタミナ上限値で打ち切り

- **元になったコードの抜粋**:
  ```php
  // UserService.php - addStaminaByRewards()
  public function addStaminaByRewards(string $usrUserId, Collection $rewards, CarbonImmutable $now): void
  {
      // 自然回復分を先に適用
      $usrUserParameter = $this->recoveryStamina($usrUserId, $now);
      $maxAmount = $this->mstConfigService->getUserStaminaMaxAmount();

      foreach ($rewards as $reward) {
          $beforeAmount = $usrUserParameter->getStamina();
          $afterAmount = $beforeAmount + $addAmount;
          if ($afterAmount > $maxAmount) {
              $reward->setUnreceivedRewardReason(UnreceivedRewardReason::RESOURCE_OVERFLOW_DISCARDED);
              $afterAmount = $maxAmount;
          }
          $usrUserParameter->setStamina($afterAmount);
      }
  }
  ```

- **備考**:
  - 仕様書には記載なし
  - **スタミナ回復アイテム使用時も、自然回復を先に適用してから回復量を計算・加算する必要がある**

---

### 要件C-3: スタミナ上限超過時の報酬廃棄処理
- **種別**: コードから判明した追加要件
- **関連機能**: 報酬配布全般（スタミナ・コイン・アイテム）
- **関連ファイル**:
  - `api/app/Domain/User/Services/UserService.php` の `addStaminaByRewards`, `addCoinByRewards`
  - `api/app/Domain/Item/Services/UsrItemService.php` の `addItemByRewards`
  - `api/app/Domain/Resource/Enums/UnreceivedRewardReason.php`

- **内容の要約**:
  - 報酬配布でリソース上限を超える場合、超過分は廃棄され `UnreceivedRewardReason::RESOURCE_OVERFLOW_DISCARDED` が設定される

- **詳細**:

  既存の報酬配布処理では、以下のパターンが確立されている：

  1. **スタミナ報酬の上限処理**:
     ```php
     if ($afterAmount > $maxAmount) {
         $reward->setUnreceivedRewardReason(UnreceivedRewardReason::RESOURCE_OVERFLOW_DISCARDED);
         $afterAmount = $maxAmount;
     }
     ```
     - 上限（999）を超える分は廃棄
     - 報酬オブジェクトに廃棄理由を記録

  2. **コイン報酬の上限処理**:
     - 同様に `USER_COIN_MAX_AMOUNT` で打ち切り
     - 超過分は廃棄される

  3. **アイテム報酬の上限処理**:
     - `USER_ITEM_MAX_AMOUNT` で打ち切り
     - 超過分は廃棄される

  4. **複数報酬の処理**:
     - 報酬がコレクションで複数ある場合、ループ内で1つずつ処理
     - 各報酬の処理時に現在値を取得し直す（連続加算の考慮）

- **元になったコードの抜粋**:
  ```php
  // UserService.php - addStaminaByRewards()
  foreach ($rewards as $reward) {
      $beforeAmount = $usrUserParameter->getStamina();
      $reward->setBeforeAmount($beforeAmount);

      $afterAmount = $beforeAmount + $addAmount;

      if ($afterAmount > $maxAmount) {
          $reward->setUnreceivedRewardReason(UnreceivedRewardReason::RESOURCE_OVERFLOW_DISCARDED);
          $afterAmount = $maxAmount;
      }

      $reward->setAfterAmount($afterAmount);
      $usrUserParameter->setStamina($afterAmount);
      $reward->markAsSent();
  }
  ```

- **備考**:
  - 仕様書には記載なし
  - **スタミナ回復アイテムを複数個使用した場合、上限を超える分は廃棄される**
  - UI側で「上限を超える使用数は選択不可」とするか、サーバー側で廃棄するかの選択が必要

---

### 要件C-4: アイテム種別の定義と消費処理パターン
- **種別**: コードから判明した追加要件
- **関連機能**: アイテム管理全般
- **関連ファイル**:
  - `api/app/Domain/Item/Enums/ItemType.php`
  - `api/app/Domain/Item/Services/ItemService.php` の `apply`, `applyWithSelectItem`
  - `api/app/Domain/Item/Services/UsrItemService.php` の `consumeItem`, `consumeItems`
  - `glow-schema/Schema/Item.yml`

- **内容の要約**:
  - アイテム種別（ItemType）は固定Enumで定義され、種別ごとに異なる消費処理が実装されている

- **詳細**:

  既存のアイテムシステムでは、以下の構造が確立されている：

  1. **ItemType定義**（glow-schema/Schema/Item.yml）:
     - CharacterFragment: キャラのかけら
     - RankUpMaterial: リミテッドメモリー
     - RankUpMemoryFragment: メモリーフラグメント
     - StageMedal: ステージメダル
     - IdleCoinBox: コイン放置BOX
     - IdleRankUpMaterialBox: リミテッドメモリー放置BOX
     - RandomFragmentBox: ランダムかけらBOX
     - SelectionFragmentBox: 選択かけらBOX
     - GachaTicket: ガチャチケット
     - GachaMedal: ガシャメダル
     - Etc: その他
     - **スタミナ回復アイテムの種別は未定義**

  2. **消費処理のパターン**:
     ```php
     // ItemService.php - apply()
     switch ($mstItem->getItemType()) {
         case ItemType::RANDOM_FRAGMENT_BOX->value:
             $this->applyRandomFragmentBox(...);
             break;
         case ItemType::CHARACTER_FRAGMENT->value:
             $this->applyCharacterFragment(...);
             break;
         default:
             throw new GameException(ErrorCode::INVALID_PARAMETER, "invalid item type");
     }
     ```
     - 種別ごとに専用の処理メソッドが実装されている
     - 未定義の種別はエラーとなる

  3. **アイテム消費処理**:
     ```php
     // UsrItemService.php - consumeItem()
     public function consumeItem(string $usrId, string $mstItemId, int $consumeAmount, LogTrigger $logTrigger): ?UsrItemInterface
     {
         $usrItem = $usrItems->get($mstItemId);
         if (is_null($usrItem)) {
             throw new GameException(ErrorCode::ITEM_NOT_OWNED);
         }
         $usrItem->subtractItemAmount($consumeAmount);
     }
     ```
     - 所持数チェック → 消費 → ログ記録
     - 所持していないアイテムは消費不可

- **元になったコードの抜粋**:
  ```php
  // ItemType.php
  enum ItemType: string
  {
      case CHARACTER_FRAGMENT = 'CharacterFragment';
      case RANDOM_FRAGMENT_BOX = 'RandomFragmentBox';
      case SELECTION_FRAGMENT_BOX = 'SelectionFragmentBox';
      case GACHA_TICKET = 'GachaTicket';
      case ETC = 'Etc';
      // スタミナ回復アイテムの種別は未定義
  }
  ```

- **備考**:
  - 仕様書には記載なし
  - **スタミナ回復アイテムの実装には、新しいItemType（例: `StaminaRecovery`）の追加が必要**
  - **または既存の`Etc`種別を使用する選択肢もある**
  - **`ItemService::apply()` に新種別用の処理分岐を追加する必要がある**

---

### 要件C-5: 報酬配布システム（RewardDelegator）の利用パターン
- **種別**: コードから判明した既存実装パターン
- **関連機能**: 報酬配布全般（ログインボーナス、ミッション報酬、イベント報酬など）
- **関連ファイル**:
  - `api/app/Domain/Reward/Delegators/RewardDelegator.php`
  - `api/app/Domain/Reward/Services/RewardSendService.php`
  - `api/app/Domain/Reward/Services/StaminaSendService.php`
  - `api/app/Domain/Reward/Services/ItemSendService.php`

- **内容の要約**:
  - スタミナやアイテムの配布は、RewardDelegatorを経由した統一的な報酬配布システムで実装されている

- **詳細**:

  既存の報酬配布システムでは、以下のパターンが確立されている：

  1. **報酬配布の基本フロー**:
     ```php
     // 報酬をリストに追加
     $this->rewardDelegator->addReward(new ItemReward(...));
     $this->rewardDelegator->addReward(new StaminaReward(...));

     // 一括で配布実行
     $this->rewardDelegator->sendRewards($usrUserId, $platform, $now);
     ```
     - 複数種類の報酬を一括で配布可能
     - トランザクション内で実行される

  2. **RewardSendServiceの種別別処理**:
     - `StaminaSendService`: スタミナ報酬の配布
     - `ItemSendService`: アイテム報酬の配布
     - `CurrencySendService`: 通貨報酬の配布
     - 各サービスが `RewardSendServiceInterface` を実装

  3. **StaminaSendServiceの実装**:
     ```php
     public function send(RewardSendContext $context): RewardSent
     {
         $usrUserId = $context->getUsrUserId();
         $rewards = $context->getRewards();
         $now = $context->getNow();

         $this->userDelegator->addStaminaByRewards(
             usrUserId: $usrUserId,
             rewards: $rewards,
             now: $now,
         );

         return new RewardSent($rewards);
     }
     ```
     - UserDelegator経由でUserService::addStaminaByRewards()を呼び出し

- **実装パターンの適用範囲**:
  - **報酬配布が必要な全ての機能（ログインボーナス、ミッション、イベント、お詫び配布など）に適用可能**
  - **今回のスタミナ回復アイテム配布もこの適用範囲に該当する**
  - ただし、**アイテムの「使用」処理は報酬配布とは別のフロー**（後述の要件C-6参照）

- **実装方針の背景**:
  - 報酬配布処理の共通化により、報酬種別の追加が容易
  - トランザクション管理の一元化
  - ログ記録・ミッショントリガー送信の統一

- **代替案が必要になる条件**:
  - 報酬配布ではなく、ユーザー操作による「消費→効果発動」フローが必要な場合
  - **今回のスタミナ回復アイテムはこの条件に該当する**（使用API実装が必要）

- **元になったコードの抜粋**:
  ```php
  // StaminaSendService.php
  public function send(RewardSendContext $context): RewardSent
  {
      $this->userDelegator->addStaminaByRewards(
          usrUserId: $usrUserId,
          rewards: $rewards,
          now: $now,
      );
      return new RewardSent($rewards);
  }
  ```

- **備考**:
  - 仕様書の「要件5: アイテム配布と報酬管理」は、このRewardDelegatorパターンで実装可能
  - ただし、**アイテム使用処理は別途API実装が必要**

---

### 要件C-6: アイテム使用API（Item/Consume）の既存実装パターン
- **種別**: コードから判明した既存実装パターン
- **関連機能**: アイテム使用全般
- **関連ファイル**:
  - `glow-schema/Schema/Item.yml` の `/api/item/consume` API定義
  - `api/app/Domain/Item/Services/ItemService.php` の `apply()`
  - API Controller（未確認）

- **内容の要約**:
  - アイテム使用のためのAPI `/api/item/consume` が既に定義されており、種別別の処理が実装されている

- **詳細**:

  既存のアイテム使用APIでは、以下のパターンが確立されている：

  1. **API定義**（glow-schema/Schema/Item.yml）:
     ```yaml
     - name: Consume
       path: "/api/item/consume"
       params:
         - name: mstItemId
           type: string
         - name: amount
           type: int
       method: POST
       response: ItemConsumeResultData
     ```
     - アイテムIDと使用数を受け取る
     - レスポンスに使用後のアイテム一覧、ユーザーパラメータ、獲得報酬を含む

  2. **ItemConsumeResultData**:
     ```yaml
     - name: ItemConsumeResult
       params:
         - name: usrItems
           type: UsrItemData[]
         - name: usrParameter
           type: UsrParameterData
         - name: itemRewards
           type: ItemRewardData[]
         - name: usrItemTrade
           type: UsrItemTradeData?
     ```
     - 使用後のユーザーパラメータ（スタミナ値含む）を返す構造

  3. **処理フロー**:
     ```php
     // ItemService.php - apply()
     public function apply(string $userId, int $platform, MstItemEntity $mstItem, int $amount, CarbonImmutable $now): ?UsrItemTradeInterface
     {
         switch ($mstItem->getItemType()) {
             case ItemType::RANDOM_FRAGMENT_BOX->value:
                 $this->applyRandomFragmentBox(...);
                 break;
             // 各種別の処理
         }
     }
     ```
     - アイテム消費 → 効果発動 → 報酬配布（RewardDelegator経由）

- **実装パターンの適用範囲**:
  - **消費型アイテム全般に適用可能**
  - **今回のスタミナ回復アイテムもこの適用範囲に該当する**

- **実装方針の背景**:
  - 既存APIを拡張することで、クライアント側の実装負担を軽減
  - アイテム種別別の処理を追加するだけで機能実装可能

- **代替案が必要になる条件**:
  - スタミナ回復専用のAPIを新規作成する場合
  - ただし、既存パターンを踏襲する方が統一性が高い

- **元になったコードの抜粋**:
  ```yaml
  # Item.yml - Consume API
  - name: Consume
    path: "/api/item/consume"
    params:
      - name: mstItemId
        type: string
      - name: amount
        type: int
    method: POST
    response: ItemConsumeResultData
  ```

- **備考**:
  - 仕様書には記載なし
  - **スタミナ回復アイテムは、既存の `/api/item/consume` APIを拡張する形で実装可能**
  - **ItemService::apply() にスタミナ回復処理を追加する必要がある**

---

### 要件C-7: 日次リセット処理の実装パターン（Clock機能）
- **種別**: コードから判明した既存実装パターン
- **関連機能**: 日次・週次・月次のリセット処理全般
- **関連ファイル**:
  - `api/app/Domain/Common/Entities/Clock.php` の `isFirstToday`, `isFirstWeek`, `isFirstMonth`
  - `api/app/Domain/User/Services/UserBuyStaminaService.php` の `resetDailyBuyStaminaAdCount`
  - `api/app/Domain/Item/Services/ItemService.php` の `resetUsrItemTrade`

- **内容の要約**:
  - 日次・週次・月次のリセット処理は、Clock機能を使ったアクセス時判定で実装されている（バッチ不要）

- **詳細**:

  既存のリセット処理では、以下のパターンが確立されている：

  1. **Clock機能の日跨ぎ判定**:
     ```php
     // Clock.php
     public function isFirstToday(string $targetAt): bool
     {
         return CarbonImmutable::parse($targetAt) < $this->getDayStartDatetime();
     }
     ```
     - 日跨ぎ基準時刻: 04:00 JST（`BORDER_TIME_DAY_START = '04:00:00'`）
     - 週の起点: 月曜日（`WEEK_START_DAY = CarbonImmutable::MONDAY`）

  2. **アクセス時リセット処理**:
     ```php
     // UserBuyStaminaService.php - buyStaminaAd()
     public function buyStaminaAd(string $usrUserId, CarbonImmutable $now): void
     {
         $usrUserBuyCount = $this->usrUserBuyCountRepository->findOrCreate($usrUserId);

         // リセットの必要があれば実行（アクセス時判定）
         $this->resetDailyBuyStaminaAdCount($usrUserBuyCount);

         // 購入処理を続行
         $this->validateAvailabilityForBuyStaminaAd($usrUserBuyCount);
         ...
     }

     private function resetDailyBuyStaminaAdCount(UsrUserBuyCountInterface $usrUserBuyCount, bool $withSyncModel = true): void
     {
         $buyAt = $usrUserBuyCount->getDailyBuyStaminaAdAt();
         if (!is_null($buyAt) && !$this->clock->isFirstToday($buyAt)) {
             // 購入が今日初めてではないので何もしない
             return;
         }
         $usrUserBuyCount->setDailyBuyStaminaAdCount(0);
         if ($withSyncModel) {
             $this->usrUserBuyCountRepository->syncModel($usrUserBuyCount);
         }
     }
     ```
     - APIリクエスト処理時に、前回実行時刻をチェック
     - 日跨ぎしている場合のみリセット実行

  3. **アイテム交換回数リセット**:
     ```php
     // ItemService.php - resetUsrItemTrade()
     private function resetUsrItemTrade(MstItemRarityTradeEntity $mstItemRarityTrade, UsrItemTradeInterface $usrItemTrade, CarbonImmutable $now): void
     {
         $needReset = match ($mstItemRarityTrade->getResetTypeEnum()) {
             ItemTradeResetType::DAILY => $this->clock->isFirstToday($beforeResetAt),
             ItemTradeResetType::WEEKLY => $this->clock->isFirstWeek($beforeResetAt),
             ItemTradeResetType::MONTHLY => $this->clock->isFirstMonth($beforeResetAt),
             default => false,
         };

         if ($needReset === false) {
             return;
         }

         $usrItemTrade->reset($now);
     }
     ```

- **実装パターンの適用範囲**:
  - **ユーザーごとの定期リセット処理全般（日次・週次・月次）に適用可能**
  - 広告視聴スタミナ購入の日次リセット（回数制限・インターバル）
  - ショップアイテムの購入回数リセット
  - アイテム交換回数のリセット
  - **今回のスタミナ回復アイテムが回数制限を持つ場合、このパターンを適用可能**

- **実装方針の背景**:
  - バッチ処理基盤（cron、AWS EventBridge等）の保守コストを削減
  - リアルタイム性の確保（04:00にバッチが動かなくても、次回アクセス時に確実にリセット）
  - ユーザー単位の処理のため、全ユーザー一斉処理が不要

- **代替案が必要になる条件**:
  - リセット対象が全ユーザー（数百万人）かつ一斉処理が必要な場合
  - アクセス時のレスポンスタイムが厳しく制約される場合
  - **今回のスタミナ回復アイテム機能はこれらの条件に該当しない**

- **元になったコードの抜粋**:
  ```php
  // Clock.php
  public const BORDER_TIME_DAY_START = '04:00:00';

  public function isFirstToday(string $targetAt): bool
  {
      return CarbonImmutable::parse($targetAt) < $this->getDayStartDatetime();
  }
  ```

- **備考**:
  - 仕様書には記載なし
  - **スタミナ回復アイテムに使用回数制限を設ける場合、このClock機能を使った実装パターンを踏襲すべき**
  - **ただし、仕様書には回数制限の記載がないため、この要件は現時点では不要の可能性が高い**

---

### 要件C-8: スタミナ回復前のスタミナ満タンチェック
- **種別**: コードから判明した追加要件
- **関連機能**: スタミナ購入全般
- **関連ファイル**:
  - `api/app/Domain/User/Services/UserBuyStaminaService.php` の `calcAddStamina`
  - `api/app/Domain/Common/Constants/ErrorCode.php`

- **内容の要約**:
  - スタミナ購入（広告/プリズム）では、現在スタミナが上限値以上の場合は購入不可（エラー）となる

- **詳細**:

  既存のスタミナ購入機能では、以下の仕様が確立されている：

  1. **購入前バリデーション**:
     ```php
     if ($totalStamina <= $currentStamina) {
         throw new GameException(
             ErrorCode::USER_STAMINA_FULL,
             "stamina is full. (stamina: $currentStamina)"
         );
     }
     ```
     - 現在スタミナ >= スタミナ上限値 の場合はエラー
     - **上限値とイコールの場合も購入不可**という厳密な仕様

  2. **該当するケース**:
     - レベルアップでスタミナ全回復した直後
     - ショップパス効果でスタミナ上限が増加し、自然回復で満タンになった場合
     - 既にプリズム購入や広告視聴でスタミナを回復済みの場合

- **元になったコードの抜粋**:
  ```php
  // UserBuyStaminaService.php - calcAddStamina()
  if ($totalStamina <= $currentStamina) {
      // スタミナ購入前の時点で最大値を超えている場合はエラー(最大値とイコールの場合は購入不可)
      throw new GameException(
          ErrorCode::USER_STAMINA_FULL,
          "stamina is full. (stamina: $currentStamina)"
      );
  }
  ```

- **備考**:
  - 仕様書には記載なし
  - **スタミナ回復アイテムにも同様のバリデーションが必要か確認が必要**
  - **選択肢1**: 満タン時は使用不可（既存と同じ）
  - **選択肢2**: 満タン時も使用可能だが効果なし（アイテムは消費される）
  - **選択肢3**: 満タン時も使用可能で、上限を超えて回復する（仕様書の記載と矛盾）

---

### 要件C-9: スタミナのシステム絶対上限（999）
- **種別**: コードから判明した追加要件
- **関連機能**: スタミナ管理全般
- **関連ファイル**:
  - `api/app/Domain/User/Constants/UserConstant.php`
  - `api/app/Domain/Resource/Mst/Services/MstConfigService.php` の `getUserStaminaMaxAmount`
  - `api/app/Domain/User/Services/UserBuyStaminaService.php` の `calcAddStamina`

- **内容の要約**:
  - スタミナのシステム絶対上限は999で、いかなる方法でもこの値を超えることはできない

- **詳細**:

  既存のスタミナシステムでは、以下の上限が設定されている：

  1. **システム絶対上限**:
     ```php
     // UserConstant.php
     public const MAX_STAMINA = 999;
     ```
     - この値は `mst_configs` テーブルで変更可能
     - デフォルト値は999

  2. **上限超過チェック**:
     ```php
     if ($this->mstConfigService->getUserStaminaMaxAmount() < $currentStamina + $addStamina) {
         throw new GameException(
             ErrorCode::USER_STAMINA_EXCEEDS_LIMIT,
             "exceeding the limit by making a buy. (stamina: $currentStamina addStamina: $addStamina)"
         );
     }
     ```
     - スタミナ購入時に、加算後の値が999を超える場合はエラー

  3. **レベル別スタミナ上限との関係**:
     - `mst_user_levels.stamina`: レベル別の通常上限（例: Lv1=50, Lv50=150など）
     - ショップパス効果で上限が増加する可能性あり
     - しかし、これらの合計も999を超えることはできない

- **元になったコードの抜粋**:
  ```php
  // UserConstant.php
  public const MAX_STAMINA = 999;

  // UserBuyStaminaService.php
  if ($this->mstConfigService->getUserStaminaMaxAmount() < $currentStamina + $addStamina) {
      throw new GameException(ErrorCode::USER_STAMINA_EXCEEDS_LIMIT, ...);
  }
  ```

- **備考**:
  - 仕様書には記載なし
  - **スタミナ回復アイテムの複数個使用で999を超える場合の挙動を定義する必要がある**
  - **選択肢1**: 超える個数は使用不可（UI側で制御）
  - **選択肢2**: 超える個数も使用可能だが、999で打ち切り（要件C-3の廃棄処理）

---

### 要件C-10: ミッショントリガー送信の必要性
- **種別**: コードから判明した追加要件
- **関連機能**: ミッション連携
- **関連ファイル**:
  - `api/app/Domain/User/Services/UserBuyStaminaService.php` の `buyStaminaAd`
  - `api/app/Domain/Common/Services/AdPlayService.php`
  - `api/app/Domain/Item/Services/UsrItemService.php` の `addItemByRewards`
  - `api/app/Domain/Item/Services/ItemMissionTriggerService.php`

- **内容の要約**:
  - スタミナ購入やアイテム獲得時には、ミッショントリガーを送信する必要がある

- **詳細**:

  既存の実装では、以下のミッショントリガー送信パターンが確立されている：

  1. **広告視聴スタミナ購入時**:
     ```php
     // UserBuyStaminaService.php - buyStaminaAd()
     $this->adPlayService->adPlay(
         $usrUserId,
         ContentType::BUY_STAMINA->value,
         '',
         $now
     );
     ```
     - 広告視聴でスタミナ購入した場合、ミッショントリガーを送信

  2. **アイテム獲得時**:
     ```php
     // UsrItemService.php - addItemByRewards()
     $this->itemMissionTriggerService->sendItemCollectTrigger($mstItemId, $addAmount);
     ```
     - アイテムを獲得した際、ミッショントリガーを送信

  3. **該当ミッションの例**:
     - 「広告視聴でスタミナを購入する」
     - 「特定のアイテムを獲得する」
     - 「特定のアイテムを使用する」（実装次第）

- **元になったコードの抜粋**:
  ```php
  // UserBuyStaminaService.php
  $this->adPlayService->adPlay(
      $usrUserId,
      ContentType::BUY_STAMINA->value,
      '',
      $now
  );
  ```

- **備考**:
  - 仕様書には記載なし
  - **スタミナ回復アイテム使用時のミッショントリガー送信が必要かどうか確認が必要**
  - 「スタミナ回復アイテムを使用する」というミッションが存在する可能性がある

---

### 要件C-11: ログ記録の実装パターン
- **種別**: コードから判明した追加要件
- **関連機能**: ログ管理全般
- **関連ファイル**:
  - `api/app/Domain/User/Repositories/LogStaminaRepository.php`
  - `api/app/Domain/Item/Repositories/LogItemRepository.php`
  - `api/app/Domain/User/Services/UserService.php` の `consumeStamina`
  - `api/app/Domain/Item/Services/UsrItemService.php` の `consumeItems`

- **内容の要約**:
  - スタミナやアイテムの増減には、ログ記録（log_staminas, log_items）が必須

- **詳細**:

  既存の実装では、以下のログ記録パターンが確立されている：

  1. **スタミナ消費ログ**:
     ```php
     // UserService.php - consumeStamina()
     $this->logStaminaRepository->create(
         $usrUserId,
         LogResourceActionType::USE,
         $beforeStamina,
         $usrUserParameter->getStamina(),
         $logTrigger->getLogTriggerData(),
     );
     ```
     - 消費前・消費後の値を記録
     - トリガー情報（どこで消費したか）を記録

  2. **アイテム消費ログ**:
     ```php
     // UsrItemService.php - consumeItems()
     $logItems->push(
         $this->logItemRepository->make(
             $usrUserId,
             LogResourceActionType::USE,
             $mstItemId,
             $beforeAmount,
             $usrItem->getAmount(),
             $logTrigger->getLogTriggerData(),
         ),
     );
     $this->logItemRepository->addModels($logItems);
     ```
     - 消費前・消費後の所持数を記録
     - アイテムIDとトリガー情報を記録

  3. **ログテーブル構造**:
     - `log_staminas`: スタミナ増減ログ
     - `log_items`: アイテム増減ログ
     - `action_type`: USE, GET, ADDなどのアクション種別
     - `trigger_data`: JSONで詳細なトリガー情報を保存

- **元になったコードの抜粋**:
  ```php
  // UserService.php
  $this->logStaminaRepository->create(
      $usrUserId,
      LogResourceActionType::USE,
      $beforeStamina,
      $afterStamina,
      $logTrigger->getLogTriggerData(),
  );
  ```

- **備考**:
  - 仕様書の「要件7: イベント時の使用促進」に関連
  - **スタミナ回復アイテム使用時のログ記録が必須**
  - アイテム消費ログ + スタミナ増加ログの両方が必要
  - ログトリガーに「スタミナ回復アイテム使用」という情報を含める必要がある

---

## 既存実装パターンのまとめ

### 適用可能な既存パターン

1. **報酬配布パターン（要件C-5）**:
   - ログインボーナス、ミッション報酬でスタミナ回復アイテムを配布
   - RewardDelegator → ItemSendService の既存フローを利用

2. **アイテム使用パターン（要件C-6）**:
   - 既存の `/api/item/consume` APIを拡張
   - ItemService::apply() に新種別の処理を追加

3. **スタミナ回復計算パターン（要件C-1）**:
   - UserBuyStaminaService::calcAddStamina() のロジックを流用
   - ただし、回復率を50%（上限の半分）に設定

4. **自然回復適用パターン（要件C-2）**:
   - UserService::recoveryStamina() を先に呼び出し
   - その後にアイテムによる回復を適用

5. **上限超過時の廃棄パターン（要件C-3）**:
   - 報酬配布時の `RESOURCE_OVERFLOW_DISCARDED` 処理
   - 複数個使用時に999を超える分は廃棄

### 新規実装が必要な事項

1. **ItemType定義の追加（要件C-4）**:
   - `ItemType::STAMINA_RECOVERY` または `ItemType::ETC` の選択
   - glow-schema/Schema/Item.yml への追加

2. **ItemService::apply() への処理追加（要件C-6）**:
   - スタミナ回復アイテム種別の case 分岐
   - UserService::addStamina() 呼び出し

3. **ミッショントリガー送信（要件C-10）**:
   - アイテム使用時のトリガー送信実装

4. **ログ記録（要件C-11）**:
   - アイテム消費ログ + スタミナ増加ログの記録

---

## 不明点・確認事項（コード調査で新たに発見）

### 仕様の詳細確認が必要な項目

1. **スタミナ満タン時の使用可否（要件C-8）**:
   - 既存のスタミナ購入機能では満タン時は購入不可
   - スタミナ回復アイテムも同様の制約を設けるか
   - 選択肢:
     - A: 満タン時は使用不可（UI側でグレーアウト）
     - B: 満タン時も使用可能だが効果なし（アイテムは消費される）
     - C: 満タン時も使用可能で、上限を超えて回復（仕様書の記載と矛盾）

2. **ItemTypeの定義方針（要件C-4）**:
   - 新規ItemType `StaminaRecovery` を追加するか
   - 既存の `Etc` 種別を使用するか
   - 選択肢:
     - A: 新規種別を追加（拡張性高い、スキーマ変更必要）
     - B: `Etc` を使用（実装容易、種別判定が曖昧）

3. **複数個使用時の上限制御（要件C-3, C-9）**:
   - 10個使用時に999を超える場合の挙動
   - 選択肢:
     - A: UI側で上限を超えない個数のみ選択可能にする
     - B: サーバー側で999を超える分は廃棄（報酬配布パターン）
     - C: サーバー側でエラーを返す（スタミナ購入パターン）

4. **使用回数制限の有無（要件C-7）**:
   - 仕様書には記載なし
   - 広告視聴スタミナ購入のような日次制限を設けるか
   - 選択肢:
     - A: 回数制限なし（アイテム所持数のみが制約）
     - B: 日次回数制限あり（Clock機能を使用）

5. **ミッショントリガーの実装範囲（要件C-10）**:
   - 「スタミナ回復アイテムを使用する」ミッションが存在するか
   - アイテム獲得時のトリガー送信は既存パターンで実装済み
   - 使用時のトリガー送信が必要かどうか

---

## 次のステップ

このコード調査結果を元に、以下の作業を進めます:

1. **プランナー確認**: 上記の不明点・確認事項について企画側に質問し、仕様を明確化
2. **サーバー仕様レビュー**: 確定した仕様をもとに、実装方針を決定
3. **要件定義書作成**: サーバー側で実装すべき機能要件を詳細に定義
4. **API設計**: 必要なエンドポイント（既存API拡張 or 新規API）、リクエスト/レスポンス仕様を設計

---

## 備考

- 既存のスタミナ管理・アイテム管理システムは非常に体系的に実装されている
- スタミナ回復アイテムは、既存パターンの組み合わせで実装可能
- ただし、細かい仕様（満タン時の挙動、上限制御、回数制限など）は企画確認が必要
