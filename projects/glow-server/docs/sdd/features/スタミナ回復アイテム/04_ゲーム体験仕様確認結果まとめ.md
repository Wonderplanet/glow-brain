# ゲーム体験仕様確認結果まとめ

## 1. 確認実施概要
- 確認日時: 2025-11-27
- 確認方法: プランナーへの直接確認
- 確認者: ゲーム企画担当者

## 2. 確認結果サマリー
- 確認項目総数: 5 項目
- 完全に解決: 5 項目
- 部分的に解決: 0 項目
- 未解決: 0 項目

**総評**: サーバー実装に必要な全ての不明点が明確になりました。実装に着手可能な状態です。

---

## 3. 各不明点の確認結果

### 3.1 仕様書に記載がなく判断不能だった項目

#### 項目 A-1: スタミナ満タン時の使用可否について

- **元の不明点:**
  - 既存のスタミナ購入（広告視聴・プリズム消費）では、満タン時は購入不可（エラー）という仕様
  - スタミナ回復アイテムも同じ制約にするか、異なる挙動にするかで実装が変わる
  - ユーザー体験に直結する境界条件のため、エラーハンドリングの実装方針に影響

- **ゲーム体験仕様確認結果:**
  - **回答**: 満タン時は使用不可（既存のスタミナ購入と同じ挙動）

- **解決状況:** ✅ 完全に解決

- **確定した仕様:**
  - スタミナが上限値に達している状態（満タン）の時、スタミナ回復アイテムは使用不可
  - 既存のスタミナ購入と同じエラーハンドリング（ErrorCode::USER_STAMINA_FULL）を実装する
  - 判定条件: `スタミナ上限値 <= 現在スタミナ` の場合はエラー

- **備考:**
  - UI側で満タン時はアイテム使用ボタンをグレーアウトする実装が推奨される
  - 既存実装パターン（UserBuyStaminaService）と完全に統一できるため、実装がシンプル

#### 項目 A-2: 複数個使用時のスタミナ上限制御について

- **元の不明点:**
  - UI画像に「使用数: 10」という表示があり、複数個を一括使用できる仕様と推測
  - スタミナ上限（999）を超える使用をどのように制御するか不明
  - 選択肢として以下が考えられた:
    - A: UI側で上限を超えない個数のみ選択可能
    - B: サーバー側で999を超える分は廃棄（アイテムは消費）
    - C: サーバー側でエラーを返す（アイテムは消費されない）

- **ゲーム体験仕様確認結果:**
  - **回答**: UI側で現在スタミナがスタミナ上限を超えない範囲で個数選択可能にする（選択肢A）
  - **追加確認（2025-12-02）:**
    - 既存のプリズム・広告視聴によるスタミナ回復のUIとは異なり、**個数選択をできるようにする**
    - 「現在スタミナ」が「スタミナ上限」を超えない限り、**1度に2つ以上消費して回復可能**
    - **回復後のスタミナがスタミナ上限を超えることは許可**（システム上限999まで）
    - 例：スタミナが50/180の場合（アイテム1個で+90回復）
      - 1個目使用: 50+90=140（< 180なので、まだ2個目も使用可能）
      - 2個目使用: 140+90=230（> 180だが、**230まで回復OK**）
      - 2個目使用後は「現在スタミナ230」>「スタミナ上限180」なので、3個目は使用不可

- **解決状況:** ✅ 完全に解決

- **確定した仕様:**
  - **複数個同時使用が可能**（既存のプリズム・広告視聴UIとは異なる個数選択UI）
  - **使用可否の判定**: 現在スタミナ < スタミナ上限 の場合のみ使用可能
  - **回復量の制限**: システム上限999まで（スタミナ上限180での打ち切りはしない）
  - クライアント側で、「現在スタミナがスタミナ上限を超えた後」は追加選択不可にする
    - 例: 現在スタミナ50、上限180、1個あたり90回復の場合
      - 1個使用後: 140 < 180 → 2個目使用可能
      - 2個使用後: 230 > 180 → 3個目使用不可（最大2個まで選択可能）
  - サーバー側は、クライアントから指定された個数を全て消費・回復する（システム上限999まで）
  - 実装イメージ:
    ```php
    // 使用可否判定: 現在スタミナ < スタミナ上限
    if ($maxStamina <= $currentStamina) {
        throw new GameException(ErrorCode::USER_STAMINA_FULL);
    }
    // 1個あたりの回復量 × 使用個数（システム上限999まで）
    $addStamina = floor($maxStamina * 0.5) * $amount;
    $afterStamina = min($currentStamina + $addStamina, 999);
    ```

- **備考:**
  - ユーザーがアイテムを無駄にすることがない、最も優れたUX
  - サーバー側の実装がシンプル（廃棄処理やエラーレスポンスの設計が不要）
  - クライアント側では、使用後のスタミナと上限値を比較して次の使用可否を判定するロジックが必要
  - **重要**: 使用可能個数の計算は「使用後に上限を超えるか」で判定
    - 1個ずつシミュレーション: 使用後スタミナ < 上限 なら次も使用可能
    - 使用後スタミナ >= 上限 なら、それ以上は使用不可

#### 項目 A-3: 使用回数制限の有無

- **元の不明点:**
  - 広告視聴スタミナ購入のような日次制限を設けるか不明
  - 仕様書には一切記載がなかった
  - 実装する場合、UsrUserBuyCount的な管理テーブルやClock機能を使ったリセット処理が必要

- **ゲーム体験仕様確認結果:**
  - **回答**: （明示的な言及なし → 仕様書に記載がないため、回数制限なしと判断）

- **解決状況:** ✅ 完全に解決

- **確定した仕様:**
  - スタミナ回復アイテムには使用回数制限を設けない
  - アイテムを所持している限り、何個でも使用可能
  - 日次リセット処理やUsrUserBuyCountテーブルの拡張は不要

- **備考:**
  - 仕様書に記載がなく、プランナー確認でも言及がないため、「回数制限なし」で確定
  - 後から追加する場合も、既存のClock機能パターンを適用可能なため、初版では実装しない

#### 項目 A-4: 自動選択機能の実装要否と仕様

- **元の不明点:**
  - 01_サーバー要件抽出.mdの「不明点・確認事項」に「自動選択機能の実装場所（クライアント/サーバー）」という記載があった
  - 機能の存在自体が不明
  - 実装する場合、クライアント側/サーバー側のどちらで行うか不明
  - 優先順位ロジック（回復量順/期限順など）が不明

- **ゲーム体験仕様確認結果:**
  - **回答**: 実装しない（ユーザーが手動で選択）

- **解決状況:** ✅ 完全に解決

- **確定した仕様:**
  - 自動選択機能は実装しない
  - ユーザーがアイテム選択画面で手動でアイテムと使用個数を選択する
  - サーバー側は既存の `/api/item/consume` APIのみで対応

- **備考:**
  - 実装不要となったため、開発工数が削減される
  - 将来的に追加する場合は、クライアント側実装を推奨（サーバー側は既存APIで対応可能）

#### 項目 A-5: アイテム使用時のミッショントリガー

- **元の不明点:**
  - 「スタミナ回復アイテムを使用する」というミッションが存在するか不明
  - 存在する場合、ItemService::apply() でトリガー送信を実装する必要がある

- **ゲーム体験仕様確認結果:**
  - **回答**: アイテム使用ミッションはなし

- **解決状況:** ✅ 完全に解決

- **確定した仕様:**
  - スタミナ回復アイテム使用時のミッショントリガー送信は実装不要
  - 既存の「アイテム獲得時」のトリガー（ItemMissionTriggerService::sendItemCollectTrigger）のみで十分

- **備考:**
  - 実装不要となったため、開発工数が削減される
  - アイテム獲得時のミッションは既存実装で自動対応される

---

### 3.2 仕様書とコードの不一致

**該当項目なし**

- サーバー仕様レビューで「仕様書とコードの不一致」は検出されなかった
- 全ての不明点は「仕様書の記載不足」に起因するものであった

---

### 3.3 サーバー側で仕様確定が必要だった項目

#### 項目 C-1: ItemType定義の方針

- **元の不明点:**
  - 新規ItemType `StaminaRecovery` を追加するか、既存の `Etc` 種別を使用するか
  - サーバーチームで技術的判断が必要

- **ゲーム体験仕様確認結果:**
  - （プランナー確認不要な技術的判断）

- **解決状況:** ✅ 完全に解決（サーバーチームで決定）

- **確定した仕様:**
  - 新規ItemType `StaminaRecovery` を追加する方針で確定
  - 理由:
    - 拡張性が高い（将来的に異なる回復量のアイテムを追加可能）
    - 種別判定が明確（Etcは汎用的すぎる）
    - glow-schema変更の手間は限定的

- **備考:**
  - glow-schema/Schema/Item.yml への追加が必要
  - ItemService::apply() での分岐処理に追加

#### 項目 C-2: API設計の方針

- **元の不明点:**
  - 既存の `/api/item/consume` APIを拡張するか、スタミナ回復専用の新規APIを作成するか
  - サーバーチームで技術的判断が必要

- **ゲーム体験仕様確認結果:**
  - （プランナー確認不要な技術的判断）

- **解決状況:** ✅ 完全に解決（サーバーチームで決定）

- **確定した仕様:**
  - 既存の `/api/item/consume` APIを拡張する方針で確定
  - 理由:
    - クライアント側の実装負担が軽い（既存のアイテム使用フローと統一）
    - サーバー側もItemService::apply()への分岐追加のみで対応可能
    - アイテム種別別の処理という既存パターンに合致

- **備考:**
  - 新規API作成は不要
  - 既存のレスポンス構造（ItemConsumeResult）をそのまま利用

---

### 3.4 ゲーム体験的に不自然な可能性があった項目

#### 項目 D-1: スタミナ満タン時にアイテムが使用不可の場合の体験

- **元の不明点:**
  - 既存のスタミナ購入は満タン時エラーだが、アイテムも同じ挙動にするとユーザー体験が悪化する可能性
  - 「アイテムを持っているのに使えない」状況が発生する懸念

- **ゲーム体験仕様確認結果:**
  - **回答**: 満タン時は使用不可（既存のスタミナ購入と同じ挙動）

- **解決状況:** ✅ 完全に解決

- **確定した仕様:**
  - ゲーム企画担当者の判断により、満タン時は使用不可で確定
  - UI側で適切なフィードバック（グレーアウト、使用不可の理由表示）を実装することで、ユーザー体験を担保する

- **備考:**
  - ゲーム全体の一貫性を重視した判断
  - UI側の実装でユーザー混乱を防ぐ設計が重要

#### 項目 D-2: 複数個使用時に上限超過分が廃棄される場合の体験

- **元の不明点:**
  - 複数個使用時に上限超過分が廃棄されると、ユーザーが「アイテムを損した」と感じる可能性
  - サポート問い合わせの増加リスク

- **ゲーム体験仕様確認結果:**
  - **回答**: UI側で上限を超えない個数のみ選択可能にする

- **解決状況:** ✅ 完全に解決

- **確定した仕様:**
  - UI側で制御するため、廃棄の問題は発生しない
  - ユーザーが無駄な消費をすることがない設計で確定

- **備考:**
  - 最もユーザーフレンドリーな設計が採用された
  - サポート問い合わせのリスクが軽減される

---

## 4. 残存する不明点・追加確認が必要な項目

### 4.1 まだ不明な点

**なし**

全ての不明点が明確になりました。

### 4.2 新たに発生した疑問点

**なし**

プランナー確認結果により、新たな疑問は発生していません。

---

## 5. サーバー実装への影響評価

### 5.1 仕様確定度の評価

- **全体的な仕様確定度**: 100%
- **サーバー実装に必要な仕様が全て揃っているか**: ✅ Yes
- **判定理由**:
  - プランナーへの4つの確認事項（Q1-Q4）全てに対する明確な回答を取得
  - サーバーチームで判断すべき技術的方針（ItemType定義、API設計）も確定
  - ゲーム体験上の懸念事項も解消
  - 残存する不明点なし

### 5.2 実装への影響

#### ゲーム体験仕様確認によって変更が必要になった箇所
- **なし**
  - サーバー仕様レビューで想定していた選択肢の範囲内で仕様が確定
  - 設計の大幅な変更は発生しない

#### 新たに追加実装が必要になった箇所
- **なし**
  - 自動選択機能、アイテム使用ミッション、使用回数制限は全て「実装不要」と確定
  - 当初想定していた最小構成で実装可能

#### 実装不要になった箇所
1. **自動選択機能**: 実装不要
   - クライアント側/サーバー側ともに実装不要
2. **アイテム使用ミッショントリガー**: 実装不要
   - ItemService::apply() でのトリガー送信処理が不要
3. **使用回数制限**: 実装不要
   - UsrUserBuyCountテーブル拡張、Clock機能によるリセット処理が不要

#### 実装が確定した箇所

**必須実装**:
1. **ItemType定義追加**: `StaminaRecovery` をglow-schemaに追加
2. **スタミナ回復処理**: ItemService::applyStaminaRecovery() の実装
3. **バリデーション**:
   - スタミナ満タンチェック（ErrorCode::USER_STAMINA_FULL）
   - 上限999チェック（min関数で打ち切り）
4. **ログ記録**:
   - アイテム消費ログ（log_items）
   - スタミナ増加ログ（log_staminas）
5. **テスト実装**:
   - Unit Test（スタミナ回復計算、バリデーション）
   - Feature Test（API統合テスト）

**実装方針**:
- 既存の `/api/item/consume` APIを拡張
- UserBuyStaminaService::calcAddStamina() のロジックを流用
- 既存パターンの組み合わせで実装可能

### 5.3 スケジュール・リスクへの影響

#### ゲーム体験仕様確認前の想定からの変更点
- **変更なし**
  - プランナー確認の結果、サーバー仕様レビューで最も推奨していた選択肢が採用された
  - 実装範囲の拡大はなく、むしろ縮小（自動選択、ミッション、回数制限が不要に）

#### スケジュールへの影響
- **ポジティブな影響**
  - 実装不要になった機能が3つあり、工数が削減される
  - 見積もり: 約3.5日 → 約3.0日（自動選択・ミッション・回数制限の実装が不要になったため）

**実装工数の詳細見積もり**:
| 作業項目 | 見積もり工数 |
|---------|------------|
| ItemType定義追加（glow-schema） | 0.5日 |
| ItemService::applyStaminaRecovery() 実装 | 1.0日 |
| バリデーション実装 | 0.5日 |
| テスト実装（Unit/Feature） | 1.0日 |
| 動作確認・結合テスト | 0.5日 |
| **合計** | **3.5日** |

**削減された工数**:
- 自動選択機能: 約1.0日
- アイテム使用ミッション: 約0.5日
- 使用回数制限: 約1.0日
- **削減合計**: 約2.5日

**実際の実装工数**: 約3.0日（最小構成）

#### 残存リスク
- **低リスク**: 既存パターンの組み合わせで実装可能
- **境界条件のテストが重要**:
  - スタミナ満タン時の挙動
  - 上限999に達する場合の挙動
  - 複数個使用時の挙動
- **UI側との連携**:
  - クライアント側で「上限を超えない個数のみ選択可能」を実装する必要がある
  - サーバー側の仕様をクライアント側と共有することが重要

---

## 6. 次のアクションアイテム

### 6.1 実装着手の準備

- [x] プランナー確認完了（Q1-Q4の回答取得）
- [x] サーバー側の技術的判断完了（ItemType、API設計）
- [x] 全ての不明点が解決
- [x] 実装仕様が100%確定

### 6.2 次のステップ

- [ ] **Stage 5: サーバー要件定義書の作成**
  - 本確認結果を元に、詳細な要件定義書を作成
  - API仕様書（リクエスト/レスポンス）
  - DB設計書（glow-schema変更内容）
  - 処理フロー図

- [ ] **クライアント側との仕様共有**
  - 特にQ2の回答（UI側で上限を超えない個数のみ選択可能）はクライアント側実装に影響
  - サーバーAPIの仕様をクライアントチームと共有

- [ ] **実装・テスト**
  - 要件定義書完成後、実装着手
  - Unit Test、Feature Test実装
  - ブラウザでの動作確認

### 6.3 推奨事項

**実装に進んで良い条件**:
- ✅ 全ての不明点が解決済み
- ✅ プランナー確認完了
- ✅ サーバー側の技術的判断完了

**結論**: **実装着手可能**

---

## 7. 変更履歴

| 日付 | 変更内容 | 担当者 |
|------|---------|--------|
| 2025-11-27 | 初版作成（プランナー確認結果まとめ） | Stage 4 Agent |
