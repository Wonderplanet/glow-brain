name: å®Ÿè£…ç¢ºèªã‚·ãƒ¼ãƒˆç®¡ç†

on:
  issue_comment:
    types: [created]
  pull_request:
    types: [closed]

jobs:
  create-check-sheet:
    # PRã‚³ãƒ¡ãƒ³ãƒˆã§ã€ã‹ã¤ã€ŒTask linked:ã€ã‚’å«ã‚€ã‚³ãƒ¡ãƒ³ãƒˆã®ã¿å‡¦ç†å¯¾è±¡
    if: |
      github.event_name == 'issue_comment' &&
      github.event.issue.pull_request != null &&
      contains(github.event.comment.body, 'Task linked:')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: ClickUpã‚¿ã‚¹ã‚¯IDæŠ½å‡º
        id: extract-task
        run: |
          COMMENT_BODY="${{ github.event.comment.body }}"
          echo "Comment body: $COMMENT_BODY"

          # Task linked: [CU-xxxxx ã‚¿ã‚¤ãƒˆãƒ«](URL) ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æŠ½å‡º
          # ã‚¿ã‚¤ãƒˆãƒ«ã«ã¯è§’æ‹¬å¼§ãªã©ã‚ã‚‰ã‚†ã‚‹æ–‡å­—ãŒå«ã¾ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€URLã¾ã§ã®ä»»æ„ã®æ–‡å­—åˆ—ã«ãƒãƒƒãƒã•ã›ã‚‹
          if echo "$COMMENT_BODY" | grep -E 'Task linked:\s*\[CU-[a-zA-Z0-9]+\s+.*\]\(https://app\.clickup\.com/t/[a-zA-Z0-9]+\)' > /dev/null; then
            # CU-ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãªã—ã®IDã‚’æŠ½å‡ºï¼ˆClickUp APIç”¨ï¼‰
            TASK_ID=$(echo "$COMMENT_BODY" | grep -Eo '\[CU-[a-zA-Z0-9]+' | sed 's/\[CU-//' | head -1)
            TASK_URL_ID=$(echo "$COMMENT_BODY" | grep -Eo 'https://app\.clickup\.com/t/[a-zA-Z0-9]+' | sed 's|.*/||' | head -1)

            # APIç”¨ã®IDï¼ˆCU-ãªã—ï¼‰ã¨è¡¨ç¤ºç”¨ã®IDï¼ˆCU-ã‚ã‚Šï¼‰ã‚’ä¸¡æ–¹å‡ºåŠ›
            echo "task_id=${TASK_ID}" >> $GITHUB_OUTPUT
            echo "task_id_display=CU-${TASK_ID}" >> $GITHUB_OUTPUT
            echo "task_url_id=${TASK_URL_ID}" >> $GITHUB_OUTPUT
            echo "skip=false" >> $GITHUB_OUTPUT
            echo "Found ClickUp task: CU-${TASK_ID} (API ID: ${TASK_ID})"
          else
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "Skipping: ClickUp task link not found"
          fi

      - name: Checkout repository
        if: steps.extract-task.outputs.skip == 'false'
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: PRæƒ…å ±å–å¾—
        if: steps.extract-task.outputs.skip == 'false'
        id: pr-info
        run: |
          PR_NUMBER="${{ github.event.issue.number }}"
          PR_DATA=$(gh pr view $PR_NUMBER --json number,headRefName)
          PR_BRANCH=$(echo "$PR_DATA" | jq -r '.headRefName')

          echo "pr_number=${PR_NUMBER}" >> $GITHUB_OUTPUT
          echo "pr_branch=${PR_BRANCH}" >> $GITHUB_OUTPUT
          echo "PR Branch: ${PR_BRANCH}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: ClickUpã‚¿ã‚¹ã‚¯æƒ…å ±å–å¾—
        if: steps.extract-task.outputs.skip == 'false'
        id: clickup-task
        run: |
          # CU-ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãªã—ã®IDã‚’ä½¿ç”¨
          TASK_ID="${{ steps.extract-task.outputs.task_id }}"

          # ClickUp APIã§ã‚¿ã‚¹ã‚¯æƒ…å ±ã‚’å–å¾—
          HTTP_CODE=$(curl -s -o /tmp/clickup_response.json -w "%{http_code}" -X GET \
            "https://api.clickup.com/api/v2/task/${TASK_ID}" \
            -H "Authorization: ${{ secrets.CLICKUP_API_KEY }}" \
            -H "Content-Type: application/json")

          RESPONSE=$(cat /tmp/clickup_response.json)

          # HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’ãƒã‚§ãƒƒã‚¯
          if [ "$HTTP_CODE" -ne 200 ]; then
            echo "Error: ClickUp API returned HTTP $HTTP_CODE"
            echo "Response: $RESPONSE"
            exit 1
          fi

          # ã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ãƒã‚§ãƒƒã‚¯
          if echo "$RESPONSE" | jq -e '.err' > /dev/null 2>&1; then
            echo "Error: ClickUp API error: $(echo "$RESPONSE" | jq -r '.err')"
            exit 1
          fi

          # ã‚¿ã‚¹ã‚¯åã‚’å–å¾—
          TASK_NAME=$(echo "$RESPONSE" | jq -r '.name')
          TASK_URL=$(echo "$RESPONSE" | jq -r '.url')

          # ã‚¿ã‚¹ã‚¯åãŒå–å¾—ã§ããŸã‹ãƒã‚§ãƒƒã‚¯
          if [ "$TASK_NAME" = "null" ] || [ -z "$TASK_NAME" ]; then
            echo "Error: Failed to get task name from ClickUp API"
            echo "Response: $RESPONSE"
            exit 1
          fi

          # locationsé…åˆ—ã®æœ€åˆã®è¦ç´ ã®nameã‚’å–å¾—ã€ãªã‘ã‚Œã°list.nameã€ãã‚Œã‚‚ãªã‘ã‚Œã°"others"ã‚’ä½¿ç”¨
          LOCATION=$(echo "$RESPONSE" | jq -r '.locations[0].name // .list.name // "others"')

          echo "task_name=${TASK_NAME}" >> $GITHUB_OUTPUT
          echo "task_url=${TASK_URL}" >> $GITHUB_OUTPUT
          echo "location=${LOCATION}" >> $GITHUB_OUTPUT
          echo "Task: ${TASK_NAME}"
          echo "Location: ${LOCATION}"

      - name: ãƒ•ã‚¡ã‚¤ãƒ«åãƒ»å†…å®¹ç”Ÿæˆ
        if: steps.extract-task.outputs.skip == 'false'
        id: generate-file
        run: |
          # ç¾åœ¨æ—¥ä»˜å–å¾—ï¼ˆYYYYMMDDå½¢å¼ï¼‰
          DATE_STR=$(date +%Y%m%d)
          CURRENT_DATE=$(date +%Y-%m-%d)

          # ã‚¿ã‚¹ã‚¯IDã‚’å–å¾—
          TASK_ID="${{ steps.extract-task.outputs.task_id }}"

          # ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒˆãƒ«ã‹ã‚‰ä¸è¦æ–‡å­—ã‚’é™¤å»ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«åç”Ÿæˆ
          TASK_NAME="${{ steps.clickup-task.outputs.task_name }}"
          # ãƒ•ã‚¡ã‚¤ãƒ«åã¨ã—ã¦ä½¿ç”¨ã§ããªã„æ–‡å­—ï¼ˆ/, \, :, *, ?, ", <, >, |ï¼‰ã®ã¿ã‚’ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã«å¤‰æ›
          # ãã‚Œä»¥å¤–ã®æ–‡å­—ï¼ˆæ—¥æœ¬èªã€è¨˜å·å«ã‚€ï¼‰ã¯ä¿æŒ
          TASK_TITLE_CLEAN=$(echo "$TASK_NAME" | sed 's/[\/\\:*?"<>|]/_/g')
          FILE_NAME="${DATE_STR}_${TASK_ID}_${TASK_TITLE_CLEAN}.md"

          # ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ç”Ÿæˆï¼ˆlocationã‚’ãã®ã¾ã¾ãƒ•ã‚©ãƒ«ãƒ€åã¨ã—ã¦ä½¿ç”¨ï¼‰
          LOCATION="${{ steps.clickup-task.outputs.location }}"
          # ãƒ•ã‚©ãƒ«ãƒ€åã¨ã—ã¦ã‚‚ä¸æ­£ãªæ–‡å­—ã‚’ç½®æ›
          LOCATION_CLEAN=$(echo "$LOCATION" | sed 's/[\/\\:*?"<>|]/_/g')
          FILE_PATH="docs/impl_check_sheet/${LOCATION_CLEAN}/${FILE_NAME}"

          echo "file_name=${FILE_NAME}" >> $GITHUB_OUTPUT
          echo "file_path=${FILE_PATH}" >> $GITHUB_OUTPUT
          echo "current_date=${CURRENT_DATE}" >> $GITHUB_OUTPUT

          echo "Target file: ${FILE_PATH}"

      - name: PRãƒ–ãƒ©ãƒ³ãƒã«ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆ
        if: steps.extract-task.outputs.skip == 'false'
        run: |
          git fetch origin ${{ steps.pr-info.outputs.pr_branch }}
          git checkout ${{ steps.pr-info.outputs.pr_branch }}

      - name: ãƒ•ã‚¡ã‚¤ãƒ«å­˜åœ¨ãƒã‚§ãƒƒã‚¯
        if: steps.extract-task.outputs.skip == 'false'
        id: check-file-exists
        run: |
          TASK_ID="${{ steps.extract-task.outputs.task_id }}"

          # ã‚¿ã‚¹ã‚¯IDã‚’å«ã‚€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œç´¢ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«åãƒ‘ã‚¿ãƒ¼ãƒ³: *_taskid_*.mdï¼‰
          # docs/impl_check_sheet/é…ä¸‹ã®å…¨ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰æ¤œç´¢
          EXISTING_FILE=$(find "docs/impl_check_sheet/" -name "*_${TASK_ID}_*.md" 2>/dev/null | head -1)

          if [ -n "$EXISTING_FILE" ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "File already exists for task ${TASK_ID}: ${EXISTING_FILE}"
          else
            echo "skip=false" >> $GITHUB_OUTPUT
            echo "No file found for task ${TASK_ID}, will create new file"
          fi

      - name: Gitè¨­å®š
        if: steps.check-file-exists.outputs.skip == 'false'
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'

      - name: ã‚·ãƒ¼ãƒˆä½œæˆã‚³ãƒŸãƒƒãƒˆ
        if: steps.check-file-exists.outputs.skip == 'false'
        id: commit-sheet
        run: |
          FILE_PATH="${{ steps.generate-file.outputs.file_path }}"
          TASK_ID_DISPLAY="${{ steps.extract-task.outputs.task_id_display }}"
          TASK_NAME="${{ steps.clickup-task.outputs.task_name }}"
          TASK_URL="${{ steps.clickup-task.outputs.task_url }}"
          CURRENT_DATE="${{ steps.generate-file.outputs.current_date }}"
          LOCATION="${{ steps.clickup-task.outputs.location }}"
          LOCATION_CLEAN=$(echo "$LOCATION" | sed 's/[\/\\:*?"<>|]/_/g')

          # ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå–å¾—
          TEMPLATE=$(cat docs/impl_check_sheet/template.md)

          # ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¤‰æ•°ç½®æ›
          CONTENT=$(echo "$TEMPLATE" | sed \
            -e "s/{{TASK_TITLE}}/${TASK_NAME}/g" \
            -e "s|{{TASK_URL}}|${TASK_URL}|g" \
            -e "s/{{DATE}}/${CURRENT_DATE}/g")

          # ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
          if ! mkdir -p "docs/impl_check_sheet/${LOCATION_CLEAN}"; then
            echo "Error: Failed to create directory"
            exit 1
          fi

          # ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
          if ! echo "$CONTENT" > "${FILE_PATH}"; then
            echo "Error: Failed to create file"
            exit 1
          fi

          # Git add
          if ! git add "${FILE_PATH}"; then
            echo "Error: Failed to add file to git"
            exit 1
          fi

          # å¤‰æ›´ãŒã‚ã‚‹ã‹ç¢ºèª
          if ! git diff --cached --exit-code > /dev/null; then
            echo "File changes detected, committing..."
          else
            echo "Error: No file changes detected"
            exit 1
          fi

          # Git commit
          if ! git commit -m "feat: å®Ÿè£…ç¢ºèªã‚·ãƒ¼ãƒˆè¿½åŠ  (${TASK_ID_DISPLAY})"; then
            echo "Error: Commit failed"
            exit 1
          fi

          # Git push
          if ! git push origin ${{ steps.pr-info.outputs.pr_branch }}; then
            echo "Error: Push failed"
            exit 1
          fi

          echo "Committed and pushed: ${FILE_PATH}"

      - name: PRã«ã‚³ãƒ¡ãƒ³ãƒˆé€šçŸ¥
        if: steps.check-file-exists.outputs.skip == 'false'
        run: |
          FILE_PATH="${{ steps.generate-file.outputs.file_path }}"
          PR_NUMBER="${{ steps.pr-info.outputs.pr_number }}"

          cat <<EOF > /tmp/comment.txt
          âœ… å®Ÿè£…ç¢ºèªã‚·ãƒ¼ãƒˆã‚’ä½œæˆã—ã¾ã—ãŸã€‚

          ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«: \`${FILE_PATH}\`

          ã“ã®PRãƒ–ãƒ©ãƒ³ãƒã«å®Ÿè£…ç¢ºèªã‚·ãƒ¼ãƒˆãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚å†…å®¹ã‚’è¨˜å…¥ã—ã¦ã‚³ãƒŸãƒƒãƒˆã—ã¦ãã ã•ã„ã€‚
          EOF

          gh pr comment $PR_NUMBER --body-file /tmp/comment.txt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  notify-check-sheet:
    # PRãŒãƒãƒ¼ã‚¸ã•ã‚ŒãŸå ´åˆã®ã¿å®Ÿè¡Œ
    if: |
      github.event_name == 'pull_request' &&
      github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.ref }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: æ–°è¦è¿½åŠ ãƒ•ã‚¡ã‚¤ãƒ«æ¤œå‡º
        id: detect-new-files
        run: |
          # PRã§docs/impl_check_sheet/é…ä¸‹ã«è¿½åŠ ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œå‡º
          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"

          # æ—¥æœ¬èªãƒ•ã‚¡ã‚¤ãƒ«åã‚’æ­£ã—ãæ‰±ã†ãŸã‚ã«quotePathã‚’ç„¡åŠ¹åŒ–
          git config core.quotePath false

          echo "Comparing ${BASE_SHA}..${HEAD_SHA}"

          # ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
          NEW_FILES=$(git diff --name-only --diff-filter=A ${BASE_SHA} ${HEAD_SHA} | \
            grep 'docs/impl_check_sheet/' | \
            grep -v 'template\.md' | \
            grep -v 'README\.md' || true)

          echo "Found files:"
          echo "${NEW_FILES}"

          if [ -z "$NEW_FILES" ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "No new implementation check sheets found"
          else
            echo "skip=false" >> $GITHUB_OUTPUT
            # è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆã¯æœ€åˆã®1ã¤ã‚’å‡¦ç†ï¼ˆé€šå¸¸ã¯1ãƒ•ã‚¡ã‚¤ãƒ«ã®ã¯ãšï¼‰
            FILE_PATH=$(echo "$NEW_FILES" | head -1)
            echo "file_path=${FILE_PATH}" >> $GITHUB_OUTPUT
            echo "Found new check sheet: ${FILE_PATH}"
          fi

      - name: ClickUpã‚¿ã‚¹ã‚¯IDæŠ½å‡º
        if: steps.detect-new-files.outputs.skip == 'false'
        id: extract-task-id
        run: |
          FILE_PATH="${{ steps.detect-new-files.outputs.file_path }}"
          FILE_NAME=$(basename "$FILE_PATH")

          # ãƒ•ã‚¡ã‚¤ãƒ«åãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ: yyyymmdd_taskid_title.md
          # æœŸå¾…ã•ã‚Œã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³: 8æ¡ã®æ•°å­—_è‹±æ•°å­—ã¨ãƒã‚¤ãƒ•ãƒ³_ä»»æ„ã®æ–‡å­—åˆ—.md
          # ä¾‹: 20231225_abc123xyz_feature.md

          # ãƒ•ã‚¡ã‚¤ãƒ«åãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œè¨¼
          if ! echo "$FILE_NAME" | grep -E '^[0-9]{8}_[A-Za-z0-9-]+_.*\.md$' > /dev/null; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "::warning::Filename does not match expected pattern (yyyymmdd_taskid_title.md): ${FILE_NAME}"
            exit 0
          fi

          # æ­£è¦è¡¨ç¾ã‚’ä½¿ç”¨ã—ã¦TASK_IDã‚’æŠ½å‡ºï¼ˆæœ€åˆã¨2ç•ªç›®ã®ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã®é–“ï¼‰
          TASK_ID=$(echo "$FILE_NAME" | sed -E 's/^[0-9]{8}_([A-Za-z0-9-]+)_.*\.md$/\1/')

          # æŠ½å‡ºçµæœã®æ¤œè¨¼
          if [ -z "$TASK_ID" ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "::warning::Could not extract task ID from filename: ${FILE_NAME}"
            exit 0
          fi

          # TASK_IDã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ¤œè¨¼ï¼ˆè‹±æ•°å­—ã¨ãƒã‚¤ãƒ•ãƒ³ã®ã¿ã€1æ–‡å­—ä»¥ä¸Šï¼‰
          if ! echo "$TASK_ID" | grep -E '^[A-Za-z0-9-]+$' > /dev/null; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "::warning::Extracted task ID contains invalid characters: ${TASK_ID}"
            exit 0
          fi

          echo "skip=false" >> $GITHUB_OUTPUT
          echo "task_id=${TASK_ID}" >> $GITHUB_OUTPUT
          echo "Extracted task ID: ${TASK_ID}"

      - name: ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹è§£æ
        if: steps.extract-task-id.outputs.skip == 'false'
        id: parse-content
        run: |
          FILE_PATH="${{ steps.detect-new-files.outputs.file_path }}"

          # ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ
          IMPACT_FILE="/tmp/impact_items.txt"
          QA_FILE="/tmp/qa_notes.txt"

          # å½±éŸ¿ç¯„å›²ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã®æŠ½å‡ºï¼ˆ[x]ãŒã¤ã„ã¦ã„ã‚‹é …ç›®ï¼‰
          # "## å½±éŸ¿ç¯„å›²" ã‹ã‚‰ "##" ã§å§‹ã¾ã‚‹æ¬¡ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¾ã§ã‚’å¯¾è±¡
          awk '
            /^## å½±éŸ¿ç¯„å›²/ { in_section=1; next }
            /^## / && in_section { in_section=0 }
            in_section && /^- \[x\]/ {
              # "- [x] " ã‚’é™¤å»ã—ã¦é …ç›®åã®ã¿æŠ½å‡º
              gsub(/^- \[x\] /, "");
              print
            }
          ' "$FILE_PATH" > "$IMPACT_FILE"

          # QAé€£çµ¡äº‹é …ã®æŠ½å‡º
          # "## QAé€£çµ¡äº‹é …" ã‹ã‚‰ "---" ã¾ãŸã¯æ¬¡ã® "##" ã¾ã§
          awk '
            /^## QAé€£çµ¡äº‹é …/ { in_section=1; next }
            /^---$/ && in_section { in_section=0; next }
            /^## / && in_section { in_section=0 }
            in_section && NF { print }
          ' "$FILE_PATH" > "$QA_FILE"

          # ãƒ•ã‚¡ã‚¤ãƒ«ãŒç©ºã§ãªã„ã‹ç¢ºèª
          if [ ! -s "$IMPACT_FILE" ] && [ ! -s "$QA_FILE" ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "No impact items or QA notes found"
          else
            echo "skip=false" >> $GITHUB_OUTPUT
            echo "Parsed content successfully"
          fi

      - name: ClickUpã‚³ãƒ¡ãƒ³ãƒˆæŠ•ç¨¿
        if: steps.parse-content.outputs.skip == 'false'
        env:
          TASK_ID: ${{ steps.extract-task-id.outputs.task_id }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_URL: ${{ github.event.pull_request.html_url }}
        run: |
          # ã‚³ãƒ¡ãƒ³ãƒˆæœ¬æ–‡ã‚’æ§‹ç¯‰
          echo "(PRã‹ã‚‰ã®è‡ªå‹•æŠ•ç¨¿ã§ã™)" > /tmp/comment.md
          echo "" >> /tmp/comment.md
          echo "## å®Ÿè£…å†…å®¹ã«ã¤ã„ã¦" >> /tmp/comment.md
          echo "" >> /tmp/comment.md
          echo "### å½±éŸ¿ç¯„å›²" >> /tmp/comment.md

          # å½±éŸ¿ç¯„å›²ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã‚’è¿½åŠ 
          if [ -s /tmp/impact_items.txt ]; then
            while IFS= read -r line; do
              echo "- $line" >> /tmp/comment.md
            done < /tmp/impact_items.txt
          else
            echo "- ï¼ˆãƒã‚§ãƒƒã‚¯é …ç›®ãªã—ï¼‰" >> /tmp/comment.md
          fi

          # QAé€£çµ¡äº‹é …ã‚’è¿½åŠ 
          echo "" >> /tmp/comment.md
          echo "### QAé€£çµ¡äº‹é …" >> /tmp/comment.md

          if [ -s /tmp/qa_notes.txt ]; then
            cat /tmp/qa_notes.txt >> /tmp/comment.md
          else
            echo "ï¼ˆè¨˜è¼‰ãªã—ï¼‰" >> /tmp/comment.md
          fi

          # PRæƒ…å ±ã‚’æœ€å¾Œã«è¿½åŠ 
          echo "" >> /tmp/comment.md
          echo "---" >> /tmp/comment.md
          echo "" >> /tmp/comment.md
          echo "PR: [#${PR_NUMBER} ${PR_TITLE}](${PR_URL})" >> /tmp/comment.md

          # ClickUp APIã§ã‚³ãƒ¡ãƒ³ãƒˆæŠ•ç¨¿
          COMMENT_TEXT=$(cat /tmp/comment.md)

          # JSONã‚¨ã‚¹ã‚±ãƒ¼ãƒ—å‡¦ç†
          COMMENT_JSON=$(jq -n --arg text "$COMMENT_TEXT" '{comment_text: $text}')

          # ClickUp APIã¸ã®ã‚³ãƒ¡ãƒ³ãƒˆæŠ•ç¨¿ï¼ˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä»˜ãï¼‰
          HTTP_CODE=$(curl -X POST \
            "https://api.clickup.com/api/v2/task/${TASK_ID}/comment" \
            -H "Authorization: ${{ secrets.CLICKUP_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d "$COMMENT_JSON" \
            -w "%{http_code}" \
            -s -o /tmp/curl_response.txt)

          # HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ã®æ¤œè¨¼
          if [ "$HTTP_CODE" != "200" ] && [ "$HTTP_CODE" != "201" ]; then
            echo "::error::ClickUp API error - HTTP Status: $HTTP_CODE"
            echo "Response body:"
            cat /tmp/curl_response.txt
            exit 1
          fi

          echo "Posted comment to ClickUp task: ${TASK_ID}"
