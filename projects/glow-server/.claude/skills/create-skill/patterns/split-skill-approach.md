# 分割スキルアプローチ

複数のスキルに分割して作成する場合のパターンとワークフローを説明します。

## このアプローチを選択すべき場合

以下の条件に当てはまる場合、分割スキルアプローチが適しています：

### 1. 責務が明確に独立している

- 各機能が独立して使われることがある
- フェーズが明確に分かれている
- 使用タイミングが異なる

**例:**
- API調査 → API実装 → APIテスト（各フェーズで独立）
- データ取得 → 画面表示（技術領域が異なる）

### 2. スコープが大きい

- 対象ファイルが10個以上
- 実装パターンが5つ以上
- SKILL.mdが100行を超えそう
- 参照ファイルが8個以上必要

### 3. 技術スタックが異なる

- 異なるツール・ライブラリを3つ以上使う
- 複数の技術領域にまたがる
- アーキテクチャ層が異なる

**例:**
- バックエンド（Laravel/Eloquent） + フロントエンド（Filament/Blade）
- データベース設計 + ビジネスロジック + API契約

### 4. 複数フェーズのワークフロー

- 調査 → 計画 → 実装 → 検証など、明確なフェーズがある
- 各フェーズで異なるツールやアプローチを使う
- フェーズ間で成果物が明確に分かれる

## 分割パターン

### パターン1: フェーズ別分割

**特徴:** 開発フローに沿って分割

**構成例（API開発）:**

```
1. api-research (調査・分析)
   - 既存実装の調査
   - 依存関係の特定
   - 影響範囲の分析
   - 使用タイミング: API改修前

2. api-implementation (実装)
   - マイグレーション作成
   - モデル・コントローラー実装
   - サービスロジック実装
   - 使用タイミング: API実装中

3. api-testing (テスト)
   - テストケース作成
   - テスト実行・デバッグ
   - カバレッジ確認
   - 使用タイミング: テスト作成・実行時
```

**メリット:**
- 開発フローが明確
- 各フェーズで集中できる
- 必要なフェーズだけを使える

**デメリット:**
- スキル間の連携が必要
- フェーズをまたいだ変更が面倒

**適している場合:**
- 開発プロセスが定型化されている
- 各フェーズの担当者が異なる
- フェーズごとにレビューがある

### パターン2: 技術領域別分割

**特徴:** 技術スタックや責務に沿って分割

**構成例（Admin開発）:**

```
1. admin-data-provider (データ取得・処理)
   - Repository実装
   - Query構築
   - N+1対策
   - リレーション設定
   - 使用タイミング: データ層の実装

2. admin-ui-builder (UI構築)
   - Filament Resource実装
   - Table/Form定義
   - Action設定
   - バリデーション
   - 使用タイミング: UI層の実装
```

**メリット:**
- 技術領域が明確
- 専門性を発揮しやすい
- 独立して進められる

**デメリット:**
- 全体像の把握が難しい
- 統合時に調整が必要

**適している場合:**
- 技術スタックが大きく異なる
- 専門家がそれぞれ担当する
- 各層を独立してテストできる

### パターン3: 機能別分割

**特徴:** 提供する機能ごとに分割

**構成例（報酬システム）:**

```
1. reward-display (報酬表示)
   - テーブル表示
   - 詳細ページ表示
   - フォーム表示
   - 使用タイミング: 報酬情報の表示実装

2. reward-send (報酬送付)
   - RewardSendService実装
   - ポリシー設定
   - エラーハンドリング
   - 使用タイミング: 報酬配布機能の実装

3. reward-validation (報酬検証)
   - 所持確認
   - 期限チェック
   - 数量検証
   - 使用タイミング: 報酬バリデーション実装
```

**メリット:**
- 機能ごとに完結
- 機能追加が容易
- 機能単位でのテストが可能

**デメリット:**
- 機能間の連携が複雑
- 重複する実装が発生しやすい

**適している場合:**
- 機能が明確に分かれている
- 機能ごとに異なる開発サイクル
- 段階的なリリースが可能

### パターン4: 複雑度別分割

**特徴:** 基本機能と応用機能を分割

**構成例（データベース操作）:**

```
1. database-basic (基本操作)
   - CRUD操作
   - シンプルなクエリ
   - 単一テーブル操作
   - 使用タイミング: 基本的なDB操作

2. database-advanced (応用操作)
   - 複雑なJOIN
   - サブクエリ
   - トランザクション
   - パフォーマンス最適化
   - 使用タイミング: 高度なDB操作
```

**メリット:**
- 学習曲線が緩やか
- 基本から段階的に習得
- 初心者にも使いやすい

**デメリット:**
- 線引きが難しい
- どちらを使うか判断が必要

**適している場合:**
- スキルレベルに幅がある
- 教育・学習目的
- 段階的な導入が必要

## 分割スキルの設計ワークフロー

### ステップ1: 全体像の把握

まず、対象範囲全体を俯瞰します。

```
1. 対象ファイルをリストアップ
2. 実装パターンを抽出
3. ツール・ライブラリを列挙
4. ワークフローを図示
```

### ステップ2: 分割軸の決定

どのパターンで分割するか決定します。

```
質問：
- フェーズは明確に分かれているか？ → フェーズ別
- 技術スタックは大きく異なるか？ → 技術領域別
- 機能は独立しているか？ → 機能別
- 複雑度に差があるか？ → 複雑度別
```

### ステップ3: スキルの境界を定義

各スキルの責務範囲を明確にします。

```
各スキルについて：
1. スキル名を決定
2. 責務を明確化
3. 使用タイミングを定義
4. 対象ファイルを割り当て
5. 想定規模を見積もり
```

### ステップ4: スキル間の連携を設計

スキル間のインターフェースを定義します。

```
1. 典型的な使用フローを定義
2. スキル間のデータ受け渡しを明確化
3. 各スキルのSKILL.mdに関連スキルを記載
```

### ステップ5: 各スキルの実装

各スキルを個別に実装します。

```
各スキルについて：
1. SKILL.md作成（30-50行）
2. guides/作成
3. patterns/作成
4. examples/作成
5. 検証チェックリスト確認
```

## スキル間の連携方法

### 関連スキルセクションの追加

各SKILL.mdに関連スキルセクションを追加します。

```markdown
## 関連スキル

このスキルは以下のスキルと連携して動作します：

- **[api-research](../api-research/SKILL.md)** - API実装前の調査・分析
- **[api-testing](../api-testing/SKILL.md)** - API実装後のテスト

**典型的な使用フロー:**
1. `api-research` で既存実装を調査
2. **`api-implementation`** で実装（このスキル）
3. `api-testing` でテストを作成・実行
```

### 共通リソースの管理

複数スキルで共有する情報は、共通ディレクトリに配置します。

```
.claude/skills/
├── api-common/
│   ├── architecture.md       # 全スキル共通のアーキテクチャ
│   ├── conventions.md        # 命名規則など
│   └── glossary.md          # 用語集
├── api-research/
│   └── SKILL.md             # api-commonを参照
├── api-implementation/
│   └── SKILL.md             # api-commonを参照
└── api-testing/
    └── SKILL.md             # api-commonを参照
```

### ラッパースキルの作成（オプション）

複数スキルを統合的に案内するラッパースキルを作成できます。

```
.claude/skills/api-development/
└── SKILL.md

---
name: API Development Workflow
description: API開発の全体フローを案内。調査・実装・テストの各スキルへの導線を提供する。
---

# API Development Workflow

API開発の全体的なワークフローを案内します。

## Instructions

### 1. 調査・分析

既存実装を調査し、依存関係を特定します。
→ **[api-research スキル](../api-research/SKILL.md)** を使用

### 2. 実装

API実装を行います。
→ **[api-implementation スキル](../api-implementation/SKILL.md)** を使用

### 3. テスト

実装したAPIのテストを行います。
→ **[api-testing スキル](../api-testing/SKILL.md)** を使用
```

## 成功例の紹介

詳細な成功例は以下を参照してください：
- **[API開発の分割例](../examples/split-example-api-dev.md)** - 3つのスキルに分割した実例
- **[Admin開発の分割例](../examples/split-example-admin.md)** - 2つのスキルに分割した実例

## 注意点とベストプラクティス

### 過度な分割を避ける

**悪い例:**
```
- api-request-validation
- api-controller-implementation
- api-service-implementation
- api-repository-implementation
- api-model-implementation
- api-response-generation
```
→ 細かすぎて全体像が見えない

**良い例:**
```
- api-implementation (Controller/Service/Repository/Modelをまとめる)
- api-testing
```
→ 適度な粒度で全体像も把握しやすい

### スキル名の命名規則

**推奨形式:** `{domain}-{responsibility}`

**例:**
- ✅ `api-implementation` (ドメイン: api, 責務: implementation)
- ✅ `admin-data-provider` (ドメイン: admin, 責務: data-provider)
- ❌ `implementation` (ドメインが不明確)
- ❌ `api-skill` (責務が不明確)

### description の一貫性

同じドメインのスキルは、descriptionの形式を統一します。

**例:**
```yaml
# api-research
description: API実装前の調査・分析を行う際に使用。既存実装の調査、依存関係の特定、影響範囲の分析を行う。

# api-implementation
description: API実装を行う際に使用。マイグレーション、モデル、コントローラーの実装を行う。

# api-testing
description: API実装後のテストを行う際に使用。Unit/Feature/Scenarioテストの作成と実行を行う。
```

## まとめ

分割スキルアプローチは以下の場合に最適です：

✅ **適している場合:**
- 責務が明確に独立
- スコープが大きい（ファイル10個以上）
- 技術スタックが異なる
- 異なる使用タイミング

❌ **適していない場合:**
- 責務が密接に関連
- スコープが小さい（ファイル10個未満）
- 技術スタックが統一
- 常に一連の流れで使用

分割のメリット：
- 各スキルの責務が明確
- 独立して保守可能
- 必要なスキルだけを読み込める
- トークン消費を削減できる

分割のデメリット：
- 全体像の把握が難しい
- スキル間の連携が必要
- ファイル数が増える
