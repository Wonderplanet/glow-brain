# オーケストレーション戦略

## 実行フロー図

```
[Stage 1] → [Stage 2] → [Stage 3] → [人間確認待ち] → [Stage 4] → [Stage 5]
                                                                        ↓
                                                          ┌─────────────┼─────────────┐
                                                          ↓             ↓             ↓
                                                      [Stage 6]     [Stage 7]     [Stage 8]
                                                       (並列)        (並列)        (並列)
```

## 実装手順

### 1. 要件定義フェーズ（Stage 1-3）を順次実行

**Task toolの使用：**
```
Task tool を使用して以下のサブエージェントを順次実行：
- sdd-extract-server-requirements
- sdd-investigate-code-requirements
- sdd-review-server-spec
```

**注意点：**
- Stage 2はStage 1の出力ファイルに依存
- Stage 3はStage 1, 2の両方の出力ファイルに依存
- 順次実行が必須（並列実行不可）

### 2. 人間確認を待機（Stage 4）

**AskUserQuestion toolの使用：**
```
AskUserQuestion tool を使用して：
1. Stage 3の出力ファイル（サーバー仕様レビュー.md）を確認
2. プランナー確認項目リストを提示
3. ユーザーにプランナーへの確認を依頼
4. 確認結果を受け取る
```

**人間確認の手順：**
1. `docs/sdd/features/{機能名}/サーバー仕様レビュー.md` を確認
2. プランナー確認項目リストを使って、企画担当者に確認
3. 確認結果をまとめる（メール、会議メモ、チャットログなど）
4. オーケストレーターに確認結果を提供

### 3. Stage 4-5を順次実行

**Task toolの使用：**
```
Task tool を使用して以下のサブエージェントを順次実行：
- sdd-confirm-game-experience-spec（人間確認結果を入力）
- sdd-finalize-server-requirements
```

**注意点：**
- Stage 4には人間確認結果を明示的に渡す
- Stage 5はStage 1～4の全出力ファイルを統合

### 4. 設計フェーズ（Stage 6-8）を並列実行

**Task toolの並列使用：**
```
Task tool を使用して以下のサブエージェントを並列実行：
- sdd-overview-api-design
- sdd-create-api-design
- sdd-design-api-implementation

⚠️ 並列実行する場合、単一メッセージで複数のTask toolを呼び出すこと
```

**並列実行の条件：**
- Stage 6-8は全てStage 5の出力ファイル（`サーバーAPI要件書.md`）のみに依存
- 相互に依存関係がない
- それぞれが独立したサブエージェントとして実行可能

---

## 並列実行の最適化

### 要件定義フェーズ（Stage 1-5）

| Stage | 実行方式 | 理由 |
|-------|---------|------|
| Stage 1-3 | **順次実行** | 相互に依存関係がある |
| Stage 4 | **人間確認待ち** | プランナーへの確認が必要 |
| Stage 5 | **順次実行** | Stage 1-4の全出力に依存 |

### 設計フェーズ（Stage 6-8）

| Stage | 実行方式 | 理由 |
|-------|---------|------|
| Stage 6-8 | **並列実行可能** | 全てStage 5の出力ファイルのみに依存 |

**並列実行のメリット：**
- 設計フェーズの所要時間を約60%短縮（30分 → 12分）
- 各段階が独立してサブエージェントで実行されるため、コンテキスト効率が向上
- トークン消費を削減

---

## オーケストレーションパターンの比較

### パターン1: 完全順次実行

```
Stage 1 → Stage 2 → Stage 3 → [人間確認] → Stage 4 → Stage 5 → Stage 6 → Stage 7 → Stage 8
```

**特徴：**
- 最もシンプル
- デバッグしやすい
- 所要時間: 約50分（Stage 4を除く）

**適用ケース：**
- 初回実行時
- デバッグが必要な場合
- Stage 6-8間に不整合が発生した場合

### パターン2: 設計フェーズ並列実行（推奨）

```
Stage 1 → Stage 2 → Stage 3 → [人間確認] → Stage 4 → Stage 5
                                                        ↓
                                          ┌─────────────┼─────────────┐
                                          ↓             ↓             ↓
                                      Stage 6       Stage 7       Stage 8
```

**特徴：**
- 設計フェーズを並列実行
- 所要時間: 約25～30分（Stage 4を除く）
- 約60%の時間短縮

**適用ケース：**
- 通常の実行（推奨）
- 要件が明確な場合
- Stage 6-8の内容が独立している場合

### パターン3: ハイブリッド実行

```
Stage 1-5を順次実行（要件定義完了）
    ↓
Stage 6を先に実行（全体像把握）
    ↓
Stage 7, 8を並列実行（詳細設計）
```

**特徴：**
- Stage 6で全体像を把握してからStage 7, 8を実行
- 複雑な機能の場合に有効

**適用ケース：**
- 複数のAPIエンドポイントが絡む複雑な機能
- 既存APIとの整合性確認が重要な場合

---

## トークン消費の最適化

### コンテキスト効率の向上

各段階で独立したサブエージェントを使用するため、コンテキスト効率が向上：

| 実行方式 | 推定トークン消費 | 削減率 |
|---------|----------------|--------|
| 手動で全段階実行 | 約200K tokens | - |
| オーケストレーター（順次実行） | 約160K tokens | 20%削減 |
| オーケストレーター（並列実行） | 約140K tokens | 30%削減 |

### トークン削減の理由

1. **各段階で不要なコンテキストをクリア**
   - 各サブエージェントは独立して実行
   - 前段階のコンテキストを引き継がない

2. **必要な情報のみファイル経由で受け渡し**
   - Stage間のデータ受け渡しは出力ファイル経由
   - 不要な会話履歴を含まない

3. **段階間の重複を排除**
   - 各Stageは特定の責務のみに集中
   - 重複する調査や分析を避ける

4. **設計フェーズの並列実行**
   - Stage 6-8が同時に開始
   - コンテキストの再利用を最小化

### Progressive Disclosureの適用

このスキル自体もProgressive Disclosureパターンを採用：

```
SKILL.md (119行)
├─ stage-details.md (詳細な責務・入出力仕様)
├─ orchestration-patterns.md (このファイル)
├─ examples.md (具体的な使用例)
└─ troubleshooting.md (エラーハンドリング)
```

**効果：**
- SKILL.mdの読み込みトークンを70%削減（435行 → 119行）
- 必要な情報のみオンデマンドで読み込み
- スキル起動の高速化

---

## サブエージェント間のデータフロー

### ファイルベースのデータ受け渡し

```
Stage 1 (sdd-extract-server-requirements)
    ↓ [サーバー要件抽出.md]
Stage 2 (sdd-investigate-code-requirements)
    ↓ [サーバー要件_コード調査追記.md]
Stage 3 (sdd-review-server-spec)
    ↓ [サーバー仕様レビュー.md + プランナー確認項目リスト]
[人間確認]
    ↓ [確認結果]
Stage 4 (sdd-confirm-game-experience-spec)
    ↓ [ゲーム体験仕様確認結果まとめ.md]
Stage 5 (sdd-finalize-server-requirements)
    ↓ [サーバーAPI要件書.md]
    ├→ Stage 6 (sdd-overview-api-design) → [API実装全体概要設計.md]
    ├→ Stage 7 (sdd-create-api-design) → [サーバーAPI設計書.md]
    └→ Stage 8 (sdd-design-api-implementation) → [サーバーAPI機能要件実装設計.md]
```

### データフォーマットの統一

**Markdown形式で統一：**
- 読みやすさ
- バージョン管理が容易
- 人間とAIの両方が扱いやすい

**ファイル名の規則：**
- Stage番号は含めない（内容で識別）
- 日本語ファイル名（プロジェクト標準）
- 機能名ディレクトリで整理

---

## オーケストレーションのベストプラクティス

### 1. 責任の分離

| 原則 | 説明 | 実装例 |
|------|------|--------|
| **単一責任** | 各サブエージェント = 単一職務 | sdd-extract-server-requirementsは要件抽出のみ |
| **コンテキスト分離** | グローバル状態をオーケストレーターのみで保持 | 各エージェントは独立して結果を報告 |
| **最小権限** | 各エージェントに必要なツールのみ付与 | read-only agentはWrite禁止 |

### 2. エラーハンドリング

- 各Stageでエラーチェックを実行
- エラー時は該当Stageから再実行可能
- 詳細は[troubleshooting.md](troubleshooting.md)を参照

### 3. 進捗の可視性

- 各Stageの完了時に出力ファイルを生成
- ユーザーはいつでも進捗を確認可能
- 中断・再開が容易

### 4. 冪等性の確保

- 各Stageは何度実行しても同じ結果
- 前回の出力ファイルを上書き
- 部分的な再実行が安全

---

## パフォーマンス指標

### 所要時間の目安

| フェーズ | Stage | 所要時間（目安） |
|---------|-------|----------------|
| 要件定義 | Stage 1 | 3～5分 |
| 要件定義 | Stage 2 | 3～5分 |
| 要件定義 | Stage 3 | 3～5分 |
| 要件定義 | Stage 4 | 2～3分（人間確認は除く） |
| 要件定義 | Stage 5 | 3～5分 |
| 設計 | Stage 6-8（並列） | 10～12分 |
| **合計** | | **25～30分** |

### トークン消費の目安

| フェーズ | 推定トークン |
|---------|-------------|
| 要件定義（Stage 1-5） | 約60K tokens |
| 設計（Stage 6-8、並列） | 約80K tokens |
| **合計** | **約140K tokens** |

**注意：**
- 機能の複雑さにより変動
- 既存コードの量により変動
- glow-schemaの複雑さにより変動
