// ReSharper disable RedundantUsingDirective
// ReSharper disable InconsistentNaming
#pragma warning disable CS8632 // nullable reference types should only be used in code within a '#nullable' annotations context.
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using UnityEngine;
using WondlerPlanet.CheatProtectKit.ObscuredTypes;
using GLOW.Core.Domain.Constants;

// ----------------------------------------------------------------------
// This file is auto-generated by SchemaBuilder. Do not modify directly.
// ----------------------------------------------------------------------

namespace GLOW.Core.Data.Data
{
    [Serializable]
    public class <%= schema["name"] %>Data
    {
        <%- schema["params"].each do |p| -%>
          <%-
            # yml上の定義からの変換ルールを定義
            t = case p["type"]
            when "int"
              "ObscuredInt"
            when "long"
              "ObscuredLong"
            when "float"
              "ObscuredFloat"
            when "double"
              "ObscuredDouble"
            when "bool"
              "ObscuredBool"
            when "string"
              "ObscuredString"
            when "int?"
              "ObscuredInt?"
            when "long?"
              "ObscuredLong?"
            when "float?"
              "ObscuredFloat?"
            when "double?"
              "ObscuredDouble?"
            when "bool?"
              "ObscuredBool?"
            when "string?"
              "ObscuredString?"
            when "string[]"
              "ObscuredString[]"
            else
              p["type"]
            end
          -%>
        [DataMember(Name = "<%= p["name"] %>")][JsonProperty("<%= p["name"] %>")]
          <%- if !schema["obscure"] || t == p["type"] -%>
        public <%= p["type"] %> <%= p["name"].camelize %> { get; set; }
          <%- else -%>
        public <%= p["type"] %> <%= p["name"].camelize %> 
        {
            <%- if p["type"] == "string[]" -%>
            get => <%="_obscured_" + p["name"] + "?.Select(x => (string)x).ToArray();"%>
            set => <%="_obscured_" + p["name"] + " = value.Select(x  => (ObscuredString)x).ToArray();"%>
            <%- else -%>
            get => <%= "_obscured_" + p["name"] %>;
            <%- if p["type"] == "string" -%>
            set => <%= "_obscured_" + p["name"] %> = value ?? string.Empty;
            <%- else -%>
            set => <%= "_obscured_" + p["name"] %> = value;
            <%- end #if -%>
            <%- end #if -%>
        }
          <%- end #if -%>
        <%- end #schema["params"].each do-%>

        <%- if schema["aliases"] -%>
          <%- schema["aliases"].each do |p| -%>
        public <%= schema["params"].find{|e| e["name"] == p["src"]}["type"] %> <%= p["name"].camelize %> => <%= p["src"].camelize %>;
          <%- end # schema["aliases"].each do-%>
        <%- end # if-%>

        <%- schema["params"].each do |p| -%>
          <%-
          t = case p["type"]
          when "int"
            "ObscuredInt"
          when "long"
            "ObscuredLong"
          when "float"
            "ObscuredFloat"
          when "double"
            "ObscuredDouble"
          when "bool"
            "ObscuredBool"
          when "string"
            "ObscuredString"
          when "int?"
            "ObscuredInt?"
          when "long?"
            "ObscuredLong?"
          when "float?"
            "ObscuredFloat?"
          when "double?"
            "ObscuredDouble?"
          when "bool?"
            "ObscuredBool?"
          when "string?"
            "ObscuredString?"
          when "string[]"
            "ObscuredString[]"
          else
            p["type"]
          end
          -%>
          <%- if schema["obscure"] && t != p["type"] -%>
        <%= t %> <%= ("_obscured_" + p["name"]) %>;
          <%- end #if -%>
        <%- end #schema["params"].each do -%>
    }
}
